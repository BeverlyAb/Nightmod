({:ns "play-clj.core", :groups ({:raw* "(defn defscreen*\n  [{:keys [screen entities\n           on-show on-render on-hide on-pause on-resize on-resume on-timer]\n    :as options}]\n  (let [execute-fn! (fn [func & {:keys [] :as options}]\n                      (when func\n                        (let [screen-map (merge @screen options)\n                              old-entities @entities]\n                          (some->> (fn []\n                                     (normalize (func screen-map old-entities)))\n                                   (wrapper screen)\n                                   (reset-changed! entities old-entities)))))]\n    ; add the input listeners to the screen atom\n    (when-not (:input-listeners @screen)\n      (->> (input-listeners options execute-fn!)\n           (swap! screen assoc :input-listeners)))\n    ; update screen when either the screen or entities are changed\n    (add-watch screen :changed (fn [_ _ _ new-screen]\n                                 (update-screen! new-screen)))\n    (add-watch entities :changed (fn [_ _ _ new-entities]\n                                   (update-screen! @screen new-entities)))\n    ; return a map with all values related to the screen\n    {:screen screen\n     :entities entities\n     :show (fn []\n             (swap! screen assoc\n                    :total-time 0\n                    :update-fn! #(apply swap! screen %1 %2)\n                    :execute-fn! execute-fn!\n                    :on-timer on-timer\n                    :ui-listeners (ui-listeners options execute-fn!))\n             (execute-fn! on-show)\n             (when-not (:contact-listener @screen)\n               (->> (contact-listener @screen options execute-fn!)\n                    (swap! screen assoc :contact-listener))))\n     :render (fn [d]\n               (swap! screen #(assoc % :total-time (+ (:total-time %) d)))\n               (execute-fn! on-render :delta-time d))\n     :hide #(execute-fn! on-hide)\n     :pause #(execute-fn! on-pause)\n     :resize #(execute-fn! on-resize :width %1 :height %2)\n     :resume #(execute-fn! on-resume)}))", :arglists [(defscreen n & options)], :java [], :name "defscreen", :type :code, :raw "(defmacro defscreen\n  [n & {:keys [] :as options}]\n  `(let [fn-syms# (->> (for [[k# v#] ~options]\n                         [k# (intern *ns* (symbol (str '~n \"-\" (name k#))) v#)])\n                       flatten\n                       (apply hash-map))\n         map-sym# (symbol (str '~n \"-map\"))\n         entities-sym# (symbol (str '~n \"-entities\"))\n         syms# (assoc fn-syms#\n                      :screen (deref\n                                (or (resolve map-sym#)\n                                    (intern *ns* map-sym# (atom {}))))\n                      :entities (deref\n                                  (or (resolve entities-sym#)\n                                      (intern *ns* entities-sym# (atom [])))))]\n     (def ~n (defscreen* syms#))))", :docstring "<p>Defines a screen, and creates vars for all the functions inside of it. All functions take a screen map and entities vector as arguments, and return the entities list at the end with any desired changes. If a function returns nil, the entities list is not changed.</p><p>Below are all the possible screen functions. Some of them get special arguments via the screen map.</p><pre>\n; main screen functions\n&#40;defscreen my-screen\n  :on-show ; the screen first shows\n  &#40;fn &#91;screen entities&#93;\n    entities&#41;\n  :on-render ; the screen must be rendered &#40;many times per second&#41;\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:delta-time screen&#41;&#41; ; time &#40;ms&#41; elapsed since last frame\n    entities&#41;\n  :on-hide ; the screen was replaced\n  &#40;fn &#91;screen entities&#93;\n    entities&#41;\n  :on-resize ; the screen was resized\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:width screen&#41;&#41; ; the new width of the screen\n    &#40;println &#40;:height screen&#41;&#41; ; the new height of the screen\n    entities&#41;\n  :on-resume ; the screen resumed from a paused state &#40;mobile only&#41;\n  &#40;fn &#91;screen entities&#93;\n    entities&#41;\n  :on-pause ; the screen paused &#40;mobile only&#41;\n  &#40;fn &#91;screen entities&#93;\n    entities&#41;\n  :on-timer ; a timer created with add-timer! executed\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:id screen&#41;&#41; ; the id supplied when the timer was created\n    entities&#41;&#41;\n</pre><pre>\n; input functions\n; Tip: use input-processor! to run these functions manually\n&#40;defscreen my-screen\n  :on-key-down ; a key was pressed\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:key screen&#41;&#41; ; the key that was pressed &#40;see key-code&#41;\n    entities&#41;\n  :on-key-typed ; a key was typed\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:character screen&#41;&#41; ; the character that was pressed\n    entities&#41;\n  :on-key-up ; a key was released\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:key screen&#41;&#41; ; the key that was released &#40;see key-code&#41;\n    entities&#41;\n  :on-mouse-moved ; the mouse was moved without pressing any buttons\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the mouse\n    entities&#41;\n  :on-scrolled ; the mouse wheel was scrolled\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:amount screen&#41;&#41; ; the amount scrolled\n    entities&#41;\n  :on-touch-down ; the screen was touched or a mouse button was pressed\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was pressed &#40;see button-code&#41;\n    entities&#41;\n  :on-touch-dragged ; a finger or the mouse was dragged\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    entities&#41;\n  :on-touch-up ; a finger was lifted or a mouse button was released\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was released &#40;see button-code&#41;\n    entities&#41;&#41;\n</pre><pre>\n; gesture functions\n; Tip: use gesture-detector! to configure these functions and run them manually\n&#40;defscreen my-screen\n  :on-fling ; the user dragged over the screen and lifted\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:velocity-x screen&#41;&#41; ; the x-axis velocity &#40;s&#41;\n    &#40;println &#40;:velocity-y screen&#41;&#41; ; the y-axis velocity &#40;s&#41;\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was pressed &#40;see button-code&#41;\n    entities&#41;\n  :on-long-press ; the user pressed for a long time\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    entities&#41;\n  :on-pan ; the user dragged a finger over the screen\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:delta-x screen&#41;&#41; ; the x-axis distance moved\n    &#40;println &#40;:delta-y screen&#41;&#41; ; the y-axis distance moved\n    entities&#41;\n  :on-pan-stop ; the user is no longer panning\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was pressed &#40;see button-code&#41;\n    entities&#41;\n  :on-pinch ; the user performed a pinch zoom gesture\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:initial-pointer-1 screen&#41;&#41; ; the start position of finger 1 &#40;see the x and y functions&#41;\n    &#40;println &#40;:initial-pointer-2 screen&#41;&#41; ; the start position of finger 2 &#40;see the x and y functions&#41;\n    &#40;println &#40;:pointer-1 screen&#41;&#41; ; the end position of finger 1 &#40;see the x and y functions&#41;\n    &#40;println &#40;:pointer-2 screen&#41;&#41; ; the end position of finger 2 &#40;see the x and y functions&#41;\n    entities&#41;\n  :on-tap ; the user tapped\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:count screen&#41;&#41; ; the number of taps\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was pressed &#40;see button-code&#41;\n    entities&#41;\n  :on-zoom ; the user performed a pinch zoom gesture\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:initial-distance screen&#41;&#41; ; the start distance between fingers\n    &#40;println &#40;:distance screen&#41;&#41; ; the end distance between fingers\n    entities&#41;&#41;\n</pre><pre>\n; 2D physics contact &#40;for play-clj.g2d-physics&#41;\n; Tip: use first-entity and second-entity to get the entities that are contacting\n&#40;defscreen my-screen\n  :on-begin-contact ; two bodies began to touch\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:contact screen&#41;&#41; ; the Contact - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/Contact.html\n    entities&#41;\n  :on-end-contact ; two bodies ceased to touch\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:contact screen&#41;&#41; ; the Contact - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/Contact.html\n    entities&#41;&#41;\n</pre><pre>\n; 3D physics contact &#40;for play-clj.g3d-physics&#41;\n; Tip: use first-entity and second-entity to get the entities that are contacting\n&#40;defscreen my-screen\n  :on-begin-contact ; two bodies began to touch\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:first-body screen&#41;&#41; ; the first btCollisionObject - http://bulletphysics.org/Bullet/BulletFull/classbtCollisionObject.html\n    &#40;println &#40;:second-body screen&#41;&#41; ; the second btCollisionObject - http://bulletphysics.org/Bullet/BulletFull/classbtCollisionObject.html\n    entities&#41;\n  :on-end-contact ; two bodies ceased to touch\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:first-body screen&#41;&#41; ; the first btCollisionObject - http://bulletphysics.org/Bullet/BulletFull/classbtCollisionObject.html\n    &#40;println &#40;:second-body screen&#41;&#41; ; the second btCollisionObject - http://bulletphysics.org/Bullet/BulletFull/classbtCollisionObject.html\n    entities&#41;&#41;\n</pre><pre>\n; ui input functions &#40;for play-clj.ui&#41;\n; Tip: use change-listener! and click-listener! to configure these functions and run them manually\n&#40;defscreen my-screen\n  :on-ui-changed ; the ui entity was changed\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the ChangeListener.ChangeEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/ChangeListener.ChangeEvent.html\n    &#40;println &#40;:actor screen&#41;&#41; ; the Actor - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/Actor.html\n    entities&#41;\n  :on-ui-clicked ; the ui entity was clicked\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    entities&#41;\n  :on-ui-enter ; the finger/mouse moved over the ui entity\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:actor screen&#41;&#41; ; the Actor - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/Actor.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    entities&#41;\n  :on-ui-exit ; the finger/mouse moved out of the ui entity\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:actor screen&#41;&#41; ; the Actor - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/Actor.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    entities&#41;\n  :on-ui-touch-down ; the finger/mouse went down on the ui entity\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was pressed &#40;see button-code&#41;\n    entities&#41;\n  :on-ui-touch-dragged ; the finger/mouse moved anywhere\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    entities&#41;\n  :on-ui-touch-up ; the finger/mouse went up anywhere\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was released &#40;see button-code&#41;\n    entities&#41;&#41;\n</pre><pre>\n; ui drag functions &#40;for play-clj.ui&#41;\n; Tip: use drag-listener! to configure these functions and run them manually\n&#40;defscreen my-screen\n  :on-ui-drag\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    entities&#41;\n  :on-ui-drag-start\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    entities&#41;\n  :on-ui-drag-stop\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger/mouse\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger/mouse\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    entities&#41;&#41;\n</pre><pre>\n; ui focus functions &#40;for play-clj.ui&#41;\n; Tip: use focus-listener! to run these functions manually\n&#40;defscreen my-screen\n  :on-ui-keyboard-focus-changed\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the FocusListener.FocusEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/FocusListener.FocusEvent.html\n    &#40;println &#40;:actor screen&#41;&#41; ; the Actor - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/Actor.html\n    &#40;println &#40;:focused? screen&#41;&#41; ; whether it is focused\n    entities&#41;\n  :on-ui-scroll-focus-changed\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the FocusListener.FocusEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/FocusListener.FocusEvent.html\n    &#40;println &#40;:actor screen&#41;&#41; ; the Actor - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/Actor.html\n    &#40;println &#40;:focused? screen&#41;&#41; ; whether it is focused\n    entities&#41;&#41;\n</pre><pre>\n; ui gesture functions &#40;for play-clj.ui&#41;\n; Tip: use actor-gesture-listener! to configure these functions and run them manually\n&#40;defscreen my-screen\n  :on-ui-fling ; the user dragged a finger over the screen and lifted it\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:velocity-x screen&#41;&#41; ; the x-axis velocity &#40;s&#41;\n    &#40;println &#40;:velocity-y screen&#41;&#41; ; the y-axis velocity &#40;s&#41;\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was pressed &#40;see button-code&#41;\n    entities&#41;\n  :on-ui-long-press ; the user pressed\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:actor screen&#41;&#41; ; the Actor - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/Actor.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger\n    entities&#41;\n  :on-ui-pan ; the user dragged a finger over the screen\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger\n    &#40;println &#40;:delta-x screen&#41;&#41; ; the x-axis distance moved\n    &#40;println &#40;:delta-y screen&#41;&#41; ; the y-axis distance moved\n    entities&#41;\n  :on-ui-pan-stop ; the user is no longer panning\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger\n    &#40;println &#40;:pointer screen&#41;&#41; ; the pointer for the event\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was pressed &#40;see button-code&#41;\n    entities&#41;\n  :on-ui-pinch ; the user performed a pinch zoom gesture\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:initial-pointer-1 screen&#41;&#41; ; the start position of finger 1 &#40;see the x and y functions&#41;\n    &#40;println &#40;:initial-pointer-2 screen&#41;&#41; ; the start position of finger 2 &#40;see the x and y functions&#41;\n    &#40;println &#40;:pointer-1 screen&#41;&#41; ; the end position of finger 1 &#40;see the x and y functions&#41;\n    &#40;println &#40;:pointer-2 screen&#41;&#41; ; the end position of finger 2 &#40;see the x and y functions&#41;\n    entities&#41;\n  :on-ui-tap ; the user tapped\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:input-x screen&#41;&#41; ; the x position of the finger\n    &#40;println &#40;:input-y screen&#41;&#41; ; the y position of the finger\n    &#40;println &#40;:count screen&#41;&#41; ; the number of taps\n    &#40;println &#40;:button screen&#41;&#41; ; the mouse button that was pressed &#40;see button-code&#41;\n    entities&#41;\n  :on-ui-zoom ; the user performed a pinch zoom gesture\n  &#40;fn &#91;screen entities&#93;\n    &#40;println &#40;:event screen&#41;&#41; ; the InputEvent - http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/InputEvent.html\n    &#40;println &#40;:initial-distance screen&#41;&#41; ; the start distance between fingers\n    &#40;println &#40;:distance screen&#41;&#41; ; the end distance between fingers\n    entities&#41;&#41;\n</pre>"} {:raw* "(defn defgame*\n  [{:keys [on-create]}]\n  (proxy [Game] []\n    (create []\n      (when on-create\n        (on-create this)))))", :arglists [(defgame n & options)], :java [], :name "defgame", :type :code, :raw "(defmacro defgame\n  [n & {:keys [] :as options}]\n  `(defonce ~n (defgame* ~options)))", :docstring "<p>Defines a game. This should only be called once.</p>"} {:raw* nil, :arglists [(set-screen! game & screens)], :java [], :name "set-screen!", :type :code, :raw "(defn set-screen!\n  [^Game game & screens]\n  (let [add-inputs! (fn []\n                      (input! :set-input-processor (InputMultiplexer.))\n                      (doseq [{:keys [screen]} screens]\n                        (doseq [[_ listener] (:input-listeners @screen)]\n                          (add-input! listener))))\n        run-fn! (fn [k & args]\n                  (doseq [screen screens]\n                    (apply (get screen k) args)))]\n    (.setScreen game (reify Screen\n                       (show [this] (add-inputs!) (run-fn! :show))\n                       (render [this d] (run-fn! :render d))\n                       (hide [this] (run-fn! :hide))\n                       (pause [this] (run-fn! :pause))\n                       (resize [this w h] (run-fn! :resize w h))\n                       (resume [this] (run-fn! :resume))\n                       (dispose [this])))))", :docstring "<p>Creates and displays a screen for the <code>game</code> object, using one or more <code>screen</code> maps in the order they were provided.</p><pre>\n&#40;set-screen! my-game main-screen text-screen&#41;\n</pre>"} {:raw* nil, :arglists [(set-screen-wrapper! wrapper-fn)], :java [], :name "set-screen-wrapper!", :type :code, :raw "(defn set-screen-wrapper!\n  [wrapper-fn]\n  (intern 'play-clj.core 'wrapper wrapper-fn))", :docstring "<p>Sets a function that wraps around all screen functions, allowing you to handle errors and perform other custom actions each time they run.</p><pre>\n; default behavior\n&#40;set-screen-wrapper! &#40;fn &#91;screen screen-fn&#93;\n                       &#40;screen-fn&#41;&#41;&#41;\n; if there is an error, print it out and switch to a blank screen\n; &#40;this is useful because it makes error recovery easier in a REPL&#41;\n&#40;set-screen-wrapper! &#40;fn &#91;screen screen-fn&#93;\n                       &#40;try &#40;screen-fn&#41;\n                         &#40;catch Exception e\n                           &#40;.printStackTrace e&#41;\n                           &#40;set-screen! my-game blank-screen&#41;&#41;&#41;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(update! screen & args)], :java [], :name "update!", :type :code, :raw "(defn update!\n  [{:keys [update-fn!] :as screen} & args]\n  (update-fn! assoc args))", :docstring "<p>Runs the equivalent of <code>&#40;swap! screen-atom assoc ...&#41;</code>, where <code>screen-atom</code> is the atom storing the screen map behind the scenes. Returns the updated <code>screen</code> map.</p><pre>\n&#40;update! screen :renderer &#40;stage&#41;&#41;\n</pre>"})} {:ns "", :groups ({:raw* nil, :arglists [(clear!) (clear! r g b a)], :java [], :name "clear!", :type :code, :raw "(defn clear!\n  ([]\n    (clear! 0 0 0 0))\n  ([r g b a]\n    (doto (Gdx/gl)\n      (.glClearColor (float r) (float g) (float b) (float a))\n      (.glClear (bit-or GL20/GL_COLOR_BUFFER_BIT GL20/GL_DEPTH_BUFFER_BIT)))))", :docstring "<p>Clears the screen with a uniform color, defaulting to black.</p><pre>\n&#40;clear!&#41;\n&#40;clear! 0.5 0.5 1 1&#41;\n</pre>"} {:raw* nil, :arglists [(color & args)], :java [["color" {:text "A color class, holding the r, g, b and alpha component as floats in the range [0,1]. All methods perform clamping on the\n internal values after execution.", :items [{:name ":black"} {:name ":blue"} {:name ":clear"} {:name ":cyan"} {:name ":dark-gray"} {:name ":gray"} {:name ":green"} {:name ":light-gray"} {:name ":magenta"} {:name ":orange"} {:name ":pink"} {:name ":red"} {:name ":tmp"} {:name ":white"} {:name ":yellow"}]}]], :name "color", :type :code, :raw "(defmacro color\n  [& args]\n  `~(if (keyword? (first args))\n      `(Color. ^Color ~(u/gdx-field :graphics :Color\n                                    (u/key->upper (first args))))\n      `(Color. ~@args)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/Color.html'>Color</a>.</p><pre>\n&#40;color :white&#41;\n&#40;color 1 1 1 1&#41;\n</pre>"} {:raw* nil, :arglists [(color! object k & options)], :java [["color!" {:text "A color class, holding the r, g, b and alpha component as floats in the range [0,1]. All methods perform clamping on the\n internal values after execution.", :items [{:args [["Color" "color"]], :type "Color", :text "Adds the given color to this color.", :name ":add"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "Color", :text "Adds the given color component values to this Color's values.", :name ":add"} {:args [], :type "Color", :text "Clamps this Color's components to a valid range [0 - 1]", :name ":clamp"} {:args [], :type "Color", :name ":cpy"} {:args [["Object" "o"]], :type "boolean", :name ":equals"} {:args [], :type "int", :name ":hash-code"} {:args [["Color" "target"] ["float" "t"]], :type "Color", :text "Linearly interpolates between this color and the target color by t which is in the range [0,1]. The result is stored in this\n color.", :name ":lerp"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"] ["float" "t"]], :type "Color", :text "Linearly interpolates between this color and the target color by t which is in the range [0,1]. The result is stored in this\n color.", :name ":lerp"} {:args [["Color" "color"]], :type "Color", :text "Multiplies the this color and the given color", :name ":mul"} {:args [["float" "value"]], :type "Color", :text "Multiplies all components of this Color with the given value.", :name ":mul"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "Color", :text "Multiplies this Color's color components by the given ones.", :name ":mul"} {:args [], :type "Color", :text "Multiplies the RGB values by the alpha.", :name ":premultiply-alpha"} {:args [["Color" "color"]], :type "Color", :text "Sets this color to the given color.", :name ":set"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "Color", :text "Sets this Color's component values.", :name ":set"} {:args [["int" "rgba"]], :type "Color", :text "Sets this color's component values through an integer representation.", :name ":set"} {:args [["Color" "color"]], :type "Color", :text "Subtracts the given color from this color", :name ":sub"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "Color", :text "Subtracts the given values from this Color's component values.", :name ":sub"} {:args [], :type "Color", :text "Returns a temporary copy of this color. This is not thread safe, do not save a reference to this instance.", :name ":tmp"} {:args [], :type "float", :text "Packs the color components into a 32-bit integer with the format ABGR and then converts it to a float.", :name ":to-float-bits"} {:args [], :type "int", :text "Packs the color components into a 32-bit integer with the format ABGR.", :name ":to-int-bits"} {:args [], :type "String", :text "Returns the color encoded as hex string with the format RRGGBBAA.", :name ":to-string"}]}]], :name "color!", :type :code, :raw "(defmacro color!\n  [object k & options]\n  `(u/call! ^Color ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>color</code>.</p>"} {:raw* nil, :arglists [(app! k & options)], :java [["app!" {:text "<p>\n An <code>Application</code> is the main entry point of your project. It sets up a window and rendering surface and manages the\n different aspects of your application, namely {@link Graphics}, {@link Audio}, {@link Input} and {@link Files}. Think of an\n Application being equivalent to Swing's <code>JFrame</code> or Android's <code>Activity</code>.\n </p>\n \n <p>\n An application can be an instance of any of the following:\n <ul>\n <li>a desktop application (see <code>JglfwApplication</code> found in gdx-backends-jglfw.jar)</li>\n <li>an Android application (see <code>AndroidApplication</code> found in gdx-backends-android.jar)</li>\n <li>a HTML5 application (see <code>GwtApplication</code> found in gdx-backends-gwt.jar)</li>\n <li>an iOS application (see <code>IOSApplication</code> found in gdx-backends-robovm.jar)</li>\n </ul>\n Each application class has it's own startup and initialization methods. Please refer to their documentation for more\n information.\n </p>\n \n <p>\n While game programmers are used to having a main loop, libgdx employs a different concept to accommodate the event based nature\n of Android applications a little more. You application logic must be implemented in a {@link ApplicationListener} which has\n methods that get called by the Application when the application is created, resumed, paused, disposed or rendered. As a\n developer you will simply implement the ApplicationListener interface and fill in the functionality accordingly. The\n ApplicationListener is provided to a concrete Application instance as a parameter to the constructor or another initialization\n method. Please refer to the documentation of the Application implementations for more information. Note that the\n ApplicationListener can be provided to any Application implementation. This means that you only need to write your program\n logic once and have it run on different platforms by passing it to a concrete Application implementation.\n </p>\n \n <p>\n The Application interface provides you with a set of modules for graphics, audio, input and file i/o.\n </p>\n \n <p>\n {@link Graphics} offers you various methods to output visuals to the screen. This is achieved via OpenGL ES 2.0 or 3.0\n depending on what's available an the platform. On the desktop the features of OpenGL ES 2.0 and 3.0 are emulated via desktop\n OpenGL. On Android the functionality of the Java OpenGL ES bindings is used.\n </p>\n \n <p>\n {@link Audio} offers you various methods to output and record sound and music. This is achieved via the Java Sound API on the\n desktop. On Android the Android media framework is used.\n </p>\n \n <p>\n {@link Input} offers you various methods to poll user input from the keyboard, touch screen, mouse and accelerometer.\n Additionally you can implement an {@link InputProcessor} and use it with {@link Input#setInputProcessor(InputProcessor)} to\n receive input events.\n </p>\n \n <p>\n {@link Files} offers you various methods to access internal and external files. An internal file is a file that is stored near\n your application. On Android internal files are equivalent to assets. On the desktop the classpath is first scanned for the\n specified file. If that fails then the root directory of your application is used for a look up. External files are resources\n you create in your application and write to an external storage. On Android external files reside on the SD-card, on the\n desktop external files are written to a users home directory. If you know what you are doing you can also specify absolute file\n names. Absolute filenames are not portable, so take great care when using this feature.\n </p>\n \n <p>\n {@link Net} offers you various methods to perform network operations, such as performing HTTP requests, or creating server and\n client sockets for more elaborate network programming.\n </p>\n \n <p>\n The <code>Application</code> also has a set of methods that you can use to query specific information such as the operating\n system the application is currently running on and so forth. This allows you to have operating system dependent code paths. It\n is however not recommended to use this facilities.\n </p>\n \n <p>\n The <code>Application</code> also has a simple logging method which will print to standard out on the desktop and to logcat on\n Android.\n </p>", :items [{:args [["LifecycleListener" "listener"]], :text "Adds a new {@link LifecycleListener} to the application. This can be used by extensions to hook into the lifecycle more\n easily. The {@link ApplicationListener} methods are sufficient for application level development.", :name ":add-lifecycle-listener"} {:args [["String" "tag"] ["String" "message"]], :text "Logs a debug message to the console or logcat", :name ":debug"} {:args [["String" "tag"] ["String" "message"] ["Throwable" "exception"]], :text "Logs a debug message to the console or logcat", :name ":debug"} {:args [["String" "tag"] ["String" "message"]], :text "Logs an error message to the console or logcat", :name ":error"} {:args [["String" "tag"] ["String" "message"] ["Throwable" "exception"]], :text "Logs an error message to the console or logcat", :name ":error"} {:args [], :text "Schedule an exit from the application. On android, this will cause a call to pause() and dispose() some time in the future,\n it will not immediately finish your application.", :name ":exit"} {:args [], :type "ApplicationListener", :name ":get-application-listener"} {:args [], :type "Audio", :name ":get-audio"} {:args [], :type "Clipboard", :name ":get-clipboard"} {:args [], :type "Files", :name ":get-files"} {:args [], :type "Graphics", :name ":get-graphics"} {:args [], :type "Input", :name ":get-input"} {:args [], :type "long", :name ":get-java-heap"} {:args [], :type "int", :text "Gets the log level.", :name ":get-log-level"} {:args [], :type "long", :name ":get-native-heap"} {:args [], :type "Net", :name ":get-net"} {:args [["String" "name"]], :type "Preferences", :text "Returns the {@link Preferences} instance of this Application. It can be used to store application settings across runs.", :name ":get-preferences"} {:args [], :type "Application.ApplicationType", :name ":get-type"} {:args [], :type "int", :name ":get-version"} {:args [["String" "tag"] ["String" "message"]], :text "Logs a message to the console or logcat", :name ":log"} {:args [["String" "tag"] ["String" "message"] ["Throwable" "exception"]], :text "Logs a message to the console or logcat", :name ":log"} {:args [["Runnable" "runnable"]], :text "Posts a {@link Runnable} on the main loop thread.", :name ":post-runnable"} {:args [["LifecycleListener" "listener"]], :text "Removes the {@link LifecycleListener}.", :name ":remove-lifecycle-listener"} {:args [["int" "log-level"]], :text "Sets the log level. {@link #LOG_NONE} will mute all log output. {@link #LOG_ERROR} will only let error messages through.\n {@link #LOG_INFO} will let all non-debug messages through, and {@link #LOG_DEBUG} will let all messages through.", :name ":set-log-level"}]}]], :name "app!", :type :code, :raw "(defmacro app!\n  [k & options]\n  `(u/call! ^Application (Gdx/app) ~k ~@options))", :docstring "<p>Calls a single method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Application.html'>Gdx.app</a>.</p><pre>\n&#40;app! :error &quot;MYTAG&quot; &quot;An error occurred, so I'm logging it!&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(audio! k & options)], :java [["audio!" {:text "This interface encapsulates the creation and management of audio resources. It allows you to get direct access to the audio\n hardware via the {@link AudioDevice} and {@link AudioRecorder} interfaces, create sound effects via the {@link Sound} interface\n and play music streams via the {@link Music} interface.\n \n <p>\n All resources created via this interface have to be disposed as soon as they are no longer used.\n </p>\n \n <p>\n Note that all {@link Music} instances will be automatically paused when the {@link ApplicationListener#pause()} method is\n called, and automatically resumed when the {@link ApplicationListener#resume()} method is called.\n </p>", :items [{:args [["int" "sampling-rate"] ["boolean" "is-mono"]], :type "AudioDevice", :text "Creates a new {@link AudioDevice} either in mono or stereo mode. The AudioDevice has to be disposed via its\n {@link AudioDevice#dispose()} method when it is no longer used.", :name ":new-audio-device"} {:args [["int" "sampling-rate"] ["boolean" "is-mono"]], :type "AudioRecorder", :text "Creates a new {@link AudioRecorder}. The AudioRecorder has to be disposed after it is no longer used.", :name ":new-audio-recorder"} {:args [["FileHandle" "file"]], :type "Music", :text "Creates a new {@link Music} instance which is used to play back a music stream from a file. Currently supported formats are\n WAV, MP3 and OGG. The Music instance has to be disposed if it is no longer used via the {@link Music#dispose()} method.\n Music instances are automatically paused when {@link ApplicationListener#pause()} is called and resumed when\n {@link ApplicationListener#resume()} is called.", :name ":new-music"} {:args [["FileHandle" "file-handle"]], :type "Sound", :text "<p>\n Creates a new {@link Sound} which is used to play back audio effects such as gun shots or explosions. The Sound's audio data\n is retrieved from the file specified via the {@link FileHandle}. Note that the complete audio data is loaded into RAM. You\n should therefore not load big audio files with this methods. The current upper limit for decoded audio is 1 MB.\n </p>\n \n <p>\n Currently supported formats are WAV, MP3 and OGG.\n </p>\n \n <p>\n The Sound has to be disposed if it is no longer used via the {@link Sound#dispose()} method.\n </p>", :name ":new-sound"}]}]], :name "audio!", :type :code, :raw "(defmacro audio!\n  [k & options]\n  `(u/call! ^Audio (Gdx/audio) ~k ~@options))", :docstring "<p>Calls a single method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Audio.html'>Gdx.audio</a>.</p><pre>\n&#40;audio! :new-audio-recorder 44100 false&#41;\n</pre>"} {:raw* nil, :arglists [(files! k & options)], :java [["files!" {:text "Provides standard access to the filesystem, classpath, Android SD card, and Android assets directory.", :items [{:args [["String" "path"]], :type "FileHandle", :text "Convenience method that returns a {@link FileType#Absolute} file handle.", :name ":absolute"} {:args [["String" "path"]], :type "FileHandle", :text "Convenience method that returns a {@link FileType#Classpath} file handle.", :name ":classpath"} {:args [["String" "path"]], :type "FileHandle", :text "Convenience method that returns a {@link FileType#External} file handle.", :name ":external"} {:args [], :type "String", :text "Returns the external storage path directory. This is the SD card on Android and the home directory of the current user on\n the desktop.", :name ":get-external-storage-path"} {:args [["String" "path"] ["Files.FileType" "type"]], :type "FileHandle", :text "Returns a handle representing a file or directory.", :name ":get-file-handle"} {:args [], :type "String", :text "Returns the local storage path directory. This is the private files directory on Android and the directory of the jar on the\n desktop.", :name ":get-local-storage-path"} {:args [["String" "path"]], :type "FileHandle", :text "Convenience method that returns a {@link FileType#Internal} file handle.", :name ":internal"} {:args [], :type "boolean", :text "Returns true if the external storage is ready for file IO. Eg, on Android, the SD card is not available when mounted for use\n with a PC.", :name ":is-external-storage-available"} {:args [], :type "boolean", :text "Returns true if the local storage is ready for file IO.", :name ":is-local-storage-available"} {:args [["String" "path"]], :type "FileHandle", :text "Convenience method that returns a {@link FileType#Local} file handle.", :name ":local"}]}]], :name "files!", :type :code, :raw "(defmacro files!\n  [k & options]\n  `(u/call! ^Files (Gdx/files) ~k ~@options))", :docstring "<p>Calls a single method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Files.html'>Gdx.files</a>.</p><pre>\n&#40;files! :internal &quot;image.png&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(gl! k & options)], :java [["gl!" {:text "Interface wrapping all the methods of OpenGL ES 2.0", :items [{:args [["int" "texture"]], :name ":gl-active-texture"} {:args [["int" "program"] ["int" "shader"]], :name ":gl-attach-shader"} {:args [["int" "program"] ["int" "index"] ["String" "name"]], :name ":gl-bind-attrib-location"} {:args [["int" "target"] ["int" "buffer"]], :name ":gl-bind-buffer"} {:args [["int" "target"] ["int" "framebuffer"]], :name ":gl-bind-framebuffer"} {:args [["int" "target"] ["int" "renderbuffer"]], :name ":gl-bind-renderbuffer"} {:args [["int" "target"] ["int" "texture"]], :name ":gl-bind-texture"} {:args [["float" "red"] ["float" "green"] ["float" "blue"] ["float" "alpha"]], :name ":gl-blend-color"} {:args [["int" "mode"]], :name ":gl-blend-equation"} {:args [["int" "mode-rgb"] ["int" "mode-alpha"]], :name ":gl-blend-equation-separate"} {:args [["int" "sfactor"] ["int" "dfactor"]], :name ":gl-blend-func"} {:args [["int" "src-rgb"] ["int" "dst-rgb"] ["int" "src-alpha"] ["int" "dst-alpha"]], :name ":gl-blend-func-separate"} {:args [["int" "target"] ["int" "size"] ["Buffer" "data"] ["int" "usage"]], :name ":gl-buffer-data"} {:args [["int" "target"] ["int" "offset"] ["int" "size"] ["Buffer" "data"]], :name ":gl-buffer-sub-data"} {:args [["int" "target"]], :type "int", :name ":gl-check-framebuffer-status"} {:args [["int" "mask"]], :name ":gl-clear"} {:args [["float" "red"] ["float" "green"] ["float" "blue"] ["float" "alpha"]], :name ":gl-clear-color"} {:args [["float" "depth"]], :name ":gl-clear-depthf"} {:args [["int" "s"]], :name ":gl-clear-stencil"} {:args [["boolean" "red"] ["boolean" "green"] ["boolean" "blue"] ["boolean" "alpha"]], :name ":gl-color-mask"} {:args [["int" "shader"]], :name ":gl-compile-shader"} {:args [["int" "target"] ["int" "level"] ["int" "internalformat"] ["int" "width"] ["int" "height"] ["int" "border"] ["int" "image-size"] ["Buffer" "data"]], :name ":gl-compressed-tex-image2d"} {:args [["int" "target"] ["int" "level"] ["int" "xoffset"] ["int" "yoffset"] ["int" "width"] ["int" "height"] ["int" "format"] ["int" "image-size"] ["Buffer" "data"]], :name ":gl-compressed-tex-sub-image2d"} {:args [["int" "target"] ["int" "level"] ["int" "internalformat"] ["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"] ["int" "border"]], :name ":gl-copy-tex-image2d"} {:args [["int" "target"] ["int" "level"] ["int" "xoffset"] ["int" "yoffset"] ["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :name ":gl-copy-tex-sub-image2d"} {:args [], :type "int", :name ":gl-create-program"} {:args [["int" "type"]], :type "int", :name ":gl-create-shader"} {:args [["int" "mode"]], :name ":gl-cull-face"} {:args [["int" "n"] ["IntBuffer" "buffers"]], :name ":gl-delete-buffers"} {:args [["int" "n"] ["IntBuffer" "framebuffers"]], :name ":gl-delete-framebuffers"} {:args [["int" "program"]], :name ":gl-delete-program"} {:args [["int" "n"] ["IntBuffer" "renderbuffers"]], :name ":gl-delete-renderbuffers"} {:args [["int" "shader"]], :name ":gl-delete-shader"} {:args [["int" "n"] ["IntBuffer" "textures"]], :name ":gl-delete-textures"} {:args [["int" "func"]], :name ":gl-depth-func"} {:args [["boolean" "flag"]], :name ":gl-depth-mask"} {:args [["float" "z-near"] ["float" "z-far"]], :name ":gl-depth-rangef"} {:args [["int" "program"] ["int" "shader"]], :name ":gl-detach-shader"} {:args [["int" "cap"]], :name ":gl-disable"} {:args [["int" "index"]], :name ":gl-disable-vertex-attrib-array"} {:args [["int" "mode"] ["int" "first"] ["int" "count"]], :name ":gl-draw-arrays"} {:args [["int" "mode"] ["int" "count"] ["int" "type"] ["Buffer" "indices"]], :name ":gl-draw-elements"} {:args [["int" "mode"] ["int" "count"] ["int" "type"] ["int" "indices"]], :name ":gl-draw-elements"} {:args [["int" "cap"]], :name ":gl-enable"} {:args [["int" "index"]], :name ":gl-enable-vertex-attrib-array"} {:args [], :name ":gl-finish"} {:args [], :name ":gl-flush"} {:args [["int" "target"] ["int" "attachment"] ["int" "renderbuffertarget"] ["int" "renderbuffer"]], :name ":gl-framebuffer-renderbuffer"} {:args [["int" "target"] ["int" "attachment"] ["int" "textarget"] ["int" "texture"] ["int" "level"]], :name ":gl-framebuffer-texture2d"} {:args [["int" "mode"]], :name ":gl-front-face"} {:args [["int" "n"] ["IntBuffer" "buffers"]], :name ":gl-gen-buffers"} {:args [["int" "n"] ["IntBuffer" "framebuffers"]], :name ":gl-gen-framebuffers"} {:args [["int" "n"] ["IntBuffer" "renderbuffers"]], :name ":gl-gen-renderbuffers"} {:args [["int" "n"] ["IntBuffer" "textures"]], :name ":gl-gen-textures"} {:args [["int" "target"]], :name ":gl-generate-mipmap"} {:args [["int" "program"] ["int" "index"] ["IntBuffer" "size"] ["Buffer" "type"]], :type "String", :name ":gl-get-active-attrib"} {:args [["int" "program"] ["int" "index"] ["IntBuffer" "size"] ["Buffer" "type"]], :type "String", :name ":gl-get-active-uniform"} {:args [["int" "program"] ["int" "maxcount"] ["Buffer" "count"] ["IntBuffer" "shaders"]], :name ":gl-get-attached-shaders"} {:args [["int" "program"] ["String" "name"]], :type "int", :name ":gl-get-attrib-location"} {:args [["int" "pname"] ["Buffer" "params"]], :name ":gl-get-booleanv"} {:args [["int" "target"] ["int" "pname"] ["IntBuffer" "params"]], :name ":gl-get-buffer-parameteriv"} {:args [], :type "int", :name ":gl-get-error"} {:args [["int" "pname"] ["FloatBuffer" "params"]], :name ":gl-get-floatv"} {:args [["int" "target"] ["int" "attachment"] ["int" "pname"] ["IntBuffer" "params"]], :name ":gl-get-framebuffer-attachment-parameteriv"} {:args [["int" "pname"] ["IntBuffer" "params"]], :name ":gl-get-integerv"} {:args [["int" "program"]], :type "String", :name ":gl-get-program-info-log"} {:args [["int" "program"] ["int" "pname"] ["IntBuffer" "params"]], :name ":gl-get-programiv"} {:args [["int" "target"] ["int" "pname"] ["IntBuffer" "params"]], :name ":gl-get-renderbuffer-parameteriv"} {:args [["int" "shader"]], :type "String", :name ":gl-get-shader-info-log"} {:args [["int" "shadertype"] ["int" "precisiontype"] ["IntBuffer" "range"] ["IntBuffer" "precision"]], :name ":gl-get-shader-precision-format"} {:args [["int" "shader"] ["int" "pname"] ["IntBuffer" "params"]], :name ":gl-get-shaderiv"} {:args [["int" "name"]], :type "String", :name ":gl-get-string"} {:args [["int" "target"] ["int" "pname"] ["FloatBuffer" "params"]], :name ":gl-get-tex-parameterfv"} {:args [["int" "target"] ["int" "pname"] ["IntBuffer" "params"]], :name ":gl-get-tex-parameteriv"} {:args [["int" "program"] ["String" "name"]], :type "int", :name ":gl-get-uniform-location"} {:args [["int" "program"] ["int" "location"] ["FloatBuffer" "params"]], :name ":gl-get-uniformfv"} {:args [["int" "program"] ["int" "location"] ["IntBuffer" "params"]], :name ":gl-get-uniformiv"} {:args [["int" "index"] ["int" "pname"] ["Buffer" "pointer"]], :name ":gl-get-vertex-attrib-pointerv"} {:args [["int" "index"] ["int" "pname"] ["FloatBuffer" "params"]], :name ":gl-get-vertex-attribfv"} {:args [["int" "index"] ["int" "pname"] ["IntBuffer" "params"]], :name ":gl-get-vertex-attribiv"} {:args [["int" "target"] ["int" "mode"]], :name ":gl-hint"} {:args [["int" "buffer"]], :type "boolean", :name ":gl-is-buffer"} {:args [["int" "cap"]], :type "boolean", :name ":gl-is-enabled"} {:args [["int" "framebuffer"]], :type "boolean", :name ":gl-is-framebuffer"} {:args [["int" "program"]], :type "boolean", :name ":gl-is-program"} {:args [["int" "renderbuffer"]], :type "boolean", :name ":gl-is-renderbuffer"} {:args [["int" "shader"]], :type "boolean", :name ":gl-is-shader"} {:args [["int" "texture"]], :type "boolean", :name ":gl-is-texture"} {:args [["float" "width"]], :name ":gl-line-width"} {:args [["int" "program"]], :name ":gl-link-program"} {:args [["int" "pname"] ["int" "param"]], :name ":gl-pixel-storei"} {:args [["float" "factor"] ["float" "units"]], :name ":gl-polygon-offset"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"] ["int" "format"] ["int" "type"] ["Buffer" "pixels"]], :name ":gl-read-pixels"} {:args [], :name ":gl-release-shader-compiler"} {:args [["int" "target"] ["int" "internalformat"] ["int" "width"] ["int" "height"]], :name ":gl-renderbuffer-storage"} {:args [["float" "value"] ["boolean" "invert"]], :name ":gl-sample-coverage"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :name ":gl-scissor"} {:args [["int" "n"] ["IntBuffer" "shaders"] ["int" "binaryformat"] ["Buffer" "binary"] ["int" "length"]], :name ":gl-shader-binary"} {:args [["int" "shader"] ["String" "string"]], :name ":gl-shader-source"} {:args [["int" "func"] ["int" "ref"] ["int" "mask"]], :name ":gl-stencil-func"} {:args [["int" "face"] ["int" "func"] ["int" "ref"] ["int" "mask"]], :name ":gl-stencil-func-separate"} {:args [["int" "mask"]], :name ":gl-stencil-mask"} {:args [["int" "face"] ["int" "mask"]], :name ":gl-stencil-mask-separate"} {:args [["int" "fail"] ["int" "zfail"] ["int" "zpass"]], :name ":gl-stencil-op"} {:args [["int" "face"] ["int" "fail"] ["int" "zfail"] ["int" "zpass"]], :name ":gl-stencil-op-separate"} {:args [["int" "target"] ["int" "level"] ["int" "internalformat"] ["int" "width"] ["int" "height"] ["int" "border"] ["int" "format"] ["int" "type"] ["Buffer" "pixels"]], :name ":gl-tex-image2d"} {:args [["int" "target"] ["int" "pname"] ["float" "param"]], :name ":gl-tex-parameterf"} {:args [["int" "target"] ["int" "pname"] ["FloatBuffer" "params"]], :name ":gl-tex-parameterfv"} {:args [["int" "target"] ["int" "pname"] ["int" "param"]], :name ":gl-tex-parameteri"} {:args [["int" "target"] ["int" "pname"] ["IntBuffer" "params"]], :name ":gl-tex-parameteriv"} {:args [["int" "target"] ["int" "level"] ["int" "xoffset"] ["int" "yoffset"] ["int" "width"] ["int" "height"] ["int" "format"] ["int" "type"] ["Buffer" "pixels"]], :name ":gl-tex-sub-image2d"} {:args [["int" "location"] ["int" "count"] ["boolean" "transpose"] ["FloatBuffer" "value"]], :name ":gl-uniform-matrix2fv"} {:args [["int" "location"] ["int" "count"] ["boolean" "transpose"] ["FloatBuffer" "value"]], :name ":gl-uniform-matrix3fv"} {:args [["int" "location"] ["int" "count"] ["boolean" "transpose"] ["FloatBuffer" "value"]], :name ":gl-uniform-matrix4fv"} {:args [["int" "location"] ["float" "x"]], :name ":gl-uniform1f"} {:args [["int" "location"] ["int" "count"] ["FloatBuffer" "v"]], :name ":gl-uniform1fv"} {:args [["int" "location"] ["int" "x"]], :name ":gl-uniform1i"} {:args [["int" "location"] ["int" "count"] ["IntBuffer" "v"]], :name ":gl-uniform1iv"} {:args [["int" "location"] ["float" "x"] ["float" "y"]], :name ":gl-uniform2f"} {:args [["int" "location"] ["int" "count"] ["FloatBuffer" "v"]], :name ":gl-uniform2fv"} {:args [["int" "location"] ["int" "x"] ["int" "y"]], :name ":gl-uniform2i"} {:args [["int" "location"] ["int" "count"] ["IntBuffer" "v"]], :name ":gl-uniform2iv"} {:args [["int" "location"] ["float" "x"] ["float" "y"] ["float" "z"]], :name ":gl-uniform3f"} {:args [["int" "location"] ["int" "count"] ["FloatBuffer" "v"]], :name ":gl-uniform3fv"} {:args [["int" "location"] ["int" "x"] ["int" "y"] ["int" "z"]], :name ":gl-uniform3i"} {:args [["int" "location"] ["int" "count"] ["IntBuffer" "v"]], :name ":gl-uniform3iv"} {:args [["int" "location"] ["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :name ":gl-uniform4f"} {:args [["int" "location"] ["int" "count"] ["FloatBuffer" "v"]], :name ":gl-uniform4fv"} {:args [["int" "location"] ["int" "x"] ["int" "y"] ["int" "z"] ["int" "w"]], :name ":gl-uniform4i"} {:args [["int" "location"] ["int" "count"] ["IntBuffer" "v"]], :name ":gl-uniform4iv"} {:args [["int" "program"]], :name ":gl-use-program"} {:args [["int" "program"]], :name ":gl-validate-program"} {:args [["int" "indx"] ["int" "size"] ["int" "type"] ["boolean" "normalized"] ["int" "stride"] ["Buffer" "ptr"]], :name ":gl-vertex-attrib-pointer"} {:args [["int" "indx"] ["int" "size"] ["int" "type"] ["boolean" "normalized"] ["int" "stride"] ["int" "ptr"]], :name ":gl-vertex-attrib-pointer"} {:args [["int" "indx"] ["float" "x"]], :name ":gl-vertex-attrib1f"} {:args [["int" "indx"] ["FloatBuffer" "values"]], :name ":gl-vertex-attrib1fv"} {:args [["int" "indx"] ["float" "x"] ["float" "y"]], :name ":gl-vertex-attrib2f"} {:args [["int" "indx"] ["FloatBuffer" "values"]], :name ":gl-vertex-attrib2fv"} {:args [["int" "indx"] ["float" "x"] ["float" "y"] ["float" "z"]], :name ":gl-vertex-attrib3f"} {:args [["int" "indx"] ["FloatBuffer" "values"]], :name ":gl-vertex-attrib3fv"} {:args [["int" "indx"] ["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :name ":gl-vertex-attrib4f"} {:args [["int" "indx"] ["FloatBuffer" "values"]], :name ":gl-vertex-attrib4fv"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :name ":gl-viewport"}]}]], :name "gl!", :type :code, :raw "(defmacro gl!\n  [k & options]\n  `(u/call! ^GL20 (Gdx/gl20) ~k ~@options))", :docstring "<p>Calls a single method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/GL20.html'>Gdx.gl20</a>.</p><pre>\n&#40;gl! :gl-create-program&#41;\n</pre>"} {:raw* nil, :arglists [(graphics! k & options)], :java [["graphics!" {:text "This interface encapsulates communication with the graphics processor. Depending on the available hardware and the current\n {@link Application} configuration, access to {@link GL20} and {@link GL30} are provided here.\n <p>\n If supported by the backend, this interface lets you query the available display modes (graphics resolution and color depth)\n and change it.\n <p>\n This interface can be used to switch between continuous and non-continuous rendering (see\n {@link #setContinuousRendering(boolean)}), and to explicitly {@link #requestRendering()}.\n <p>\n There are many more utility classes that are not directly generated by the {@link Graphics} interfaces. See {@link VertexArray}, {@link VertexBufferObject}, {@link IndexBufferObject}, {@link Mesh}, {@link ShaderProgram} and {@link FrameBuffer},\n {@link BitmapFont}, {@link Batch} and so on. All these classes are managed, meaning they don't need to be reloaded on a context\n loss. Explore the com.badlogic.gdx.graphics package for more classes that might come in handy.", :items [{:args [], :type "Graphics.BufferFormat", :name ":get-buffer-format"} {:args [], :type "float", :name ":get-delta-time"} {:args [], :type "float", :text "This is a scaling factor for the Density Independent Pixel unit, following the same conventions as\n android.util.DisplayMetrics#density, where one DIP is one pixel on an approximately 160 dpi screen. Thus on a 160dpi screen\n this density value will be 1; on a 120 dpi screen it would be .75; etc.", :name ":get-density"} {:args [], :type "Graphics.DisplayMode", :name ":get-desktop-display-mode"} {:args [], :type "Graphics.DisplayMode", :name ":get-display-modes"} {:args [], :type "int", :name ":get-frames-per-second"} {:args [], :type "GL20", :name ":get-gl20"} {:args [], :type "GL30", :name ":get-gl30"} {:args [], :type "int", :name ":get-height"} {:args [], :type "float", :name ":get-ppc-x"} {:args [], :type "float", :name ":get-ppc-y"} {:args [], :type "float", :name ":get-ppi-x"} {:args [], :type "float", :name ":get-ppi-y"} {:args [], :type "float", :name ":get-raw-delta-time"} {:args [], :type "Graphics.GraphicsType", :name ":get-type"} {:args [], :type "int", :name ":get-width"} {:args [], :type "boolean", :name ":is-continuous-rendering"} {:args [], :type "boolean", :text "Whether the app is fullscreen or not", :name ":is-fullscreen"} {:args [], :type "boolean", :text "Returns whether OpenGL ES 3.0 is available. If it is you can get an instance of {@link GL30} via {@link #getGL30()} to\n access OpenGL ES 3.0 functionality. Note that this functionality will only be available if you instructed the\n {@link Application} instance to use OpenGL ES 3.0!", :name ":is-gl30available"} {:args [], :text "Requests a new frame to be rendered if the rendering mode is non-continuous. This method can be called from any thread.", :name ":request-rendering"} {:args [["boolean" "is-continuous"]], :text "Sets whether to render continuously. In case rendering is performed non-continuously, the following events will trigger a\n redraw:\n \n <ul>\n <li>A call to {@link #requestRendering()}</li>\n <li>Input events from the touch screen/mouse or keyboard</li>\n <li>A {@link Runnable} is posted to the rendering thread via {@link Application#postRunnable(Runnable)}</li>\n </ul>\n \n Life-cycle events will also be reported as usual, see {@link ApplicationListener}. This method can be called from any\n thread.", :name ":set-continuous-rendering"} {:args [["Graphics.DisplayMode" "display-mode"]], :type "boolean", :text "Sets the current {@link DisplayMode}. Returns false in case the operation failed. Not all backends support this method. See\n {@link Graphics#supportsDisplayModeChange()}.", :name ":set-display-mode"} {:args [["int" "width"] ["int" "height"] ["boolean" "fullscreen"]], :type "boolean", :text "Tries to set the display mode width the given width and height in pixels. Will always succeed if fullscreen is set to false,\n in which case the application will be run in windowed mode. Use {@link Graphics#getDisplayModes()} to get a list of\n supported fullscreen modes.", :name ":set-display-mode"} {:args [["String" "title"]], :text "Sets the title of the window. Ignored on Android.", :name ":set-title"} {:args [["boolean" "vsync"]], :text "Enable/Disable vsynching. This is a best-effort attempt which might not work on all platforms.", :name ":set-vsync"} {:args [], :type "boolean", :text "Whether the given backend supports a display mode change via calling {@link Graphics#setDisplayMode(DisplayMode)}", :name ":supports-display-mode-change"} {:args [["String" "extension"]], :type "boolean", :name ":supports-extension"}]}]], :name "graphics!", :type :code, :raw "(defmacro graphics!\n  [k & options]\n  `(u/call! ^Graphics (Gdx/graphics) ~k ~@options))", :docstring "<p>Calls a single method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Graphics.html'>Gdx.graphics</a>.</p><pre>\n&#40;graphics! :is-fullscreen&#41;\n</pre>"} {:raw* nil, :arglists [(input! k & options)], :java [["input!" {:text "<p>\n Interface to the input facilities. This allows polling the state of the keyboard, the touch screen and the accelerometer. On\n some backends (desktop, gwt, etc) the touch screen is replaced by mouse input. The accelerometer is of course not available on\n all backends.\n </p>\n \n <p>\n Instead of polling for events, one can process all input events with an {@link InputProcessor}. You can set the InputProcessor\n via the {@link #setInputProcessor(InputProcessor)} method. It will be called before the {@link ApplicationListener#render()}\n method in each frame.\n </p>\n \n <p>\n Keyboard keys are translated to the constants in {@link Keys} transparently on all systems. Do not use system specific key\n constants.\n </p>\n \n <p>\n The class also offers methods to use (and test for the presence of) other input systems like vibration, compass, on-screen\n keyboards, and cursor capture. Support for simple input dialogs is also provided.\n </p>", :items [{:args [], :text "Stops the vibrator", :name ":cancel-vibrate"} {:args [], :type "float", :name ":get-accelerometer-x"} {:args [], :type "float", :name ":get-accelerometer-y"} {:args [], :type "float", :name ":get-accelerometer-z"} {:args [], :type "float", :text "The azimuth is the angle of the device's orientation around the z-axis. The positive z-axis points towards the earths\n center.", :name ":get-azimuth"} {:args [], :type "long", :name ":get-current-event-time"} {:args [], :type "int", :name ":get-delta-x"} {:args [["int" "pointer"]], :type "int", :name ":get-delta-x"} {:args [], :type "int", :name ":get-delta-y"} {:args [["int" "pointer"]], :type "int", :name ":get-delta-y"} {:args [], :type "InputProcessor", :name ":get-input-processor"} {:args [], :type "Input.Orientation", :name ":get-native-orientation"} {:args [], :type "float", :text "The pitch is the angle of the device's orientation around the x-axis. The positive x-axis roughly points to the west and is\n orthogonal to the z- and y-axis.", :name ":get-pitch"} {:args [["Input.TextInputListener" "listener"] ["String" "title"] ["String" "placeholder"]], :text "System dependent method to input a string of text. A dialog box will be created with the given title and the given text as a\n hint message for the user. Once the dialog has been closed the provided {@link TextInputListener} will be called on the\n rendering thread.", :name ":get-placeholder-text-input"} {:args [], :type "float", :text "The roll is the angle of the device's orientation around the y-axis. The positive y-axis points to the magnetic north pole\n of the earth.", :name ":get-roll"} {:args [], :type "int", :name ":get-rotation"} {:args [["float[]" "matrix"]], :text "Returns the rotation matrix describing the devices rotation as per <a href=\n \"http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])\"\n >SensorManager#getRotationMatrix(float[], float[], float[], float[])</a>. Does not manipulate the matrix if the platform\n does not have an accelerometer.", :name ":get-rotation-matrix"} {:args [["Input.TextInputListener" "listener"] ["String" "title"] ["String" "text"]], :text "System dependent method to input a string of text. A dialog box will be created with the given title and the given text as a\n message for the user. Once the dialog has been closed the provided {@link TextInputListener} will be called on the rendering\n thread.", :name ":get-text-input"} {:args [], :type "int", :name ":get-x"} {:args [["int" "pointer"]], :type "int", :text "Returns the x coordinate in screen coordinates of the given pointer. Pointers are indexed from 0 to n. The pointer id\n identifies the order in which the fingers went down on the screen, e.g. 0 is the first finger, 1 is the second and so on.\n When two fingers are touched down and the first one is lifted the second one keeps its index. If another finger is placed on\n the touch screen the first free index will be used.", :name ":get-x"} {:args [], :type "int", :name ":get-y"} {:args [["int" "pointer"]], :type "int", :text "Returns the y coordinate in screen coordinates of the given pointer. Pointers are indexed from 0 to n. The pointer id\n identifies the order in which the fingers went down on the screen, e.g. 0 is the first finger, 1 is the second and so on.\n When two fingers are touched down and the first one is lifted the second one keeps its index. If another finger is placed on\n the touch screen the first free index will be used.", :name ":get-y"} {:args [["int" "button"]], :type "boolean", :text "Whether a given button is pressed or not. Button constants can be found in {@link Buttons}. On Android only the Button#LEFT\n constant is meaningful.", :name ":is-button-pressed"} {:args [], :type "boolean", :name ":is-cursor-catched"} {:args [["int" "key"]], :type "boolean", :text "Returns whether the key is pressed.", :name ":is-key-pressed"} {:args [["Input.Peripheral" "peripheral"]], :type "boolean", :text "Queries whether a {@link Peripheral} is currently available. In case of Android and the {@link Peripheral#HardwareKeyboard}\n this returns the whether the keyboard is currently slid out or not.", :name ":is-peripheral-available"} {:args [], :type "boolean", :name ":is-touched"} {:args [["int" "pointer"]], :type "boolean", :text "Whether the screen is currently touched by the pointer with the given index. Pointers are indexed from 0 to n. The pointer\n id identifies the order in which the fingers went down on the screen, e.g. 0 is the first finger, 1 is the second and so on.\n When two fingers are touched down and the first one is lifted the second one keeps its index. If another finger is placed on\n the touch screen the first free index will be used.", :name ":is-touched"} {:args [], :type "boolean", :name ":just-touched"} {:args [["boolean" "catch-back"]], :text "Sets whether the BACK button on Android should be caught. This will prevent the app from being paused. Will have no effect\n on the desktop.", :name ":set-catch-back-key"} {:args [["boolean" "catch-menu"]], :text "Sets whether the MENU button on Android should be caught. This will prevent the onscreen keyboard to show up. Will have no\n effect on the desktop.", :name ":set-catch-menu-key"} {:args [["boolean" "catched"]], :text "Only viable on the desktop. Will confine the mouse cursor location to the window and hide the mouse cursor.", :name ":set-cursor-catched"} {:args [["Pixmap" "pixmap"] ["int" "x-hotspot"] ["int" "y-hotspot"]], :text "Only viable on the desktop. Will set the mouse cursor image to the image represented by the\n {@link com.badlogic.gdx.graphics.Pixmap}. The Pixmap must be in RGBA8888 format, width & height must be powers-of-two\n greater than zero (not necessarily equal), and alpha transparency must be single-bit (i.e., 0x00 or 0xFF only). To revert to\n the default operating system cursor, pass in a null Pixmap; xHotspot & yHotspot are ignored in this case.", :name ":set-cursor-image"} {:args [["int" "x"] ["int" "y"]], :text "Only viable on the desktop. Will set the mouse cursor location to the given window coordinates (origin top-left corner).", :name ":set-cursor-position"} {:args [["InputProcessor" "processor"]], :text "Sets the {@link InputProcessor} that will receive all touch and key input events. It will be called before the\n {@link ApplicationListener#render()} method each frame.", :name ":set-input-processor"} {:args [["boolean" "visible"]], :text "Sets the on-screen keyboard visible if available.", :name ":set-onscreen-keyboard-visible"} {:args [["int" "milliseconds"]], :text "Vibrates for the given amount of time. Note that you'll need the permission\n <code> <uses-permission android:name=\"android.permission.VIBRATE\" /></code> in your manifest file in order for this to work.", :name ":vibrate"} {:args [["long[]" "pattern"] ["int" "repeat"]], :text "Vibrate with a given pattern. Pass in an array of ints that are the times at which to turn on or off the vibrator. The first\n one is how long to wait before turning it on, and then after that it alternates. If you want to repeat, pass the index into\n the pattern at which to start the repeat.", :name ":vibrate"}]}]], :name "input!", :type :code, :raw "(defmacro input!\n  [k & options]\n  `(u/call! ^Input (Gdx/input) ~k ~@options))", :docstring "<p>Calls a single method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Input.html'>Gdx.input</a>.</p><pre>\n&#40;input! :is-touched&#41;\n</pre>"} {:raw* nil, :arglists [(net! k & options)], :java [["net!" {:text "Provides methods to perform networking operations, such as simple HTTP get and post requests, and TCP server/client socket\n communication.</p>\n \n To perform an HTTP request create a {@link HttpRequest} with the HTTP method (see {@link HttpMethods} for common methods) and\n invoke {@link #sendHttpRequest(HttpRequest, HttpResponseListener)} with it and a {@link HttpResponseListener}. After the HTTP\n request was processed, the {@link HttpResponseListener} is called with a {@link HttpResponse} with the HTTP response values and\n an status code to determine if the request was successful or not.</p>\n \n To create a TCP client socket to communicate with a remote TCP server, invoke the\n {@link #newClientSocket(Protocol, String, int, SocketHints)} method. The returned {@link Socket} offers an {@link InputStream}\n and {@link OutputStream} to communicate with the end point.</p>\n \n To create a TCP server socket that waits for incoming connections, invoke the\n {@link #newServerSocket(Protocol, int, ServerSocketHints)} method. The returned {@link ServerSocket} offers an\n {@link ServerSocket#accept(SocketHints options)} method that waits for an incoming connection.", :items [{:args [["Net.HttpRequest" "http-request"]], :name ":cancel-http-request"} {:args [["Net.Protocol" "protocol"] ["String" "host"] ["int" "port"] ["SocketHints" "hints"]], :type "Socket", :text "Creates a new TCP client socket that connects to the given host and port.", :name ":new-client-socket"} {:args [["Net.Protocol" "protocol"] ["int" "port"] ["ServerSocketHints" "hints"]], :type "ServerSocket", :text "Creates a new server socket on the given port, using the given {@link Protocol}, waiting for incoming connections.", :name ":new-server-socket"} {:args [["String" "uri"]], :text "Launches the default browser to display a URI. If the default browser is not able to handle the specified URI, the\n application registered for handling URIs of the specified type is invoked. The application is determined from the protocol\n and path of the URI.", :name ":open-uri"} {:args [["Net.HttpRequest" "http-request"] ["Net.HttpResponseListener" "http-response-listener"]], :text "Process the specified {@link HttpRequest} and reports the {@link HttpResponse} to the specified {@link HttpResponseListener}\n .", :name ":send-http-request"}]}]], :name "net!", :type :code, :raw "(defmacro net!\n  [k & options]\n  `(u/call! ^Net (Gdx/net) ~k ~@options))", :docstring "<p>Calls a single method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Net.html'>Gdx.net</a>.</p><pre>\n&#40;net! :open-uri &quot;https://nightcode.info/&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(game k)], :java [], :name "game", :type :code, :raw "(defn game\n  [k]\n  (case k\n    :width (graphics! :get-width)\n    :height (graphics! :get-height)\n    :fps (graphics! :get-frames-per-second)\n    :fullscreen? (graphics! :is-fullscreen)\n    :touched? (input! :is-touched)\n    :x (input! :get-x)\n    :y (input! :get-y)\n    (u/throw-key-not-found k)))", :docstring "<p>Provides quick access to often-used functions.</p><pre>\n&#40;game :width&#41;\n</pre>"} {:raw* nil, :arglists [(key-code k)], :java [["key-code" {:text "Keys.", :items [{:name ":a"} {:name ":alt-left"} {:name ":alt-right"} {:name ":any-key"} {:name ":apostrophe"} {:name ":at"} {:name ":b"} {:name ":back"} {:name ":backslash"} {:name ":backspace"} {:name ":button-a"} {:name ":button-b"} {:name ":button-c"} {:name ":button-circle"} {:name ":button-l1"} {:name ":button-l2"} {:name ":button-mode"} {:name ":button-r1"} {:name ":button-r2"} {:name ":button-select"} {:name ":button-start"} {:name ":button-thumbl"} {:name ":button-thumbr"} {:name ":button-x"} {:name ":button-y"} {:name ":button-z"} {:name ":c"} {:name ":call"} {:name ":camera"} {:name ":center"} {:name ":clear"} {:name ":colon"} {:name ":comma"} {:name ":control-left"} {:name ":control-right"} {:name ":d"} {:name ":del"} {:name ":down"} {:name ":dpad-center"} {:name ":dpad-down"} {:name ":dpad-left"} {:name ":dpad-right"} {:name ":dpad-up"} {:name ":e"} {:name ":end"} {:name ":endcall"} {:name ":enter"} {:name ":envelope"} {:name ":equals"} {:name ":escape"} {:name ":explorer"} {:name ":f"} {:name ":f1"} {:name ":f10"} {:name ":f11"} {:name ":f12"} {:name ":f2"} {:name ":f3"} {:name ":f4"} {:name ":f5"} {:name ":f6"} {:name ":f7"} {:name ":f8"} {:name ":f9"} {:name ":focus"} {:name ":forward-del"} {:name ":g"} {:name ":grave"} {:name ":h"} {:name ":headsethook"} {:name ":home"} {:name ":i"} {:name ":insert"} {:name ":j"} {:name ":k"} {:name ":l"} {:name ":left"} {:name ":left-bracket"} {:name ":m"} {:name ":media-fast-forward"} {:name ":media-next"} {:name ":media-play-pause"} {:name ":media-previous"} {:name ":media-rewind"} {:name ":media-stop"} {:name ":menu"} {:name ":meta-alt-left-on"} {:name ":meta-alt-on"} {:name ":meta-alt-right-on"} {:name ":meta-shift-left-on"} {:name ":meta-shift-on"} {:name ":meta-shift-right-on"} {:name ":meta-sym-on"} {:name ":minus"} {:name ":mute"} {:name ":n"} {:name ":notification"} {:name ":num"} {:name ":num-0"} {:name ":num-1"} {:name ":num-2"} {:name ":num-3"} {:name ":num-4"} {:name ":num-5"} {:name ":num-6"} {:name ":num-7"} {:name ":num-8"} {:name ":num-9"} {:name ":numpad-0"} {:name ":numpad-1"} {:name ":numpad-2"} {:name ":numpad-3"} {:name ":numpad-4"} {:name ":numpad-5"} {:name ":numpad-6"} {:name ":numpad-7"} {:name ":numpad-8"} {:name ":numpad-9"} {:name ":o"} {:name ":p"} {:name ":page-down"} {:name ":page-up"} {:name ":period"} {:name ":pictsymbols"} {:name ":plus"} {:name ":pound"} {:name ":power"} {:name ":q"} {:name ":r"} {:name ":right"} {:name ":right-bracket"} {:name ":s"} {:name ":search"} {:name ":semicolon"} {:name ":shift-left"} {:name ":shift-right"} {:name ":slash"} {:name ":soft-left"} {:name ":soft-right"} {:name ":space"} {:name ":star"} {:name ":switch-charset"} {:name ":sym"} {:name ":t"} {:name ":tab"} {:name ":u"} {:name ":unknown"} {:name ":up"} {:name ":v"} {:name ":volume-down"} {:name ":volume-up"} {:name ":w"} {:name ":x"} {:name ":y"} {:name ":z"}]}]], :name "key-code", :type :code, :raw "(defmacro key-code\n  [k]\n  `~(u/gdx-field \"Input$Keys\" (u/key->upper k)))", :docstring "<p>Returns a static field from <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Input.Keys.html'>Input.Keys</a>.</p><pre>\n&#40;key-code :a&#41;\n&#40;key-code :page-down&#41;\n</pre>"} {:raw* nil, :arglists [(key-pressed? k)], :java [["key-pressed?" {:text "Keys.", :items [{:name ":a"} {:name ":alt-left"} {:name ":alt-right"} {:name ":any-key"} {:name ":apostrophe"} {:name ":at"} {:name ":b"} {:name ":back"} {:name ":backslash"} {:name ":backspace"} {:name ":button-a"} {:name ":button-b"} {:name ":button-c"} {:name ":button-circle"} {:name ":button-l1"} {:name ":button-l2"} {:name ":button-mode"} {:name ":button-r1"} {:name ":button-r2"} {:name ":button-select"} {:name ":button-start"} {:name ":button-thumbl"} {:name ":button-thumbr"} {:name ":button-x"} {:name ":button-y"} {:name ":button-z"} {:name ":c"} {:name ":call"} {:name ":camera"} {:name ":center"} {:name ":clear"} {:name ":colon"} {:name ":comma"} {:name ":control-left"} {:name ":control-right"} {:name ":d"} {:name ":del"} {:name ":down"} {:name ":dpad-center"} {:name ":dpad-down"} {:name ":dpad-left"} {:name ":dpad-right"} {:name ":dpad-up"} {:name ":e"} {:name ":end"} {:name ":endcall"} {:name ":enter"} {:name ":envelope"} {:name ":equals"} {:name ":escape"} {:name ":explorer"} {:name ":f"} {:name ":f1"} {:name ":f10"} {:name ":f11"} {:name ":f12"} {:name ":f2"} {:name ":f3"} {:name ":f4"} {:name ":f5"} {:name ":f6"} {:name ":f7"} {:name ":f8"} {:name ":f9"} {:name ":focus"} {:name ":forward-del"} {:name ":g"} {:name ":grave"} {:name ":h"} {:name ":headsethook"} {:name ":home"} {:name ":i"} {:name ":insert"} {:name ":j"} {:name ":k"} {:name ":l"} {:name ":left"} {:name ":left-bracket"} {:name ":m"} {:name ":media-fast-forward"} {:name ":media-next"} {:name ":media-play-pause"} {:name ":media-previous"} {:name ":media-rewind"} {:name ":media-stop"} {:name ":menu"} {:name ":meta-alt-left-on"} {:name ":meta-alt-on"} {:name ":meta-alt-right-on"} {:name ":meta-shift-left-on"} {:name ":meta-shift-on"} {:name ":meta-shift-right-on"} {:name ":meta-sym-on"} {:name ":minus"} {:name ":mute"} {:name ":n"} {:name ":notification"} {:name ":num"} {:name ":num-0"} {:name ":num-1"} {:name ":num-2"} {:name ":num-3"} {:name ":num-4"} {:name ":num-5"} {:name ":num-6"} {:name ":num-7"} {:name ":num-8"} {:name ":num-9"} {:name ":numpad-0"} {:name ":numpad-1"} {:name ":numpad-2"} {:name ":numpad-3"} {:name ":numpad-4"} {:name ":numpad-5"} {:name ":numpad-6"} {:name ":numpad-7"} {:name ":numpad-8"} {:name ":numpad-9"} {:name ":o"} {:name ":p"} {:name ":page-down"} {:name ":page-up"} {:name ":period"} {:name ":pictsymbols"} {:name ":plus"} {:name ":pound"} {:name ":power"} {:name ":q"} {:name ":r"} {:name ":right"} {:name ":right-bracket"} {:name ":s"} {:name ":search"} {:name ":semicolon"} {:name ":shift-left"} {:name ":shift-right"} {:name ":slash"} {:name ":soft-left"} {:name ":soft-right"} {:name ":space"} {:name ":star"} {:name ":switch-charset"} {:name ":sym"} {:name ":t"} {:name ":tab"} {:name ":u"} {:name ":unknown"} {:name ":up"} {:name ":v"} {:name ":volume-down"} {:name ":volume-up"} {:name ":w"} {:name ":x"} {:name ":y"} {:name ":z"}]}]], :name "key-pressed?", :type :code, :raw "(defmacro key-pressed?\n  [k]\n  `(input! :is-key-pressed (key-code ~k)))", :docstring "<p>Returns a boolean indicating if the key cooresponding to <code>k</code> is being pressed.</p><pre>\n&#40;key-pressed? :a&#41;\n&#40;key-pressed? :page-down&#41;\n</pre>"} {:raw* nil, :arglists [(button-code k)], :java [["button-code" {:text "Mouse buttons.", :items [{:name ":left"} {:name ":middle"} {:name ":right"}]}]], :name "button-code", :type :code, :raw "(defmacro button-code\n  [k]\n  `~(u/gdx-field \"Input$Buttons\" (u/key->upper k)))", :docstring "<p>Returns a static field from <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Input.Buttons.html'>Input.Buttons</a>.</p><pre>\n&#40;button-code :left&#41;\n</pre>"} {:raw* nil, :arglists [(button-pressed? k)], :java [["button-pressed?" {:text "Mouse buttons.", :items [{:name ":left"} {:name ":middle"} {:name ":right"}]}]], :name "button-pressed?", :type :code, :raw "(defmacro button-pressed?\n  [k]\n  `(input! :is-button-pressed (button-code ~k)))", :docstring "<p>Returns a boolean indicating if the button cooresponding to <code>k</code> is being pressed.</p><pre>\n&#40;button-pressed? :left&#41;\n</pre>"} {:raw* "(defn sound*\n  [path]\n  (let [^FileHandle fh (if (string? path)\n                         (files! :internal path)\n                         path)]\n    (or (u/load-asset (.path fh) Sound)\n        (audio! :new-sound fh))))", :arglists [(sound path & options)], :java [["sound" {:text "<p>\n A Sound is a short audio clip that can be played numerous times in parallel. It's completely loaded into memory so only load\n small audio files. Call the {@link #dispose()} method when you're done using the Sound.\n </p>\n \n <p>\n Sound instances are created via a call to {@link Audio#newSound(FileHandle)}.\n </p>\n \n <p>\n Calling the {@link #play()} or {@link #play(float)} method will return a long which is an id to that instance of the sound. You\n can use this id to modify the playback of that sound instance.\n </p>\n \n <p>\n <b>Note<b>: any values provided will not be clamped, it is the developer's responsibility to do so\n </p>", :items [{:args [], :text "Releases all the resources.", :name ":dispose"} {:args [], :type "long", :text "Plays the sound, looping. If the sound is already playing, it will be played again, concurrently.", :name ":loop"} {:args [["float" "volume"]], :type "long", :text "Plays the sound, looping. If the sound is already playing, it will be played again, concurrently. You need to stop the sound\n via a call to {@link #stop(long)} using the returned id.", :name ":loop"} {:args [["float" "volume"] ["float" "pitch"] ["float" "pan"]], :type "long", :text "Plays the sound, looping. If the sound is already playing, it will be played again, concurrently. You need to stop the sound\n via a call to {@link #stop(long)} using the returned id.", :name ":loop"} {:args [], :text "Pauses all instances of this sound.", :name ":pause"} {:args [["long" "sound-id"]], :text "Pauses the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}. If the sound is no\n longer playing, this has no effect.", :name ":pause"} {:args [], :type "long", :text "Plays the sound. If the sound is already playing, it will be played again, concurrently.", :name ":play"} {:args [["float" "volume"]], :type "long", :text "Plays the sound. If the sound is already playing, it will be played again, concurrently.", :name ":play"} {:args [["float" "volume"] ["float" "pitch"] ["float" "pan"]], :type "long", :text "Plays the sound. If the sound is already playing, it will be played again, concurrently.", :name ":play"} {:args [], :text "Resumes all paused instances of this sound.", :name ":resume"} {:args [["long" "sound-id"]], :text "Resumes the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}. If the sound is not\n paused, this has no effect.", :name ":resume"} {:args [["long" "sound-id"] ["boolean" "looping"]], :text "Sets the sound instance with the given id to be looping. If the sound is no longer playing this has no effect.s", :name ":set-looping"} {:args [["long" "sound-id"] ["float" "pan"] ["float" "volume"]], :text "Sets the panning and volume of the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}.\n If the sound is no longer playing, this has no effect.", :name ":set-pan"} {:args [["long" "sound-id"] ["float" "pitch"]], :text "Changes the pitch multiplier of the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}.\n If the sound is no longer playing, this has no effect.", :name ":set-pitch"} {:args [["long" "sound-id"] ["int" "priority"]], :text "Sets the priority of a sound currently being played back. Higher priority sounds will be considered last if the maximum\n number of concurrently playing sounds is exceeded. This is only a hint and might not be honored by a backend implementation.", :name ":set-priority"} {:args [["long" "sound-id"] ["float" "volume"]], :text "Changes the volume of the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}. If the\n sound is no longer playing, this has no effect.", :name ":set-volume"} {:args [], :text "Stops playing all instances of this sound.", :name ":stop"} {:args [["long" "sound-id"]], :text "Stops the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}. If the sound is no longer\n playing, this has no effect.", :name ":stop"}]}]], :name "sound", :type :code, :raw "(defmacro sound\n  [path & options]\n  `(let [^Sound object# (sound* ~path)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/audio/Sound.html'>Sound</a>.</p><pre>\n&#40;sound &quot;playerhurt.wav&quot;&#41;\n&#40;sound &quot;playerhurt.wav&quot; :play&#41;\n</pre>"} {:raw* nil, :arglists [(sound! object k & options)], :java [["sound!" {:text "<p>\n A Sound is a short audio clip that can be played numerous times in parallel. It's completely loaded into memory so only load\n small audio files. Call the {@link #dispose()} method when you're done using the Sound.\n </p>\n \n <p>\n Sound instances are created via a call to {@link Audio#newSound(FileHandle)}.\n </p>\n \n <p>\n Calling the {@link #play()} or {@link #play(float)} method will return a long which is an id to that instance of the sound. You\n can use this id to modify the playback of that sound instance.\n </p>\n \n <p>\n <b>Note<b>: any values provided will not be clamped, it is the developer's responsibility to do so\n </p>", :items [{:args [], :text "Releases all the resources.", :name ":dispose"} {:args [], :type "long", :text "Plays the sound, looping. If the sound is already playing, it will be played again, concurrently.", :name ":loop"} {:args [["float" "volume"]], :type "long", :text "Plays the sound, looping. If the sound is already playing, it will be played again, concurrently. You need to stop the sound\n via a call to {@link #stop(long)} using the returned id.", :name ":loop"} {:args [["float" "volume"] ["float" "pitch"] ["float" "pan"]], :type "long", :text "Plays the sound, looping. If the sound is already playing, it will be played again, concurrently. You need to stop the sound\n via a call to {@link #stop(long)} using the returned id.", :name ":loop"} {:args [], :text "Pauses all instances of this sound.", :name ":pause"} {:args [["long" "sound-id"]], :text "Pauses the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}. If the sound is no\n longer playing, this has no effect.", :name ":pause"} {:args [], :type "long", :text "Plays the sound. If the sound is already playing, it will be played again, concurrently.", :name ":play"} {:args [["float" "volume"]], :type "long", :text "Plays the sound. If the sound is already playing, it will be played again, concurrently.", :name ":play"} {:args [["float" "volume"] ["float" "pitch"] ["float" "pan"]], :type "long", :text "Plays the sound. If the sound is already playing, it will be played again, concurrently.", :name ":play"} {:args [], :text "Resumes all paused instances of this sound.", :name ":resume"} {:args [["long" "sound-id"]], :text "Resumes the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}. If the sound is not\n paused, this has no effect.", :name ":resume"} {:args [["long" "sound-id"] ["boolean" "looping"]], :text "Sets the sound instance with the given id to be looping. If the sound is no longer playing this has no effect.s", :name ":set-looping"} {:args [["long" "sound-id"] ["float" "pan"] ["float" "volume"]], :text "Sets the panning and volume of the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}.\n If the sound is no longer playing, this has no effect.", :name ":set-pan"} {:args [["long" "sound-id"] ["float" "pitch"]], :text "Changes the pitch multiplier of the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}.\n If the sound is no longer playing, this has no effect.", :name ":set-pitch"} {:args [["long" "sound-id"] ["int" "priority"]], :text "Sets the priority of a sound currently being played back. Higher priority sounds will be considered last if the maximum\n number of concurrently playing sounds is exceeded. This is only a hint and might not be honored by a backend implementation.", :name ":set-priority"} {:args [["long" "sound-id"] ["float" "volume"]], :text "Changes the volume of the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}. If the\n sound is no longer playing, this has no effect.", :name ":set-volume"} {:args [], :text "Stops playing all instances of this sound.", :name ":stop"} {:args [["long" "sound-id"]], :text "Stops the sound instance with the given id as returned by {@link #play()} or {@link #play(float)}. If the sound is no longer\n playing, this has no effect.", :name ":stop"}]}]], :name "sound!", :type :code, :raw "(defmacro sound!\n  [object k & options]\n  `(let [^Sound object# ~object]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>sound</code>.</p><pre>\n&#40;sound! object :play&#41;\n&#40;sound! object :dispose&#41;\n</pre>"})} {:ns "", :groups ({:raw* "(defn orthographic*\n  []\n  (OrthographicCamera.))", :arglists [(orthographic & options)], :java [["orthographic" {:text "A camera with orthographic projection.", :items [{:args [["float" "screen-x"] ["float" "screen-y"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Ray", :text "Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the\n whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis\n pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.", :name ":get-pick-ray"} {:args [["float" "screen-x"] ["float" "screen-y"]], :type "Ray", :text "Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the\n whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis\n pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.", :name ":get-pick-ray"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Recalculates the direction of the camera to look at the point (x, y, z). This function assumes the up vector is normalized.", :name ":look-at"} {:args [["Vector3" "target"]], :text "Recalculates the direction of the camera to look at the point (x, y, z).", :name ":look-at"} {:args [], :text "Normalizes the up vector by first calculating the right vector via a cross product between direction and up, and then\n recalculating the up vector via a cross product between right and direction.", :name ":normalize-up"} {:args [["Vector3" "world-coords"]], :type "Vector3", :text "Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small\n deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the\n <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily\n useable in conjunction with {@link Batch} and similar classes.", :name ":project"} {:args [["Vector3" "world-coords"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Vector3", :text "Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small\n deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the\n <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily\n useable in conjunction with {@link Batch} and similar classes. This method allows you to specify the viewport position and\n dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the origin in the bottom\n left corner of the screen.", :name ":project"} {:args [["float" "angle"] ["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector\n will not be orthogonalized.", :name ":rotate"} {:args [["Vector3" "axis"] ["float" "angle"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector\n will not be orthogonalized.", :name ":rotate"} {:args [["Matrix4" "transform"]], :text "Rotates the direction and up vector of this camera by the given rotation matrix. The direction and up vector will not be\n orthogonalized.", :name ":rotate"} {:args [["Quaternion" "quat"]], :text "Rotates the direction and up vector of this camera by the given {@link Quaternion}. The direction and up vector will not be\n orthogonalized.", :name ":rotate"} {:args [["float" "angle"]], :text "Rotates the camera by the given angle around the direction vector. The direction and up vector will not be orthogonalized.", :name ":rotate"} {:args [["Vector3" "point"] ["Vector3" "axis"] ["float" "angle"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis, with the axis attached to given\n point. The direction and up vector will not be orthogonalized.", :name ":rotate-around"} {:args [["boolean" "y-down"]], :text "Sets this camera to an orthographic projection using a viewport fitting the screen resolution, centered at\n (Gdx.graphics.getWidth()/2, Gdx.graphics.getHeight()/2), with the y-axis pointing up or down.", :name ":set-to-ortho"} {:args [["boolean" "y-down"] ["float" "viewport-width"] ["float" "viewport-height"]], :text "Sets this camera to an orthographic projection, centered at (viewportWidth/2, viewportHeight/2), with the y-axis pointing up\n or down.", :name ":set-to-ortho"} {:args [["Matrix4" "transform"]], :text "Transform the position, direction and up vector by the given matrix", :name ":transform"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Moves the camera by the given amount on each axis.", :name ":translate"} {:args [["Vector3" "vec"]], :text "Moves the camera by the given vector.", :name ":translate"} {:args [["float" "x"] ["float" "y"]], :text "Moves the camera by the given amount on each axis.", :name ":translate"} {:args [["Vector2" "vec"]], :text "Moves the camera by the given vector.", :name ":translate"} {:args [["Vector3" "screen-coords"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Vector3", :text "Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject, but does not\n rely on OpenGL. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left corner, y\n pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0 will return a\n point on the near plane, a z-coordinate of 1 will return a point on the far plane. This method allows you to specify the\n viewport position and dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the\n origin in the bottom left corner of the screen.", :name ":unproject"} {:args [["Vector3" "screen-coords"]], :type "Vector3", :text "Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject but does not\n rely on OpenGL. The viewport is assumed to span the whole screen and is fetched from {@link Graphics#getWidth()} and\n {@link Graphics#getHeight()}. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left\n corner, y pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0\n will return a point on the near plane, a z-coordinate of 1 will return a point on the far plane.", :name ":unproject"} {:args [], :text "Recalculates the projection and view matrix of this camera and the {@link Frustum} planes. Use this after you've manipulated\n any of the attributes of the camera.", :name ":update"} {:args [["boolean" "update-frustum"]], :text "Recalculates the projection and view matrix of this camera and the {@link Frustum} planes if <code>updateFrustum</code> is\n true. Use this after you've manipulated any of the attributes of the camera.", :name ":update"} {:args [], :name ":update"} {:args [["boolean" "update-frustum"]], :name ":update"}]}]], :name "orthographic", :type :code, :raw "(defmacro orthographic\n  [& options]\n  `(let [^OrthographicCamera object# (orthographic*)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/OrthographicCamera.html'>OrthographicCamera</a>.</p><pre>\n&#40;orthographic&#41;\n</pre>"} {:raw* nil, :arglists [(orthographic! screen k & options)], :java [["orthographic!" {:text "A camera with orthographic projection.", :items [{:args [["float" "screen-x"] ["float" "screen-y"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Ray", :text "Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the\n whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis\n pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.", :name ":get-pick-ray"} {:args [["float" "screen-x"] ["float" "screen-y"]], :type "Ray", :text "Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the\n whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis\n pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.", :name ":get-pick-ray"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Recalculates the direction of the camera to look at the point (x, y, z). This function assumes the up vector is normalized.", :name ":look-at"} {:args [["Vector3" "target"]], :text "Recalculates the direction of the camera to look at the point (x, y, z).", :name ":look-at"} {:args [], :text "Normalizes the up vector by first calculating the right vector via a cross product between direction and up, and then\n recalculating the up vector via a cross product between right and direction.", :name ":normalize-up"} {:args [["Vector3" "world-coords"]], :type "Vector3", :text "Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small\n deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the\n <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily\n useable in conjunction with {@link Batch} and similar classes.", :name ":project"} {:args [["Vector3" "world-coords"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Vector3", :text "Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small\n deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the\n <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily\n useable in conjunction with {@link Batch} and similar classes. This method allows you to specify the viewport position and\n dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the origin in the bottom\n left corner of the screen.", :name ":project"} {:args [["float" "angle"] ["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector\n will not be orthogonalized.", :name ":rotate"} {:args [["Vector3" "axis"] ["float" "angle"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector\n will not be orthogonalized.", :name ":rotate"} {:args [["Matrix4" "transform"]], :text "Rotates the direction and up vector of this camera by the given rotation matrix. The direction and up vector will not be\n orthogonalized.", :name ":rotate"} {:args [["Quaternion" "quat"]], :text "Rotates the direction and up vector of this camera by the given {@link Quaternion}. The direction and up vector will not be\n orthogonalized.", :name ":rotate"} {:args [["float" "angle"]], :text "Rotates the camera by the given angle around the direction vector. The direction and up vector will not be orthogonalized.", :name ":rotate"} {:args [["Vector3" "point"] ["Vector3" "axis"] ["float" "angle"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis, with the axis attached to given\n point. The direction and up vector will not be orthogonalized.", :name ":rotate-around"} {:args [["boolean" "y-down"]], :text "Sets this camera to an orthographic projection using a viewport fitting the screen resolution, centered at\n (Gdx.graphics.getWidth()/2, Gdx.graphics.getHeight()/2), with the y-axis pointing up or down.", :name ":set-to-ortho"} {:args [["boolean" "y-down"] ["float" "viewport-width"] ["float" "viewport-height"]], :text "Sets this camera to an orthographic projection, centered at (viewportWidth/2, viewportHeight/2), with the y-axis pointing up\n or down.", :name ":set-to-ortho"} {:args [["Matrix4" "transform"]], :text "Transform the position, direction and up vector by the given matrix", :name ":transform"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Moves the camera by the given amount on each axis.", :name ":translate"} {:args [["Vector3" "vec"]], :text "Moves the camera by the given vector.", :name ":translate"} {:args [["float" "x"] ["float" "y"]], :text "Moves the camera by the given amount on each axis.", :name ":translate"} {:args [["Vector2" "vec"]], :text "Moves the camera by the given vector.", :name ":translate"} {:args [["Vector3" "screen-coords"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Vector3", :text "Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject, but does not\n rely on OpenGL. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left corner, y\n pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0 will return a\n point on the near plane, a z-coordinate of 1 will return a point on the far plane. This method allows you to specify the\n viewport position and dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the\n origin in the bottom left corner of the screen.", :name ":unproject"} {:args [["Vector3" "screen-coords"]], :type "Vector3", :text "Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject but does not\n rely on OpenGL. The viewport is assumed to span the whole screen and is fetched from {@link Graphics#getWidth()} and\n {@link Graphics#getHeight()}. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left\n corner, y pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0\n will return a point on the near plane, a z-coordinate of 1 will return a point on the far plane.", :name ":unproject"} {:args [], :text "Recalculates the projection and view matrix of this camera and the {@link Frustum} planes. Use this after you've manipulated\n any of the attributes of the camera.", :name ":update"} {:args [["boolean" "update-frustum"]], :text "Recalculates the projection and view matrix of this camera and the {@link Frustum} planes if <code>updateFrustum</code> is\n true. Use this after you've manipulated any of the attributes of the camera.", :name ":update"} {:args [], :name ":update"} {:args [["boolean" "update-frustum"]], :name ":update"}]}]], :name "orthographic!", :type :code, :raw "(defmacro orthographic!\n  [screen k & options]\n  `(let [^OrthographicCamera object# (u/get-obj ~screen :camera)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on an <code>orthographic</code>.</p>"} {:raw* "(defn perspective*\n  ([]\n    (PerspectiveCamera.))\n  ([field-of-view viewport-width viewport-height]\n    (PerspectiveCamera. field-of-view viewport-width viewport-height)))", :arglists [(perspective field-of-view viewport-width viewport-height & options)], :java [["perspective" {:text "A Camera with perspective projection.", :items [{:args [["float" "screen-x"] ["float" "screen-y"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Ray", :text "Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the\n whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis\n pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.", :name ":get-pick-ray"} {:args [["float" "screen-x"] ["float" "screen-y"]], :type "Ray", :text "Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the\n whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis\n pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.", :name ":get-pick-ray"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Recalculates the direction of the camera to look at the point (x, y, z). This function assumes the up vector is normalized.", :name ":look-at"} {:args [["Vector3" "target"]], :text "Recalculates the direction of the camera to look at the point (x, y, z).", :name ":look-at"} {:args [], :text "Normalizes the up vector by first calculating the right vector via a cross product between direction and up, and then\n recalculating the up vector via a cross product between right and direction.", :name ":normalize-up"} {:args [["Vector3" "world-coords"]], :type "Vector3", :text "Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small\n deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the\n <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily\n useable in conjunction with {@link Batch} and similar classes.", :name ":project"} {:args [["Vector3" "world-coords"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Vector3", :text "Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small\n deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the\n <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily\n useable in conjunction with {@link Batch} and similar classes. This method allows you to specify the viewport position and\n dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the origin in the bottom\n left corner of the screen.", :name ":project"} {:args [["float" "angle"] ["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector\n will not be orthogonalized.", :name ":rotate"} {:args [["Vector3" "axis"] ["float" "angle"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector\n will not be orthogonalized.", :name ":rotate"} {:args [["Matrix4" "transform"]], :text "Rotates the direction and up vector of this camera by the given rotation matrix. The direction and up vector will not be\n orthogonalized.", :name ":rotate"} {:args [["Quaternion" "quat"]], :text "Rotates the direction and up vector of this camera by the given {@link Quaternion}. The direction and up vector will not be\n orthogonalized.", :name ":rotate"} {:args [["Vector3" "point"] ["Vector3" "axis"] ["float" "angle"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis, with the axis attached to given\n point. The direction and up vector will not be orthogonalized.", :name ":rotate-around"} {:args [["Matrix4" "transform"]], :text "Transform the position, direction and up vector by the given matrix", :name ":transform"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Moves the camera by the given amount on each axis.", :name ":translate"} {:args [["Vector3" "vec"]], :text "Moves the camera by the given vector.", :name ":translate"} {:args [["Vector3" "screen-coords"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Vector3", :text "Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject, but does not\n rely on OpenGL. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left corner, y\n pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0 will return a\n point on the near plane, a z-coordinate of 1 will return a point on the far plane. This method allows you to specify the\n viewport position and dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the\n origin in the bottom left corner of the screen.", :name ":unproject"} {:args [["Vector3" "screen-coords"]], :type "Vector3", :text "Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject but does not\n rely on OpenGL. The viewport is assumed to span the whole screen and is fetched from {@link Graphics#getWidth()} and\n {@link Graphics#getHeight()}. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left\n corner, y pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0\n will return a point on the near plane, a z-coordinate of 1 will return a point on the far plane.", :name ":unproject"} {:args [], :text "Recalculates the projection and view matrix of this camera and the {@link Frustum} planes. Use this after you've manipulated\n any of the attributes of the camera.", :name ":update"} {:args [["boolean" "update-frustum"]], :text "Recalculates the projection and view matrix of this camera and the {@link Frustum} planes if <code>updateFrustum</code> is\n true. Use this after you've manipulated any of the attributes of the camera.", :name ":update"} {:args [], :name ":update"} {:args [["boolean" "update-frustum"]], :name ":update"}]}]], :name "perspective", :type :code, :raw "(defmacro perspective\n  [field-of-view viewport-width viewport-height & options]\n  `(let [^PerspectiveCamera object#\n         (perspective* ~field-of-view ~viewport-width ~viewport-height)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/PerspectiveCamera.html'>PerspectiveCamera</a>.</p><pre>\n&#40;perspective 75 &#40;game :width&#41; &#40;game :height&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(perspective! screen k & options)], :java [["perspective!" {:text "A Camera with perspective projection.", :items [{:args [["float" "screen-x"] ["float" "screen-y"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Ray", :text "Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the\n whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis\n pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.", :name ":get-pick-ray"} {:args [["float" "screen-x"] ["float" "screen-y"]], :type "Ray", :text "Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the\n whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis\n pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.", :name ":get-pick-ray"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Recalculates the direction of the camera to look at the point (x, y, z). This function assumes the up vector is normalized.", :name ":look-at"} {:args [["Vector3" "target"]], :text "Recalculates the direction of the camera to look at the point (x, y, z).", :name ":look-at"} {:args [], :text "Normalizes the up vector by first calculating the right vector via a cross product between direction and up, and then\n recalculating the up vector via a cross product between right and direction.", :name ":normalize-up"} {:args [["Vector3" "world-coords"]], :type "Vector3", :text "Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small\n deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the\n <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily\n useable in conjunction with {@link Batch} and similar classes.", :name ":project"} {:args [["Vector3" "world-coords"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Vector3", :text "Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small\n deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the\n <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily\n useable in conjunction with {@link Batch} and similar classes. This method allows you to specify the viewport position and\n dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the origin in the bottom\n left corner of the screen.", :name ":project"} {:args [["float" "angle"] ["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector\n will not be orthogonalized.", :name ":rotate"} {:args [["Vector3" "axis"] ["float" "angle"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector\n will not be orthogonalized.", :name ":rotate"} {:args [["Matrix4" "transform"]], :text "Rotates the direction and up vector of this camera by the given rotation matrix. The direction and up vector will not be\n orthogonalized.", :name ":rotate"} {:args [["Quaternion" "quat"]], :text "Rotates the direction and up vector of this camera by the given {@link Quaternion}. The direction and up vector will not be\n orthogonalized.", :name ":rotate"} {:args [["Vector3" "point"] ["Vector3" "axis"] ["float" "angle"]], :text "Rotates the direction and up vector of this camera by the given angle around the given axis, with the axis attached to given\n point. The direction and up vector will not be orthogonalized.", :name ":rotate-around"} {:args [["Matrix4" "transform"]], :text "Transform the position, direction and up vector by the given matrix", :name ":transform"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Moves the camera by the given amount on each axis.", :name ":translate"} {:args [["Vector3" "vec"]], :text "Moves the camera by the given vector.", :name ":translate"} {:args [["Vector3" "screen-coords"] ["float" "viewport-x"] ["float" "viewport-y"] ["float" "viewport-width"] ["float" "viewport-height"]], :type "Vector3", :text "Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject, but does not\n rely on OpenGL. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left corner, y\n pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0 will return a\n point on the near plane, a z-coordinate of 1 will return a point on the far plane. This method allows you to specify the\n viewport position and dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the\n origin in the bottom left corner of the screen.", :name ":unproject"} {:args [["Vector3" "screen-coords"]], :type "Vector3", :text "Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject but does not\n rely on OpenGL. The viewport is assumed to span the whole screen and is fetched from {@link Graphics#getWidth()} and\n {@link Graphics#getHeight()}. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left\n corner, y pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0\n will return a point on the near plane, a z-coordinate of 1 will return a point on the far plane.", :name ":unproject"} {:args [], :text "Recalculates the projection and view matrix of this camera and the {@link Frustum} planes. Use this after you've manipulated\n any of the attributes of the camera.", :name ":update"} {:args [["boolean" "update-frustum"]], :text "Recalculates the projection and view matrix of this camera and the {@link Frustum} planes if <code>updateFrustum</code> is\n true. Use this after you've manipulated any of the attributes of the camera.", :name ":update"} {:args [], :name ":update"} {:args [["boolean" "update-frustum"]], :name ":update"}]}]], :name "perspective!", :type :code, :raw "(defmacro perspective!\n  [screen k & options]\n  `(let [^PerspectiveCamera object# (u/get-obj ~screen :camera)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>perspective</code>.</p>"} {:raw* nil, :arglists [(size! screen width height)], :java [], :name "size!", :type :code, :raw "(defn size!\n  [screen width height]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (set! (. camera viewportWidth) width)\n    (set! (. camera viewportHeight) height)\n    (.update camera)))", :docstring "<p>Sets the size of the camera in <code>screen</code>.</p><pre>\n&#40;size! screen 480 360&#41;\n</pre>"} {:raw* nil, :arglists [(width screen)], :java [], :name "width", :type :code, :raw "(defn width\n  [screen]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (. camera viewportWidth)))", :docstring "<p>Returns the width of the camera in <code>screen</code>.</p><pre>\n&#40;width screen&#41;\n</pre>"} {:raw* nil, :arglists [(width! screen new-width)], :java [], :name "width!", :type :code, :raw "(defn width!\n  [screen new-width]\n  (size! screen new-width (* new-width (/ (game :height) (game :width)))))", :docstring "<p>Sets the width of the camera in <code>screen</code>, adjusting the height so the ratio remains in tact.</p><pre>\n&#40;width! screen 480&#41;\n</pre>"} {:raw* nil, :arglists [(height screen)], :java [], :name "height", :type :code, :raw "(defn height\n  [screen]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (. camera viewportHeight)))", :docstring "<p>Returns the height of the camera in <code>screen</code>.</p><pre>\n&#40;height screen&#41;\n</pre>"} {:raw* nil, :arglists [(height! screen new-height)], :java [], :name "height!", :type :code, :raw "(defn height!\n  [screen new-height]\n  (size! screen (* new-height (/ (game :width) (game :height))) new-height))", :docstring "<p>Sets the height of the camera in <code>screen</code>, adjusting the width so the ratio remains in tact.</p><pre>\n&#40;height! screen 360&#41;\n</pre>"} {:raw* nil, :arglists [(x object)], :java [], :name "x", :type :code, :raw "(defn x\n  [object]\n  (cond\n    (isa? (type object) Vector2) (. ^Vector2 object x)\n    (isa? (type object) Vector3) (. ^Vector3 object x)\n    :else (let [^Camera camera (u/get-obj object :camera)]\n            (. (. camera position) x))))", :docstring "<p>Returns the x position of <code>object</code>. If <code>object</code> is a screen, the x position of the camera will be returned.</p>"} {:raw* nil, :arglists [(x! object x-val)], :java [], :name "x!", :type :code, :raw "(defn x!\n  [object x-val]\n  (cond\n    (isa? (type object) Vector2) (let [^Vector2 v object]\n                                   (.set v x-val (. v y)))\n    (isa? (type object) Vector3) (let [^Vector3 v object]\n                                   (.set v x-val (. v y) (. v z)))\n    :else (let [^Camera camera (u/get-obj object :camera)]\n            (set! (. (. camera position) x) x-val)\n            (.update camera))))", :docstring "<p>Sets only the x position of <code>object</code>. If <code>object</code> is a screen, the x position of the camera will be set.</p>"} {:raw* nil, :arglists [(y object)], :java [], :name "y", :type :code, :raw "(defn y\n  [object]\n  (cond\n    (isa? (type object) Vector2) (. ^Vector2 object y)\n    (isa? (type object) Vector3) (. ^Vector3 object y)\n    :else (let [^Camera camera (u/get-obj object :camera)]\n            (. (. camera position) y))))", :docstring "<p>Returns the y position of <code>object</code>. If <code>object</code> is a screen, the y position of the camera will be returned.</p>"} {:raw* nil, :arglists [(y! object y-val)], :java [], :name "y!", :type :code, :raw "(defn y!\n  [object y-val]\n  (cond\n    (isa? (type object) Vector2) (let [^Vector2 v object]\n                                   (.set v (. v x) y-val))\n    (isa? (type object) Vector3) (let [^Vector3 v object]\n                                   (.set v (. v x) y-val (. v z)))\n    :else (let [^Camera camera (u/get-obj object :camera)]\n            (set! (. (. camera position) y) y-val)\n            (.update camera))))", :docstring "<p>Sets only the y position of <code>object</code>. If <code>object</code> is a screen, the y position of the camera will be set.</p>"} {:raw* nil, :arglists [(z object)], :java [], :name "z", :type :code, :raw "(defn z\n  [object]\n  (cond\n    (isa? (type object) Vector3) (. ^Vector3 object z)\n    :else (let [^Camera camera (u/get-obj object :camera)]\n            (. (. camera position) z))))", :docstring "<p>Returns the z position of <code>object</code>. If <code>object</code> is a screen, the z position of the camera will be returned.</p>"} {:raw* nil, :arglists [(z! object z-val)], :java [], :name "z!", :type :code, :raw "(defn z!\n  [object z-val]\n  (cond\n    (isa? (type object) Vector3) (let [^Vector3 v object]\n                                   (.set v (. v x) (. v y) z-val))\n    :else (let [^Camera camera (u/get-obj object :camera)]\n            (set! (. (. camera position) z) z-val)\n            (.update camera))))", :docstring "<p>Sets only the z position of <code>object</code>. If <code>object</code> is a screen, the z position of the camera will be set.</p>"} {:raw* nil, :arglists [(position screen)], :java [], :name "position", :type :code, :raw "(defn position\n  [screen]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (. camera position)))", :docstring "<p>Returns the position of the camera in <code>screen</code>.</p>"} {:raw* nil, :arglists [(position! object vec-3) (position! object x-val y-val) (position! object x-val y-val z-val)], :java [], :name "position!", :type :code, :raw "(defn position!\n  ([object vec-3]\n    (let [^Camera camera (u/get-obj object :camera)]\n      (set! (. camera position) vec-3)))\n  ([object x-val y-val]\n    (position! object x-val y-val nil))\n  ([object x-val y-val z-val]\n    (when x-val (x! object x-val))\n    (when y-val (y! object y-val))\n    (when z-val (z! object z-val))))", :docstring "<p>Sets the position of <code>object</code>. If <code>object</code> is a screen, the position of the camera will be set.</p>"} {:raw* nil, :arglists [(direction screen)], :java [], :name "direction", :type :code, :raw "(defn direction\n  [screen]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (. camera direction)))", :docstring "<p>Returns the direction of the camera in <code>screen</code>.</p>"} {:raw* nil, :arglists [(direction! screen x y z)], :java [], :name "direction!", :type :code, :raw "(defn direction!\n  [screen x y z]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (.lookAt camera x y z)\n    (.update camera)))", :docstring "<p>Sets the direction of the camera in <code>screen</code>.</p>"} {:raw* nil, :arglists [(near screen)], :java [], :name "near", :type :code, :raw "(defn near\n  [screen]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (. camera near)))", :docstring "<p>Returns the near clipping plane distance of the camera in <code>screen</code>.</p>"} {:raw* nil, :arglists [(near! screen n)], :java [], :name "near!", :type :code, :raw "(defn near!\n  [screen n]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (set! (. camera near) n)\n    (.update camera)))", :docstring "<p>Sets the near clipping plane distance of the camera in <code>screen</code>.</p>"} {:raw* nil, :arglists [(far screen)], :java [], :name "far", :type :code, :raw "(defn far\n  [screen]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (. camera far)))", :docstring "<p>Returns the far clipping plane distance of the camera in <code>screen</code>.</p>"} {:raw* nil, :arglists [(far! screen n)], :java [], :name "far!", :type :code, :raw "(defn far!\n  [screen n]\n  (let [^Camera camera (u/get-obj screen :camera)]\n    (set! (. camera far) n)\n    (.update camera)))", :docstring "<p>Sets the far clipping plane distance of the camera in <code>screen</code>.</p>"})} {:ns "", :groups ({:raw* "(defn pixmap*\n  [path]\n  (let [^FileHandle fh (if (string? path)\n                         (files! :internal path)\n                         path)]\n    (or (u/load-asset (.path fh) Pixmap)\n        (Pixmap. fh))))", :arglists [(pixmap path & options)], :java [["pixmap" {:text "<p>\n A Pixmap represents an image in memory. It has a width and height expressed in pixels as well as a {@link Format} specifying\n the number and order of color components per pixel. Coordinates of pixels are specified with respect to the top left corner of\n the image, with the x-axis pointing to the right and the y-axis pointing downwards.\n </p>\n \n <p>\n By default all methods use blending. You can disable blending with {@link Pixmap#setBlending(Blending)}. The\n {@link Pixmap#drawPixmap(Pixmap, int, int, int, int, int, int, int, int)} method will scale and stretch the source image to a\n target image. There either nearest neighbour or bilinear filtering can be used.\n </p>\n \n <p>\n A Pixmap stores its data in native heap memory. It is mandatory to call {@link Pixmap#dispose()} when the pixmap is no longer\n needed, otherwise memory leaks will result\n </p>", :items [{:args [], :text "Releases all resources associated with this Pixmap.", :name ":dispose"} {:args [["int" "x"] ["int" "y"] ["int" "radius"]], :text "Draws a circle outline with the center at x,y and a radius using the current color and stroke width.", :name ":draw-circle"} {:args [["int" "x"] ["int" "y"] ["int" "x2"] ["int" "y2"]], :text "Draws a line between the given coordinates using the currently set color.", :name ":draw-line"} {:args [["int" "x"] ["int" "y"]], :text "Draws a pixel at the given location with the current color.", :name ":draw-pixel"} {:args [["int" "x"] ["int" "y"] ["int" "color"]], :text "Draws a pixel at the given location with the given color.", :name ":draw-pixel"} {:args [["Pixmap" "pixmap"] ["int" "x"] ["int" "y"]], :text "Draws an area form another Pixmap to this Pixmap.", :name ":draw-pixmap"} {:args [["Pixmap" "pixmap"] ["int" "x"] ["int" "y"] ["int" "srcx"] ["int" "srcy"] ["int" "src-width"] ["int" "src-height"]], :text "Draws an area form another Pixmap to this Pixmap.", :name ":draw-pixmap"} {:args [["Pixmap" "pixmap"] ["int" "srcx"] ["int" "srcy"] ["int" "src-width"] ["int" "src-height"] ["int" "dstx"] ["int" "dsty"] ["int" "dst-width"] ["int" "dst-height"]], :text "Draws an area form another Pixmap to this Pixmap. This will automatically scale and stretch the source image to the\n specified target rectangle. Use {@link Pixmap#setFilter(Filter)} to specify the type of filtering to be used (nearest\n neighbour or bilinear).", :name ":draw-pixmap"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :text "Draws a rectangle outline starting at x, y extending by width to the right and by height downwards (y-axis points downwards)\n using the current color.", :name ":draw-rectangle"} {:args [], :text "Fills the complete bitmap with the currently set color.", :name ":fill"} {:args [["int" "x"] ["int" "y"] ["int" "radius"]], :text "Fills a circle with the center at x,y and a radius using the current color.", :name ":fill-circle"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :text "Fills a rectangle starting at x, y extending by width to the right and by height downwards (y-axis points downwards) using\n the current color.", :name ":fill-rectangle"} {:args [["int" "x1"] ["int" "y1"] ["int" "x2"] ["int" "y2"] ["int" "x3"] ["int" "y3"]], :text "Fills a triangle with vertices at x1,y1 and x2,y2 and x3,y3 using the current color.", :name ":fill-triangle"} {:args [], :type "Pixmap.Format", :name ":get-format"} {:args [], :type "int", :text "Returns the OpenGL ES format of this Pixmap. Used as the seventh parameter to\n {@link GL20#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)}.", :name ":get-glformat"} {:args [], :type "int", :text "Returns the OpenGL ES format of this Pixmap. Used as the third parameter to\n {@link GL20#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)}.", :name ":get-glinternal-format"} {:args [], :type "int", :text "Returns the OpenGL ES type of this Pixmap. Used as the eighth parameter to\n {@link GL20#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)}.", :name ":get-gltype"} {:args [], :type "int", :name ":get-height"} {:args [["int" "x"] ["int" "y"]], :type "int", :text "Returns the 32-bit RGBA8888 value of the pixel at x, y. For Alpha formats the RGB components will be one.", :name ":get-pixel"} {:args [], :type "ByteBuffer", :text "Returns the direct ByteBuffer holding the pixel data. For the format Alpha each value is encoded as a byte. For the format\n LuminanceAlpha the luminance is the first byte and the alpha is the second byte of the pixel. For the formats RGB888 and\n RGBA8888 the color components are stored in a single byte each in the order red, green, blue (alpha). For the formats RGB565\n and RGBA4444 the pixel colors are stored in shorts in machine dependent order.", :name ":get-pixels"} {:args [], :type "int", :name ":get-width"} {:args [["int" "color"]], :text "Sets the color for the following drawing operations", :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :text "Sets the color for the following drawing operations.", :name ":set-color"} {:args [["Color" "color"]], :text "Sets the color for the following drawing operations.", :name ":set-color"}]}]], :name "pixmap", :type :code, :raw "(defmacro pixmap\n  [path & options]\n  `(let [^Pixmap object# (pixmap* ~path)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/Pixmap.html'>Pixmap</a>.</p><pre>\n&#40;pixmap &quot;image.png&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(pixmap! object k & options)], :java [["pixmap!" {:text "<p>\n A Pixmap represents an image in memory. It has a width and height expressed in pixels as well as a {@link Format} specifying\n the number and order of color components per pixel. Coordinates of pixels are specified with respect to the top left corner of\n the image, with the x-axis pointing to the right and the y-axis pointing downwards.\n </p>\n \n <p>\n By default all methods use blending. You can disable blending with {@link Pixmap#setBlending(Blending)}. The\n {@link Pixmap#drawPixmap(Pixmap, int, int, int, int, int, int, int, int)} method will scale and stretch the source image to a\n target image. There either nearest neighbour or bilinear filtering can be used.\n </p>\n \n <p>\n A Pixmap stores its data in native heap memory. It is mandatory to call {@link Pixmap#dispose()} when the pixmap is no longer\n needed, otherwise memory leaks will result\n </p>", :items [{:args [], :text "Releases all resources associated with this Pixmap.", :name ":dispose"} {:args [["int" "x"] ["int" "y"] ["int" "radius"]], :text "Draws a circle outline with the center at x,y and a radius using the current color and stroke width.", :name ":draw-circle"} {:args [["int" "x"] ["int" "y"] ["int" "x2"] ["int" "y2"]], :text "Draws a line between the given coordinates using the currently set color.", :name ":draw-line"} {:args [["int" "x"] ["int" "y"]], :text "Draws a pixel at the given location with the current color.", :name ":draw-pixel"} {:args [["int" "x"] ["int" "y"] ["int" "color"]], :text "Draws a pixel at the given location with the given color.", :name ":draw-pixel"} {:args [["Pixmap" "pixmap"] ["int" "x"] ["int" "y"]], :text "Draws an area form another Pixmap to this Pixmap.", :name ":draw-pixmap"} {:args [["Pixmap" "pixmap"] ["int" "x"] ["int" "y"] ["int" "srcx"] ["int" "srcy"] ["int" "src-width"] ["int" "src-height"]], :text "Draws an area form another Pixmap to this Pixmap.", :name ":draw-pixmap"} {:args [["Pixmap" "pixmap"] ["int" "srcx"] ["int" "srcy"] ["int" "src-width"] ["int" "src-height"] ["int" "dstx"] ["int" "dsty"] ["int" "dst-width"] ["int" "dst-height"]], :text "Draws an area form another Pixmap to this Pixmap. This will automatically scale and stretch the source image to the\n specified target rectangle. Use {@link Pixmap#setFilter(Filter)} to specify the type of filtering to be used (nearest\n neighbour or bilinear).", :name ":draw-pixmap"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :text "Draws a rectangle outline starting at x, y extending by width to the right and by height downwards (y-axis points downwards)\n using the current color.", :name ":draw-rectangle"} {:args [], :text "Fills the complete bitmap with the currently set color.", :name ":fill"} {:args [["int" "x"] ["int" "y"] ["int" "radius"]], :text "Fills a circle with the center at x,y and a radius using the current color.", :name ":fill-circle"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :text "Fills a rectangle starting at x, y extending by width to the right and by height downwards (y-axis points downwards) using\n the current color.", :name ":fill-rectangle"} {:args [["int" "x1"] ["int" "y1"] ["int" "x2"] ["int" "y2"] ["int" "x3"] ["int" "y3"]], :text "Fills a triangle with vertices at x1,y1 and x2,y2 and x3,y3 using the current color.", :name ":fill-triangle"} {:args [], :type "Pixmap.Format", :name ":get-format"} {:args [], :type "int", :text "Returns the OpenGL ES format of this Pixmap. Used as the seventh parameter to\n {@link GL20#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)}.", :name ":get-glformat"} {:args [], :type "int", :text "Returns the OpenGL ES format of this Pixmap. Used as the third parameter to\n {@link GL20#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)}.", :name ":get-glinternal-format"} {:args [], :type "int", :text "Returns the OpenGL ES type of this Pixmap. Used as the eighth parameter to\n {@link GL20#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)}.", :name ":get-gltype"} {:args [], :type "int", :name ":get-height"} {:args [["int" "x"] ["int" "y"]], :type "int", :text "Returns the 32-bit RGBA8888 value of the pixel at x, y. For Alpha formats the RGB components will be one.", :name ":get-pixel"} {:args [], :type "ByteBuffer", :text "Returns the direct ByteBuffer holding the pixel data. For the format Alpha each value is encoded as a byte. For the format\n LuminanceAlpha the luminance is the first byte and the alpha is the second byte of the pixel. For the formats RGB888 and\n RGBA8888 the color components are stored in a single byte each in the order red, green, blue (alpha). For the formats RGB565\n and RGBA4444 the pixel colors are stored in shorts in machine dependent order.", :name ":get-pixels"} {:args [], :type "int", :name ":get-width"} {:args [["int" "color"]], :text "Sets the color for the following drawing operations", :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :text "Sets the color for the following drawing operations.", :name ":set-color"} {:args [["Color" "color"]], :text "Sets the color for the following drawing operations.", :name ":set-color"}]}]], :name "pixmap!", :type :code, :raw "(defmacro pixmap!\n  [object k & options]\n  `(let [^Pixmap object# ~object]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>pixmap</code>.</p><pre>\n&#40;pixmap! object :dispose&#41;\n</pre>"} {:raw* nil, :arglists [(shape-type k)], :java [["shape-type" {:text "Shape types to be used with {@link #begin(ShapeType)}.", :items [{:name ":filled"} {:name ":line"} {:name ":point"}]}]], :name "shape-type", :type :code, :raw "(defmacro shape-type\n  [k]\n  `~(u/gdx-field :graphics :glutils \"ShapeRenderer$ShapeType\" (u/key->pascal k)))", :docstring "<p>Returns a static field from <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/glutils/ShapeRenderer.ShapeType.html'>ShapeRenderer.ShapeType</a>.</p><pre>\n&#40;shape-type :filled&#41;\n</pre>"} {:raw* "(defn shape*\n  ([]\n    (ShapeEntity. (ShapeRenderer.)))\n  ([max-vertices]\n    (ShapeEntity. (ShapeRenderer. max-vertices))))", :arglists [(shape type & options)], :java [["shape" {:text "Renders points, lines, rectangles, filled rectangles and boxes.</p>\n \n This class works with OpenGL ES 1.x and 2.0. In its base configuration a 2D orthographic projection with the origin in the\n lower left corner is used. Units are given in screen pixels.</p>\n \n To change the projection properties use the {@link #setProjectionMatrix(Matrix4)} method. Usually the {@link Camera#combined}\n matrix is set via this method. If the screen orientation or resolution changes, the projection matrix might have to be adapted\n as well.</p>\n \n Shapes are rendered in batches to increase performance. The standard use-pattern looks as follows:\n \n <pre>\n {@code\n camera.update();\n shapeRenderer.setProjectionMatrix(camera.combined);\n \n shapeRenderer.begin(ShapeType.Line);\n shapeRenderer.setColor(1, 1, 0, 1);\n shapeRenderer.line(x, y, x2, y2);\n shapeRenderer.rect(x, y, width, height);\n shapeRenderer.circle(x, y, radius);\n shapeRenderer.end();\n \n shapeRenderer.begin(ShapeType.Filled);\n shapeRenderer.setColor(0, 1, 0, 1);\n shapeRenderer.rect(x, y, width, height);\n shapeRenderer.circle(x, y, radius);\n shapeRenderer.end();\n }\n </pre>\n \n The class has a second matrix called the transformation matrix which is used to rotate, scale and translate shapes in a more\n flexible manner. This mechanism works much like matrix operations in OpenGL ES 1.x. The following example shows how to rotate a\n rectangle around its center using the z-axis as the rotation axis and placing it's center at (20, 12, 2):\n \n <pre>\n shapeRenderer.begin(ShapeType.Line);\n shapeRenderer.identity();\n shapeRenderer.translate(20, 12, 2);\n shapeRenderer.rotate(0, 0, 1, 90);\n shapeRenderer.rect(-width / 2, -height / 2, width, height);\n shapeRenderer.end();\n </pre>\n \n Matrix operations all use postmultiplication and work just like glTranslate, glScale and glRotate. The last transformation\n specified will be the first that is applied to a shape (rotate then translate in the above example).\n \n The projection and transformation matrices are a state of the ShapeRenderer, just like the color and will be applied to all\n shapes until they are changed.", :items [{:args [["float" "x"] ["float" "y"] ["float" "radius"] ["float" "start"] ["float" "angle"]], :text "Calls {@link #arc(float, float, float, float, float, int)} by estimating the number of segments needed for a smooth arc.", :name ":arc"} {:args [["float" "x"] ["float" "y"] ["float" "radius"] ["float" "start"] ["float" "angle"] ["int" "segments"]], :name ":arc"} {:args [["ShapeRenderer.ShapeType" "type"]], :text "Starts a new batch of shapes. All shapes within the batch have to have the type specified. E.g. if {@link ShapeType#Point}\n is specified, only call #point().\n \n The call to this method must be paired with a call to {@link #end()}.\n \n In case OpenGL ES 1.x is used, the projection and modelview matrix will be modified.", :name ":begin"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "width"] ["float" "height"] ["float" "depth"]], :text "Draws a cube. The x, y and z coordinate specify the bottom left front corner of the rectangle. The {@link ShapeType} passed\n to begin has to be {@link ShapeType#Line}.", :name ":box"} {:args [["float" "x"] ["float" "y"] ["float" "radius"]], :text "Calls {@link #circle(float, float, float, int)} by estimating the number of segments needed for a smooth circle.", :name ":circle"} {:args [["float" "x"] ["float" "y"] ["float" "radius"] ["int" "segments"]], :name ":circle"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radius"] ["float" "height"]], :text "Calls {@link #cone(float, float, float, float, float, int)} by estimating the number of segments needed for a smooth\n circular base.", :name ":cone"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radius"] ["float" "height"] ["int" "segments"]], :name ":cone"} {:args [["float" "x1"] ["float" "y1"] ["float" "cx1"] ["float" "cy1"] ["float" "cx2"] ["float" "cy2"] ["float" "x2"] ["float" "y2"] ["int" "segments"]], :name ":curve"} {:args [], :name ":dispose"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Calls {@link #ellipse(float, float, float, float, int)} by estimating the number of segments needed for a smooth ellipse.", :name ":ellipse"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["int" "segments"]], :name ":ellipse"} {:args [], :text "Finishes the batch of shapes and ensures they get rendered.", :name ":end"} {:args [], :name ":flush"} {:args [], :type "Color", :name ":get-color"} {:args [], :type "ShapeRenderer.ShapeType", :text "Returns the current {@link ShapeType} used", :name ":get-current-type"} {:args [], :type "Matrix4", :name ":get-projection-matrix"} {:args [], :type "ImmediateModeRenderer", :name ":get-renderer"} {:args [], :type "Matrix4", :name ":get-transform-matrix"} {:args [], :text "Sets the transformation matrix to identity.", :name ":identity"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "x2"] ["float" "y2"] ["float" "z2"]], :text "Draws a line. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}.", :name ":line"} {:args [["Vector3" "v0"] ["Vector3" "v1"]], :text "Draws a line. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}. Lazy method that \"just\" calls the\n \"other\" method and unpacks the Vector3 for you", :name ":line"} {:args [["float" "x"] ["float" "y"] ["float" "x2"] ["float" "y2"]], :text "Draws a line in the x/y plane. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}.", :name ":line"} {:args [["Vector2" "v0"] ["Vector2" "v1"]], :text "Draws a line. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}. Lazy method that \"just\" calls the\n \"other\" method and unpacks the Vector2 for you", :name ":line"} {:args [["float" "x"] ["float" "y"] ["float" "x2"] ["float" "y2"] ["Color" "c1"] ["Color" "c2"]], :text "Draws a line in the x/y plane. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}. The line is drawn\n with 2 colors interpolated between start & end point.", :name ":line"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "x2"] ["float" "y2"] ["float" "z2"] ["Color" "c1"] ["Color" "c2"]], :text "Draws a line. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}. The line is drawn with 2 colors\n interpolated between start & end point.", :name ":line"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Draws a point. The {@link ShapeType} passed to begin has to be {@link ShapeType#Point}.", :name ":point"} {:args [["float[]" "vertices"]], :name ":polygon"} {:args [["float[]" "vertices"] ["int" "offset"] ["int" "count"]], :text "Draws a polygon in the x/y plane. The vertices must contain at least 3 points (6 floats x,y). The {@link ShapeType} passed\n to begin has to be {@link ShapeType#Line}.", :name ":polygon"} {:args [["float[]" "vertices"]], :name ":polyline"} {:args [["float[]" "vertices"] ["int" "offset"] ["int" "count"]], :text "Draws a polyline in the x/y plane. The vertices must contain at least 2 points (4 floats x,y). The {@link ShapeType} passed\n to begin has to be {@link ShapeType#Line}.", :name ":polyline"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The\n {@link ShapeType} passed to begin has to be {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":rect"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["Color" "col1"] ["Color" "col2"] ["Color" "col3"] ["Color" "col4"]], :text "Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The\n {@link ShapeType} passed to begin has to be {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":rect"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["float" "origin-x"] ["float" "origin-y"] ["float" "rotation"]], :text "Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The originX and\n originY specify the point about which to rotate the rectangle. The rotation is in degrees. The {@link ShapeType} passed to\n begin has to be {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":rect"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["float" "origin-x"] ["float" "origin-y"] ["float" "rotation"] ["Color" "col1"] ["Color" "col2"] ["Color" "col3"] ["Color" "col4"]], :text "Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The originX and\n originY specify the point about which to rotate the rectangle. The rotation is in degrees. The {@link ShapeType} passed to\n begin has to be {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":rect"} {:args [["Vector2" "p1"] ["Vector2" "p2"] ["float" "width"]], :name ":rect-line"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "width"]], :text "Draws a rectangle with one edge centered at x1, y1 and the opposite edge centered at x2, y2.", :name ":rect-line"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "angle"]], :text "Multiplies the current transformation matrix by a rotation matrix.", :name ":rotate"} {:args [["float" "scale-x"] ["float" "scale-y"] ["float" "scale-z"]], :text "Multiplies the current transformation matrix by a scale matrix.", :name ":scale"} {:args [["Color" "color"]], :text "Sets the {@link Color} to be used by shapes.", :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :text "Sets the {@link Color} to be used by shapes.", :name ":set-color"} {:args [["Matrix4" "matrix"]], :text "Sets the projection matrix to be used for rendering. Usually this will be set to {@link Camera#combined}.", :name ":set-projection-matrix"} {:args [["Matrix4" "matrix"]], :name ":set-transform-matrix"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Multiplies the current transformation matrix by a translation matrix.", :name ":translate"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"]], :text "Draws a triangle in x/y plane. The {@link ShapeType} passed to begin has to be {@link ShapeType#Filled} or\n {@link ShapeType#Line}.", :name ":triangle"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"] ["Color" "col1"] ["Color" "col2"] ["Color" "col3"]], :text "Draws a triangle in x/y plane with coloured corners. The {@link ShapeType} passed to begin has to be\n {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":triangle"} {:args [["float" "x"] ["float" "y"] ["float" "radius"]], :text "Draws two crossed lines.", :name ":x"} {:args [["Vector2" "p"] ["float" "radius"]], :name ":x"}]}]], :name "shape", :type :code, :raw "(defmacro shape\n  [type & options]\n  (when (seq (clojure.set/intersection #{:begin :end} (set options)))\n    (-> \"No need to call :begin or :end, because it's done for you.\"\n        Throwable.\n        throw))\n  `(let [entity# ~(if (keyword? type)\n                    `(assoc (shape*) :type (shape-type ~type))\n                    type)\n         ^ShapeRenderer object# (u/get-obj entity# :object)]\n     (assoc entity# :draw! (fn [] (u/calls! object# ~@options)))))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/glutils/ShapeRenderer.html'>ShapeRenderer</a>. You may pass in a type (see <code>shape-type</code>) or an existing <code>shape</code> entity that you want to modify.</p><p>A <code>shape</code> can draw multiple sub-shapes internally, allowing you to create more complicated shapes. If you use <code>assoc</code> to set the overall :x and :y of the <code>shape</code>, each sub-shape's x and y position will be relative to it.</p><pre>\n; create a green and red rectangle\n&#40;shape :filled\n       :set-color &#40;color :green&#41;\n       :rect 0 0 10 30\n       :set-color &#40;color :red&#41;\n       :rect 10 0 10 30&#41;\n; create an empty shape, then set it to a green rectangle\n&#40;shape &#40;shape :filled&#41;\n       :set-color &#40;color :green&#41;\n       :rect 0 0 10 30&#41;\n; create a green rectangle at 10,10 and rotate it 45 degrees\n&#40;assoc &#40;shape :filled\n              :set-color &#40;color :green&#41;\n              :rect 0 0 10 30&#41;\n       :x 10\n       :y 10\n       :angle 45&#41;\n</pre>"} {:raw* nil, :arglists [(shape! entity k & options)], :java [["shape!" {:text "Renders points, lines, rectangles, filled rectangles and boxes.</p>\n \n This class works with OpenGL ES 1.x and 2.0. In its base configuration a 2D orthographic projection with the origin in the\n lower left corner is used. Units are given in screen pixels.</p>\n \n To change the projection properties use the {@link #setProjectionMatrix(Matrix4)} method. Usually the {@link Camera#combined}\n matrix is set via this method. If the screen orientation or resolution changes, the projection matrix might have to be adapted\n as well.</p>\n \n Shapes are rendered in batches to increase performance. The standard use-pattern looks as follows:\n \n <pre>\n {@code\n camera.update();\n shapeRenderer.setProjectionMatrix(camera.combined);\n \n shapeRenderer.begin(ShapeType.Line);\n shapeRenderer.setColor(1, 1, 0, 1);\n shapeRenderer.line(x, y, x2, y2);\n shapeRenderer.rect(x, y, width, height);\n shapeRenderer.circle(x, y, radius);\n shapeRenderer.end();\n \n shapeRenderer.begin(ShapeType.Filled);\n shapeRenderer.setColor(0, 1, 0, 1);\n shapeRenderer.rect(x, y, width, height);\n shapeRenderer.circle(x, y, radius);\n shapeRenderer.end();\n }\n </pre>\n \n The class has a second matrix called the transformation matrix which is used to rotate, scale and translate shapes in a more\n flexible manner. This mechanism works much like matrix operations in OpenGL ES 1.x. The following example shows how to rotate a\n rectangle around its center using the z-axis as the rotation axis and placing it's center at (20, 12, 2):\n \n <pre>\n shapeRenderer.begin(ShapeType.Line);\n shapeRenderer.identity();\n shapeRenderer.translate(20, 12, 2);\n shapeRenderer.rotate(0, 0, 1, 90);\n shapeRenderer.rect(-width / 2, -height / 2, width, height);\n shapeRenderer.end();\n </pre>\n \n Matrix operations all use postmultiplication and work just like glTranslate, glScale and glRotate. The last transformation\n specified will be the first that is applied to a shape (rotate then translate in the above example).\n \n The projection and transformation matrices are a state of the ShapeRenderer, just like the color and will be applied to all\n shapes until they are changed.", :items [{:args [["float" "x"] ["float" "y"] ["float" "radius"] ["float" "start"] ["float" "angle"]], :text "Calls {@link #arc(float, float, float, float, float, int)} by estimating the number of segments needed for a smooth arc.", :name ":arc"} {:args [["float" "x"] ["float" "y"] ["float" "radius"] ["float" "start"] ["float" "angle"] ["int" "segments"]], :name ":arc"} {:args [["ShapeRenderer.ShapeType" "type"]], :text "Starts a new batch of shapes. All shapes within the batch have to have the type specified. E.g. if {@link ShapeType#Point}\n is specified, only call #point().\n \n The call to this method must be paired with a call to {@link #end()}.\n \n In case OpenGL ES 1.x is used, the projection and modelview matrix will be modified.", :name ":begin"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "width"] ["float" "height"] ["float" "depth"]], :text "Draws a cube. The x, y and z coordinate specify the bottom left front corner of the rectangle. The {@link ShapeType} passed\n to begin has to be {@link ShapeType#Line}.", :name ":box"} {:args [["float" "x"] ["float" "y"] ["float" "radius"]], :text "Calls {@link #circle(float, float, float, int)} by estimating the number of segments needed for a smooth circle.", :name ":circle"} {:args [["float" "x"] ["float" "y"] ["float" "radius"] ["int" "segments"]], :name ":circle"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radius"] ["float" "height"]], :text "Calls {@link #cone(float, float, float, float, float, int)} by estimating the number of segments needed for a smooth\n circular base.", :name ":cone"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radius"] ["float" "height"] ["int" "segments"]], :name ":cone"} {:args [["float" "x1"] ["float" "y1"] ["float" "cx1"] ["float" "cy1"] ["float" "cx2"] ["float" "cy2"] ["float" "x2"] ["float" "y2"] ["int" "segments"]], :name ":curve"} {:args [], :name ":dispose"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Calls {@link #ellipse(float, float, float, float, int)} by estimating the number of segments needed for a smooth ellipse.", :name ":ellipse"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["int" "segments"]], :name ":ellipse"} {:args [], :text "Finishes the batch of shapes and ensures they get rendered.", :name ":end"} {:args [], :name ":flush"} {:args [], :type "Color", :name ":get-color"} {:args [], :type "ShapeRenderer.ShapeType", :text "Returns the current {@link ShapeType} used", :name ":get-current-type"} {:args [], :type "Matrix4", :name ":get-projection-matrix"} {:args [], :type "ImmediateModeRenderer", :name ":get-renderer"} {:args [], :type "Matrix4", :name ":get-transform-matrix"} {:args [], :text "Sets the transformation matrix to identity.", :name ":identity"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "x2"] ["float" "y2"] ["float" "z2"]], :text "Draws a line. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}.", :name ":line"} {:args [["Vector3" "v0"] ["Vector3" "v1"]], :text "Draws a line. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}. Lazy method that \"just\" calls the\n \"other\" method and unpacks the Vector3 for you", :name ":line"} {:args [["float" "x"] ["float" "y"] ["float" "x2"] ["float" "y2"]], :text "Draws a line in the x/y plane. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}.", :name ":line"} {:args [["Vector2" "v0"] ["Vector2" "v1"]], :text "Draws a line. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}. Lazy method that \"just\" calls the\n \"other\" method and unpacks the Vector2 for you", :name ":line"} {:args [["float" "x"] ["float" "y"] ["float" "x2"] ["float" "y2"] ["Color" "c1"] ["Color" "c2"]], :text "Draws a line in the x/y plane. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}. The line is drawn\n with 2 colors interpolated between start & end point.", :name ":line"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "x2"] ["float" "y2"] ["float" "z2"] ["Color" "c1"] ["Color" "c2"]], :text "Draws a line. The {@link ShapeType} passed to begin has to be {@link ShapeType#Line}. The line is drawn with 2 colors\n interpolated between start & end point.", :name ":line"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Draws a point. The {@link ShapeType} passed to begin has to be {@link ShapeType#Point}.", :name ":point"} {:args [["float[]" "vertices"]], :name ":polygon"} {:args [["float[]" "vertices"] ["int" "offset"] ["int" "count"]], :text "Draws a polygon in the x/y plane. The vertices must contain at least 3 points (6 floats x,y). The {@link ShapeType} passed\n to begin has to be {@link ShapeType#Line}.", :name ":polygon"} {:args [["float[]" "vertices"]], :name ":polyline"} {:args [["float[]" "vertices"] ["int" "offset"] ["int" "count"]], :text "Draws a polyline in the x/y plane. The vertices must contain at least 2 points (4 floats x,y). The {@link ShapeType} passed\n to begin has to be {@link ShapeType#Line}.", :name ":polyline"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The\n {@link ShapeType} passed to begin has to be {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":rect"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["Color" "col1"] ["Color" "col2"] ["Color" "col3"] ["Color" "col4"]], :text "Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The\n {@link ShapeType} passed to begin has to be {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":rect"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["float" "origin-x"] ["float" "origin-y"] ["float" "rotation"]], :text "Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The originX and\n originY specify the point about which to rotate the rectangle. The rotation is in degrees. The {@link ShapeType} passed to\n begin has to be {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":rect"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["float" "origin-x"] ["float" "origin-y"] ["float" "rotation"] ["Color" "col1"] ["Color" "col2"] ["Color" "col3"] ["Color" "col4"]], :text "Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The originX and\n originY specify the point about which to rotate the rectangle. The rotation is in degrees. The {@link ShapeType} passed to\n begin has to be {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":rect"} {:args [["Vector2" "p1"] ["Vector2" "p2"] ["float" "width"]], :name ":rect-line"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "width"]], :text "Draws a rectangle with one edge centered at x1, y1 and the opposite edge centered at x2, y2.", :name ":rect-line"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "angle"]], :text "Multiplies the current transformation matrix by a rotation matrix.", :name ":rotate"} {:args [["float" "scale-x"] ["float" "scale-y"] ["float" "scale-z"]], :text "Multiplies the current transformation matrix by a scale matrix.", :name ":scale"} {:args [["Color" "color"]], :text "Sets the {@link Color} to be used by shapes.", :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :text "Sets the {@link Color} to be used by shapes.", :name ":set-color"} {:args [["Matrix4" "matrix"]], :text "Sets the projection matrix to be used for rendering. Usually this will be set to {@link Camera#combined}.", :name ":set-projection-matrix"} {:args [["Matrix4" "matrix"]], :name ":set-transform-matrix"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :text "Multiplies the current transformation matrix by a translation matrix.", :name ":translate"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"]], :text "Draws a triangle in x/y plane. The {@link ShapeType} passed to begin has to be {@link ShapeType#Filled} or\n {@link ShapeType#Line}.", :name ":triangle"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"] ["Color" "col1"] ["Color" "col2"] ["Color" "col3"]], :text "Draws a triangle in x/y plane with coloured corners. The {@link ShapeType} passed to begin has to be\n {@link ShapeType#Filled} or {@link ShapeType#Line}.", :name ":triangle"} {:args [["float" "x"] ["float" "y"] ["float" "radius"]], :text "Draws two crossed lines.", :name ":x"} {:args [["Vector2" "p"] ["float" "radius"]], :name ":x"}]}]], :name "shape!", :type :code, :raw "(defmacro shape!\n  [entity k & options]\n  `(let [^ShapeRenderer object# (u/get-obj ~entity :object)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>shape</code>.</p>"} {:raw* nil, :arglists [(shape? entity)], :java [], :name "shape?", :type :code, :raw "(defn shape?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) ShapeRenderer))", :docstring "<p>Returns true if <code>entity</code> is a <code>shape</code>.</p>"} {:raw* "(defn tiled-map*\n  ([]\n    (TiledMap.))\n  ([s]\n    (if (string? s)\n      (or (u/load-asset s TiledMap)\n          (.load (TmxMapLoader.) s))\n      s)))", :arglists [(tiled-map s & options)], :java [["tiled-map" {:text "", :items [{:args [], :text "Disposes all resources like {@link Texture} instances that the map may own.", :name ":dispose"} {:args [], :name ":dispose"} {:args [], :type "MapLayers", :name ":get-layers"} {:args [], :type "MapProperties", :name ":get-properties"} {:args [], :type "TiledMapTileSets", :name ":get-tile-sets"} {:args [["com.badlogic.gdx.utils.Array" "resources"]], :text "Used by loaders to set resources when loading the map directly, without {@link AssetManager}. To be disposed in\n {@link #dispose()}.", :name ":set-owned-resources"}]}]], :name "tiled-map", :type :code, :raw "(defmacro tiled-map\n  [s & options]\n  `(u/calls! ^TiledMap (tiled-map* ~s) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/tiled/TiledMap.html'>TiledMap</a>. Normally, you don't need to use this directly.</p>"} {:raw* nil, :arglists [(tiled-map! screen k & options)], :java [["tiled-map!" {:text "", :items [{:args [], :text "Disposes all resources like {@link Texture} instances that the map may own.", :name ":dispose"} {:args [], :name ":dispose"} {:args [], :type "MapLayers", :name ":get-layers"} {:args [], :type "MapProperties", :name ":get-properties"} {:args [], :type "TiledMapTileSets", :name ":get-tile-sets"} {:args [["com.badlogic.gdx.utils.Array" "resources"]], :text "Used by loaders to set resources when loading the map directly, without {@link AssetManager}. To be disposed in\n {@link #dispose()}.", :name ":set-owned-resources"}]}]], :name "tiled-map!", :type :code, :raw "(defmacro tiled-map!\n  [screen k & options]\n  `(let [^BatchTiledMapRenderer renderer# (u/get-obj ~screen :renderer)]\n     (u/call! ^TiledMap (.getMap renderer#) ~k ~@options)))", :docstring "<p>Calls a single method on a <code>tiled-map</code>.</p><pre>\n&#40;tiled-map! screen :get-layers&#41;\n</pre>"} {:raw* "(defn tiled-map-layer*\n  ([width height tile-width tile-height]\n    (TiledMapTileLayer. width height tile-width tile-height))\n  ([screen layer]\n    (if (isa? (type layer) MapLayer)\n        layer\n        (->> ^BatchTiledMapRenderer (u/get-obj screen :renderer)\n             .getMap\n             .getLayers\n             (drop-while #(not= layer (.getName ^MapLayer %)))\n             first))))", :arglists [(tiled-map-layer screen layer & options)], :java [["tiled-map-layer" {:text "", :items [{:args [["int" "x"] ["int" "y"]], :type "TiledMapTileLayer.Cell", :name ":get-cell"} {:args [], :type "int", :name ":get-height"} {:args [], :type "String", :name ":get-name"} {:args [], :type "MapObjects", :name ":get-objects"} {:args [], :type "float", :name ":get-opacity"} {:args [], :type "MapProperties", :name ":get-properties"} {:args [], :type "float", :name ":get-tile-height"} {:args [], :type "float", :name ":get-tile-width"} {:args [], :type "int", :name ":get-width"} {:args [], :type "boolean", :name ":is-visible"} {:args [["int" "x"] ["int" "y"] ["TiledMapTileLayer.Cell" "cell"]], :text "Sets the {@link Cell} at the given coordinates.", :name ":set-cell"} {:args [["String" "name"]], :name ":set-name"} {:args [["float" "opacity"]], :name ":set-opacity"} {:args [["boolean" "visible"]], :name ":set-visible"}]}]], :name "tiled-map-layer", :type :code, :raw "(defmacro tiled-map-layer\n  [screen layer & options]\n  `(let [^TiledMapTileLayer object# (tiled-map-layer* ~screen ~layer)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/tiled/TiledMapTileLayer.html'>TiledMapTileLayer</a> from the tiled map in <code>screen</code> that matches <code>layer</code>.</p><pre>\n&#40;tiled-map-layer screen &quot;water&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(tiled-map-layer! object k & options)], :java [["tiled-map-layer!" {:text "", :items [{:args [["int" "x"] ["int" "y"]], :type "TiledMapTileLayer.Cell", :name ":get-cell"} {:args [], :type "int", :name ":get-height"} {:args [], :type "String", :name ":get-name"} {:args [], :type "MapObjects", :name ":get-objects"} {:args [], :type "float", :name ":get-opacity"} {:args [], :type "MapProperties", :name ":get-properties"} {:args [], :type "float", :name ":get-tile-height"} {:args [], :type "float", :name ":get-tile-width"} {:args [], :type "int", :name ":get-width"} {:args [], :type "boolean", :name ":is-visible"} {:args [["int" "x"] ["int" "y"] ["TiledMapTileLayer.Cell" "cell"]], :text "Sets the {@link Cell} at the given coordinates.", :name ":set-cell"} {:args [["String" "name"]], :name ":set-name"} {:args [["float" "opacity"]], :name ":set-opacity"} {:args [["boolean" "visible"]], :name ":set-visible"}]}]], :name "tiled-map-layer!", :type :code, :raw "(defmacro tiled-map-layer!\n  [object k & options]\n  `(u/call! ^TiledMapTileLayer (cast TiledMapTileLayer ~object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>tiled-map-layer</code>.</p><pre>\n&#40;tiled-map-layer! &#40;tiled-map-layer screen &quot;water&quot;&#41;\n                  :set-cell 0 0 nil&#41;\n</pre>"} {:raw* "(defn tiled-map-cell*\n  ([]\n    (TiledMapTileLayer$Cell.))\n  ([^TiledMapTileLayer layer x y]\n    (.getCell layer x y)))", :arglists [(tiled-map-cell layer x y & options)], :java [["tiled-map-cell" {:text "", :items [{:args [], :type "boolean", :name ":get-flip-horizontally"} {:args [], :type "boolean", :name ":get-flip-vertically"} {:args [], :type "int", :name ":get-rotation"} {:args [], :type "TiledMapTile", :name ":get-tile"} {:args [["boolean" "flip-horizontally"]], :text "Sets whether to flip the tile horizontally.", :name ":set-flip-horizontally"} {:args [["boolean" "flip-vertically"]], :text "Sets whether to flip the tile vertically.", :name ":set-flip-vertically"} {:args [["int" "rotation"]], :text "Sets the rotation of this cell, in degrees.", :name ":set-rotation"} {:args [["TiledMapTile" "tile"]], :text "Sets the tile to be used for this cell.", :name ":set-tile"}]}]], :name "tiled-map-cell", :type :code, :raw "(defmacro tiled-map-cell\n  [layer x y & options]\n  `(let [^TiledMapTileLayer$Cell object# (tiled-map-cell* ~layer ~x ~y)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/tiled/TiledMapTileLayer.Cell.html'>TiledMapTileLayer.Cell</a> from the <code>layer</code> at position <code>x</code> and <code>y</code>.</p><pre>\n&#40;tiled-map-cell &#40;tiled-map-layer screen &quot;water&quot;&#41; 0 0&#41;\n</pre>"} {:raw* nil, :arglists [(tiled-map-cell! object k & options)], :java [["tiled-map-cell!" {:text "", :items [{:args [], :type "boolean", :name ":get-flip-horizontally"} {:args [], :type "boolean", :name ":get-flip-vertically"} {:args [], :type "int", :name ":get-rotation"} {:args [], :type "TiledMapTile", :name ":get-tile"} {:args [["boolean" "flip-horizontally"]], :text "Sets whether to flip the tile horizontally.", :name ":set-flip-horizontally"} {:args [["boolean" "flip-vertically"]], :text "Sets whether to flip the tile vertically.", :name ":set-flip-vertically"} {:args [["int" "rotation"]], :text "Sets the rotation of this cell, in degrees.", :name ":set-rotation"} {:args [["TiledMapTile" "tile"]], :text "Sets the tile to be used for this cell.", :name ":set-tile"}]}]], :name "tiled-map-cell!", :type :code, :raw "(defmacro tiled-map-cell!\n  [object k & options]\n  `(u/call! ^TiledMapTileLayer$Cell ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>tiled-map-cell</code>.</p><pre>\n&#40;-&gt; &#40;tiled-map-layer screen &quot;water&quot;&#41;\n    &#40;tiled-map-cell 0 0&#41;\n    &#40;tiled-map-cell! :set-rotation 90&#41;&#41;\n</pre>"} {:raw* "(defn map-layers*\n  ([]\n    (MapLayers.))\n  ([screen]\n    (let [^BatchTiledMapRenderer renderer (u/get-obj screen :renderer)]\n      (-> renderer .getMap .getLayers))))", :arglists [(map-layers screen & options)], :java [["map-layers" {:text "Ordered list of {@link MapLayer} instances owned by a {@link Map}", :items [{:args [["MapLayer" "layer"]], :name ":add"} {:args [["int" "index"]], :type "MapLayer", :name ":get"} {:args [["String" "name"]], :type "MapLayer", :name ":get"} {:args [["java.lang.Class" "type"]], :type "Array", :name ":get-by-type"} {:args [["java.lang.Class" "type"] ["com.badlogic.gdx.utils.Array" "fill"]], :type "Array", :name ":get-by-type"} {:args [], :type "int", :name ":get-count"} {:args [], :type "Iterator", :name ":iterator"} {:args [["int" "index"]], :name ":remove"} {:args [["MapLayer" "layer"]], :name ":remove"}]}]], :name "map-layers", :type :code, :raw "(defmacro map-layers\n  [screen & options]\n  `(let [^MapLayers object# (map-layers* ~screen)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/MapLayers.html'>MapLayers</a> in the tiled map in <code>screen</code>.</p><pre>\n&#40;map-layers screen&#41;\n</pre>"} {:raw* nil, :arglists [(map-layers! object k & options)], :java [["map-layers!" {:text "Ordered list of {@link MapLayer} instances owned by a {@link Map}", :items [{:args [["MapLayer" "layer"]], :name ":add"} {:args [["int" "index"]], :type "MapLayer", :name ":get"} {:args [["String" "name"]], :type "MapLayer", :name ":get"} {:args [["java.lang.Class" "type"]], :type "Array", :name ":get-by-type"} {:args [["java.lang.Class" "type"] ["com.badlogic.gdx.utils.Array" "fill"]], :type "Array", :name ":get-by-type"} {:args [], :type "int", :name ":get-count"} {:args [], :type "Iterator", :name ":iterator"} {:args [["int" "index"]], :name ":remove"} {:args [["MapLayer" "layer"]], :name ":remove"}]}]], :name "map-layers!", :type :code, :raw "(defmacro map-layers!\n  [object k & options]\n  `(u/call! ^MapLayers ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>map-layers</code>.</p><pre>\n&#40;map-layers! object :remove &#40;map-layer screen &quot;objects&quot;&#41;&#41;\n</pre>"} {:raw* "(defn map-layer*\n  ([]\n    (MapLayer.))\n  ([screen layer]\n    (tiled-map-layer* screen layer)))", :arglists [(map-layer screen layer & options)], :java [["map-layer" {:text "Map layer containing a set of objects and properties", :items [{:args [], :type "String", :name ":get-name"} {:args [], :type "MapObjects", :name ":get-objects"} {:args [], :type "float", :name ":get-opacity"} {:args [], :type "MapProperties", :name ":get-properties"} {:args [], :type "boolean", :name ":is-visible"} {:args [["String" "name"]], :name ":set-name"} {:args [["float" "opacity"]], :name ":set-opacity"} {:args [["boolean" "visible"]], :name ":set-visible"}]}]], :name "map-layer", :type :code, :raw "(defmacro map-layer\n  [screen layer & options]\n  `(let [^MapLayer object# (map-layer* ~screen ~layer)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/MapLayer.html'>MapLayer</a> from the tiled map in <code>screen</code> that matches <code>layer</code>. This is necessary for non-tile layers, like object and image layers.</p><pre>\n&#40;map-layer screen &quot;objects&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(map-layer! object k & options)], :java [["map-layer!" {:text "Map layer containing a set of objects and properties", :items [{:args [], :type "String", :name ":get-name"} {:args [], :type "MapObjects", :name ":get-objects"} {:args [], :type "float", :name ":get-opacity"} {:args [], :type "MapProperties", :name ":get-properties"} {:args [], :type "boolean", :name ":is-visible"} {:args [["String" "name"]], :name ":set-name"} {:args [["float" "opacity"]], :name ":set-opacity"} {:args [["boolean" "visible"]], :name ":set-visible"}]}]], :name "map-layer!", :type :code, :raw "(defmacro map-layer!\n  [object k & options]\n  `(u/call! ^MapLayer ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>map-layer</code>.</p><pre>\n&#40;map-layer! &#40;map-layer screen &quot;objects&quot;&#41;\n            :set-visible false&#41;\n</pre>"} {:raw* nil, :arglists [(map-layer-names screen)], :java [], :name "map-layer-names", :type :code, :raw "(defn map-layer-names\n  [screen]\n  (doall\n    (for [^MapLayer layer (map-layers screen)]\n      (.getName layer))))", :docstring "<p>Returns a list with strings cooresponding to the name of each layer in the tiled map in <code>screen</code>.</p>"} {:raw* "(defn map-objects*\n  ([]\n    (MapObjects.))\n  ([^MapLayer layer]\n    (.getObjects layer)))", :arglists [(map-objects layer & options)], :java [["map-objects" {:text "", :items [{:args [["MapObject" "object"]], :name ":add"} {:args [["int" "index"]], :type "MapObject", :name ":get"} {:args [["String" "name"]], :type "MapObject", :name ":get"} {:args [["java.lang.Class" "type"]], :type "Array", :name ":get-by-type"} {:args [["java.lang.Class" "type"] ["com.badlogic.gdx.utils.Array" "fill"]], :type "Array", :name ":get-by-type"} {:args [], :type "int", :name ":get-count"} {:args [], :type "Iterator", :name ":iterator"} {:args [["int" "index"]], :name ":remove"} {:args [["MapObject" "object"]], :name ":remove"}]}]], :name "map-objects", :type :code, :raw "(defmacro map-objects\n  [^MapLayer layer & options]\n  `(let [^MapObjects object# (map-objects* ~layer)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/MapObjects.html'>MapObjects</a> in the <code>layer</code>.</p><pre>\n&#40;map-objects layer&#41;\n</pre>"} {:raw* nil, :arglists [(map-objects! object k & options)], :java [["map-objects!" {:text "", :items [{:args [["MapObject" "object"]], :name ":add"} {:args [["int" "index"]], :type "MapObject", :name ":get"} {:args [["String" "name"]], :type "MapObject", :name ":get"} {:args [["java.lang.Class" "type"]], :type "Array", :name ":get-by-type"} {:args [["java.lang.Class" "type"] ["com.badlogic.gdx.utils.Array" "fill"]], :type "Array", :name ":get-by-type"} {:args [], :type "int", :name ":get-count"} {:args [], :type "Iterator", :name ":iterator"} {:args [["int" "index"]], :name ":remove"} {:args [["MapObject" "object"]], :name ":remove"}]}]], :name "map-objects!", :type :code, :raw "(defmacro map-objects!\n  [object k & options]\n  `(u/call! ^MapObjects ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>map-objects</code>.</p><pre>\n&#40;map-objects! &#40;map-objects layer&#41; :remove &#40;map-object layer 0&#41;&#41;\n</pre>"} {:raw* "(defn map-object*\n  []\n  (MapObject.))", :arglists [(map-object type & options)], :java [["map-object" {:text "", :items [{:args [], :type "Color", :name ":polyline :get-color"} {:args [], :type "String", :name ":polyline :get-name"} {:args [], :type "float", :name ":polyline :get-opacity"} {:args [], :type "Polyline", :name ":polyline :get-polyline"} {:args [], :type "MapProperties", :name ":polyline :get-properties"} {:args [], :type "boolean", :name ":polyline :is-visible"} {:args [["Color" "color"]], :name ":polyline :set-color"} {:args [["String" "name"]], :name ":polyline :set-name"} {:args [["float" "opacity"]], :name ":polyline :set-opacity"} {:args [["Polyline" "polyline"]], :name ":polyline :set-polyline"} {:args [["boolean" "visible"]], :name ":polyline :set-visible"}]}] ["map-object" {:text "", :items [{:args [], :type "Color", :name ":texture :get-color"} {:args [], :type "String", :name ":texture :get-name"} {:args [], :type "float", :name ":texture :get-opacity"} {:args [], :type "float", :name ":texture :get-origin-x"} {:args [], :type "float", :name ":texture :get-origin-y"} {:args [], :type "MapProperties", :name ":texture :get-properties"} {:args [], :type "float", :name ":texture :get-rotation"} {:args [], :type "float", :name ":texture :get-scale-x"} {:args [], :type "float", :name ":texture :get-scale-y"} {:args [], :type "TextureRegion", :name ":texture :get-texture-region"} {:args [], :type "float", :name ":texture :get-x"} {:args [], :type "float", :name ":texture :get-y"} {:args [], :type "boolean", :name ":texture :is-visible"} {:args [["Color" "color"]], :name ":texture :set-color"} {:args [["String" "name"]], :name ":texture :set-name"} {:args [["float" "opacity"]], :name ":texture :set-opacity"} {:args [["float" "x"]], :name ":texture :set-origin-x"} {:args [["float" "y"]], :name ":texture :set-origin-y"} {:args [["float" "rotation"]], :name ":texture :set-rotation"} {:args [["float" "x"]], :name ":texture :set-scale-x"} {:args [["float" "y"]], :name ":texture :set-scale-y"} {:args [["TextureRegion" "region"]], :name ":texture :set-texture-region"} {:args [["boolean" "visible"]], :name ":texture :set-visible"} {:args [["float" "x"]], :name ":texture :set-x"} {:args [["float" "y"]], :name ":texture :set-y"}]}] ["map-object" {:text "", :items [{:args [], :type "Color", :name ":polygon :get-color"} {:args [], :type "String", :name ":polygon :get-name"} {:args [], :type "float", :name ":polygon :get-opacity"} {:args [], :type "Polygon", :name ":polygon :get-polygon"} {:args [], :type "MapProperties", :name ":polygon :get-properties"} {:args [], :type "boolean", :name ":polygon :is-visible"} {:args [["Color" "color"]], :name ":polygon :set-color"} {:args [["String" "name"]], :name ":polygon :set-name"} {:args [["float" "opacity"]], :name ":polygon :set-opacity"} {:args [["Polygon" "polygon"]], :name ":polygon :set-polygon"} {:args [["boolean" "visible"]], :name ":polygon :set-visible"}]}] ["map-object" {:text "", :items [{:args [], :type "Circle", :name ":circle :get-circle"} {:args [], :type "Color", :name ":circle :get-color"} {:args [], :type "String", :name ":circle :get-name"} {:args [], :type "float", :name ":circle :get-opacity"} {:args [], :type "MapProperties", :name ":circle :get-properties"} {:args [], :type "boolean", :name ":circle :is-visible"} {:args [["Color" "color"]], :name ":circle :set-color"} {:args [["String" "name"]], :name ":circle :set-name"} {:args [["float" "opacity"]], :name ":circle :set-opacity"} {:args [["boolean" "visible"]], :name ":circle :set-visible"}]}] ["map-object" {:text "", :items [{:args [], :type "Color", :name ":rectangle :get-color"} {:args [], :type "String", :name ":rectangle :get-name"} {:args [], :type "float", :name ":rectangle :get-opacity"} {:args [], :type "MapProperties", :name ":rectangle :get-properties"} {:args [], :type "Rectangle", :name ":rectangle :get-rectangle"} {:args [], :type "boolean", :name ":rectangle :is-visible"} {:args [["Color" "color"]], :name ":rectangle :set-color"} {:args [["String" "name"]], :name ":rectangle :set-name"} {:args [["float" "opacity"]], :name ":rectangle :set-opacity"} {:args [["boolean" "visible"]], :name ":rectangle :set-visible"}]}] ["map-object" {:text "", :items [{:args [], :type "Color", :name ":ellipse :get-color"} {:args [], :type "Ellipse", :name ":ellipse :get-ellipse"} {:args [], :type "String", :name ":ellipse :get-name"} {:args [], :type "float", :name ":ellipse :get-opacity"} {:args [], :type "MapProperties", :name ":ellipse :get-properties"} {:args [], :type "boolean", :name ":ellipse :is-visible"} {:args [["Color" "color"]], :name ":ellipse :set-color"} {:args [["String" "name"]], :name ":ellipse :set-name"} {:args [["float" "opacity"]], :name ":ellipse :set-opacity"} {:args [["boolean" "visible"]], :name ":ellipse :set-visible"}]}]], :name "map-object", :type :code, :raw "(defmacro map-object\n  [type & options]\n  `(let [^MapObject object# (~(map-object-init type))]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a subclass of <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/MapObject.html'>MapObject</a>.</p><pre>\n&#40;map-object :circle&#41;\n</pre>"} {:raw* nil, :arglists [(map-object! object k & options)], :java [["map-object!" {:text "Generic Map entity with basic attributes like name, opacity, color", :items [{:args [], :type "Color", :name ":get-color"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-opacity"} {:args [], :type "MapProperties", :name ":get-properties"} {:args [], :type "boolean", :name ":is-visible"} {:args [["Color" "color"]], :name ":set-color"} {:args [["String" "name"]], :name ":set-name"} {:args [["float" "opacity"]], :name ":set-opacity"} {:args [["boolean" "visible"]], :name ":set-visible"}]}]], :name "map-object!", :type :code, :raw "(defmacro map-object!\n  [object k & options]\n  `(u/call! ^MapObject ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>map-object</code>.</p><pre>\n&#40;map-object! &#40;map-object :rectangle&#41; :get-rectangle&#41;\n</pre>"} {:raw* nil, :arglists [(screen->input screen entity) (screen->input screen x y) (screen->input screen x y z)], :java [], :name "screen->input", :type :code, :raw "(defn screen->input\n  ([screen {:keys [x y z] :or {x 0 y 0 z 0} :as entity}]\n    (try\n      (let [^Camera camera (u/get-obj screen :camera)\n            coords (m/vector-3 x y z)]\n        (.project camera coords)\n        (assoc entity\n               :x (. coords x)\n               :y (. coords y)\n               :z (. coords z)))\n      ; if there's no camera, just flip the y axis\n      (catch Exception _\n        (assoc entity :y (- (game :height) y)))))\n  ([screen x y]\n    (screen->input screen {:x x :y y}))\n  ([screen x y z]\n    (screen->input screen {:x x :y y :z z})))", :docstring "<p>Returns a map with the provided x,y,z values converted from screen to input coordinates.</p><pre>\n&#40;screen-&gt;input screen {:x 10 :y 10 :z 0}&#41;\n&#40;screen-&gt;input screen 10 10&#41;\n&#40;screen-&gt;input screen 10 10 0&#41;\n</pre>"} {:raw* nil, :arglists [(input->screen screen entity) (input->screen screen x y) (input->screen screen x y z)], :java [], :name "input->screen", :type :code, :raw "(defn input->screen\n  ([screen {:keys [x y z] :or {x 0 y 0 z 0} :as entity}]\n    (try\n      (let [^Camera camera (u/get-obj screen :camera)\n            coords (m/vector-3 x y z)]\n        (.unproject camera coords)\n        (assoc entity\n               :x (. coords x)\n               :y (. coords y)\n               :z (. coords z)))\n      ; if there's no camera, just flip the y axis\n      (catch Exception _\n        (assoc entity :y (- (game :height) y)))))\n  ([screen x y]\n    (input->screen screen {:x x :y y}))\n  ([screen x y z]\n    (input->screen screen {:x x :y y :z z})))", :docstring "<p>Returns a map with the provided x,y,z values converted from input to screen coordinates.</p><pre>\n&#40;input-&gt;screen screen {:x 10 :y 10 :z 0}&#41;\n&#40;input-&gt;screen screen 10 10&#41;\n&#40;input-&gt;screen screen 10 10 0&#41;\n</pre>"} {:raw* nil, :arglists [(screen->isometric screen entity) (screen->isometric screen x y)], :java [], :name "screen->isometric", :type :code, :raw "(defn screen->isometric\n  ([screen {:keys [x y] :or {x 0 y 0} :as entity}]\n    (let [{:keys [unit-scale tile-width tile-height]} (tiled-map-prop screen)\n          half-tile-width (/ (* tile-width unit-scale) 2)\n          half-tile-height (/ (* tile-height unit-scale) 2)]\n      (assoc entity\n             :x (/ (- (/ x half-tile-width)\n                      (/ y half-tile-height))\n                   2)\n             :y (/ (+ (/ y half-tile-height)\n                      (/ x half-tile-width))\n                   2))))\n  ([screen x y]\n    (screen->isometric screen {:x x :y y})))", :docstring "<p>Returns a map with the provided x,y values converted from screen to isometric map coordinates.</p><pre>\n&#40;screen-&gt;isometric screen {:x 64 :y 32}&#41;\n&#40;screen-&gt;isometric screen 64 32&#41;\n</pre>"} {:raw* nil, :arglists [(isometric->screen screen entity) (isometric->screen screen x y)], :java [], :name "isometric->screen", :type :code, :raw "(defn isometric->screen\n  ([screen {:keys [x y] :as entity}]\n    (let [{:keys [unit-scale tile-width tile-height]} (tiled-map-prop screen)\n          half-tile-width (/ (* tile-width unit-scale) 2)\n          half-tile-height (/ (* tile-height unit-scale) 2)]\n      (assoc entity\n             :x (+ (* x half-tile-width)\n                   (* y half-tile-width))\n             :y (+ (* -1 x half-tile-height)\n                   (* y half-tile-height)))))\n  ([screen x y]\n    (isometric->screen screen {:x x :y y})))", :docstring "<p>Returns a map with the provided x,y values converted from isometric map to screen coordinates.</p><pre>\n&#40;isometric-&gt;screen screen {:x 2 :y 1}&#41;\n&#40;isometric-&gt;screen screen 2 1&#41;\n</pre>"} {:raw* "(defn orthogonal-tiled-map*\n  [path unit]\n  (OrthogonalTiledMapRenderer. ^TiledMap (tiled-map* path) ^double unit))", :arglists [(orthogonal-tiled-map path unit & options)], :java [["orthogonal-tiled-map" {:text "", :items [{:args [], :name ":dispose"} {:args [], :type "TiledMap", :name ":get-map"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "float", :name ":get-unit-scale"} {:args [], :type "Rectangle", :name ":get-view-bounds"} {:args [], :name ":render"} {:args [["int[]" "layers"]], :name ":render"} {:args [["MapObject" "object"]], :name ":render-object"} {:args [["TiledMapTileLayer" "layer"]], :name ":render-tile-layer"} {:args [["TiledMap" "map"]], :name ":set-map"} {:args [["OrthographicCamera" "camera"]], :name ":set-view"} {:args [["Matrix4" "projection"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":set-view"}]}]], :name "orthogonal-tiled-map", :type :code, :raw "(defmacro orthogonal-tiled-map\n  [path unit & options]\n  `(u/calls! ^OrthogonalTiledMapRenderer (orthogonal-tiled-map* ~path ~unit)\n             ~@options))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.html'>OrthogonalTiledMapRenderer</a> with the tiled map file at <code>path</code> and <code>unit</code> scale.</p><pre>\n&#40;orthogonal-tiled-map &quot;level1.tmx&quot; &#40;/ 1 8&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(orthogonal-tiled-map! screen k & options)], :java [["orthogonal-tiled-map!" {:text "", :items [{:args [], :name ":dispose"} {:args [], :type "TiledMap", :name ":get-map"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "float", :name ":get-unit-scale"} {:args [], :type "Rectangle", :name ":get-view-bounds"} {:args [], :name ":render"} {:args [["int[]" "layers"]], :name ":render"} {:args [["MapObject" "object"]], :name ":render-object"} {:args [["TiledMapTileLayer" "layer"]], :name ":render-tile-layer"} {:args [["TiledMap" "map"]], :name ":set-map"} {:args [["OrthographicCamera" "camera"]], :name ":set-view"} {:args [["Matrix4" "projection"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":set-view"}]}]], :name "orthogonal-tiled-map!", :type :code, :raw "(defmacro orthogonal-tiled-map!\n  [screen k & options]\n  `(let [^OrthogonalTiledMapRenderer object# (u/get-obj ~screen :renderer)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on an <code>orthogonal-tiled-map</code>.</p>"} {:raw* "(defn isometric-tiled-map*\n  [path unit]\n  (IsometricTiledMapRenderer. ^TiledMap (tiled-map* path) ^double unit))", :arglists [(isometric-tiled-map path unit & options)], :java [["isometric-tiled-map" {:text "", :items [{:args [], :name ":dispose"} {:args [], :type "TiledMap", :name ":get-map"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "float", :name ":get-unit-scale"} {:args [], :type "Rectangle", :name ":get-view-bounds"} {:args [], :name ":render"} {:args [["int[]" "layers"]], :name ":render"} {:args [["MapObject" "object"]], :name ":render-object"} {:args [["TiledMapTileLayer" "layer"]], :name ":render-tile-layer"} {:args [["TiledMap" "map"]], :name ":set-map"} {:args [["OrthographicCamera" "camera"]], :name ":set-view"} {:args [["Matrix4" "projection"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":set-view"}]}]], :name "isometric-tiled-map", :type :code, :raw "(defmacro isometric-tiled-map\n  [path unit & options]\n  `(u/calls! ^IsometricTiledMapRenderer (isometric-tiled-map* ~path ~unit)\n             ~@options))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.html'>IsometricTiledMapRenderer</a> with the tiled map file at <code>path</code> and <code>unit</code> scale.</p><pre>\n&#40;isometric-tiled-map &quot;level1.tmx&quot; &#40;/ 1 8&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(isometric-tiled-map! screen k & options)], :java [["isometric-tiled-map!" {:text "", :items [{:args [], :name ":dispose"} {:args [], :type "TiledMap", :name ":get-map"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "float", :name ":get-unit-scale"} {:args [], :type "Rectangle", :name ":get-view-bounds"} {:args [], :name ":render"} {:args [["int[]" "layers"]], :name ":render"} {:args [["MapObject" "object"]], :name ":render-object"} {:args [["TiledMapTileLayer" "layer"]], :name ":render-tile-layer"} {:args [["TiledMap" "map"]], :name ":set-map"} {:args [["OrthographicCamera" "camera"]], :name ":set-view"} {:args [["Matrix4" "projection"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":set-view"}]}]], :name "isometric-tiled-map!", :type :code, :raw "(defmacro isometric-tiled-map!\n  [screen k & options]\n  `(let [^IsometricTiledMapRenderer object# (u/get-obj ~screen :renderer)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on an <code>isometric-tiled-map</code>.</p>"} {:raw* "(defn isometric-staggered-tiled-map*\n  [path unit]\n  (IsometricStaggeredTiledMapRenderer. ^TiledMap (tiled-map* path)\n                                       ^double unit))", :arglists [(isometric-staggered-tiled-map path unit & options)], :java [["isometric-staggered-tiled-map" {:text "", :items [{:args [], :name ":dispose"} {:args [], :type "TiledMap", :name ":get-map"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "float", :name ":get-unit-scale"} {:args [], :type "Rectangle", :name ":get-view-bounds"} {:args [], :name ":render"} {:args [["int[]" "layers"]], :name ":render"} {:args [["MapObject" "object"]], :name ":render-object"} {:args [["TiledMapTileLayer" "layer"]], :name ":render-tile-layer"} {:args [["TiledMap" "map"]], :name ":set-map"} {:args [["OrthographicCamera" "camera"]], :name ":set-view"} {:args [["Matrix4" "projection"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":set-view"}]}]], :name "isometric-staggered-tiled-map", :type :code, :raw "(defmacro isometric-staggered-tiled-map\n  [path unit & options]\n  `(u/calls! ^IsometricStaggeredTiledMapRenderer\n             (isometric-staggered-tiled-map* ~path ~unit)\n             ~@options))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.html'>IsometricStaggeredTiledMapRenderer</a> with the tiled map file at <code>path</code> and <code>unit</code> scale.</p><pre>\n&#40;isometric-staggered-tiled-map &quot;level1.tmx&quot; &#40;/ 1 8&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(isometric-staggered-tiled-map! screen k & options)], :java [["isometric-staggered-tiled-map!" {:text "", :items [{:args [], :name ":dispose"} {:args [], :type "TiledMap", :name ":get-map"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "float", :name ":get-unit-scale"} {:args [], :type "Rectangle", :name ":get-view-bounds"} {:args [], :name ":render"} {:args [["int[]" "layers"]], :name ":render"} {:args [["MapObject" "object"]], :name ":render-object"} {:args [["TiledMapTileLayer" "layer"]], :name ":render-tile-layer"} {:args [["TiledMap" "map"]], :name ":set-map"} {:args [["OrthographicCamera" "camera"]], :name ":set-view"} {:args [["Matrix4" "projection"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":set-view"}]}]], :name "isometric-staggered-tiled-map!", :type :code, :raw "(defmacro isometric-staggered-tiled-map!\n  [screen k & options]\n  `(let [^IsometricStaggeredTiledMapRenderer object#\n         (u/get-obj ~screen :renderer)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on an <code>isometric-staggered-tiled-map</code>.</p>"} {:raw* "(defn hexagonal-tiled-map*\n  [path unit]\n  (HexagonalTiledMapRenderer. ^TiledMap (tiled-map* path) ^double unit))", :arglists [(hexagonal-tiled-map path unit & options)], :java [["hexagonal-tiled-map" {:text "", :items [{:args [], :name ":dispose"} {:args [], :type "TiledMap", :name ":get-map"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "float", :name ":get-unit-scale"} {:args [], :type "Rectangle", :name ":get-view-bounds"} {:args [], :name ":render"} {:args [["int[]" "layers"]], :name ":render"} {:args [["MapObject" "object"]], :name ":render-object"} {:args [["TiledMapTileLayer" "layer"]], :name ":render-tile-layer"} {:args [["TiledMap" "map"]], :name ":set-map"} {:args [["OrthographicCamera" "camera"]], :name ":set-view"} {:args [["Matrix4" "projection"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":set-view"}]}]], :name "hexagonal-tiled-map", :type :code, :raw "(defmacro hexagonal-tiled-map\n  [path unit & options]\n  `(u/calls! ^HexagonalTiledMapRenderer (hexagonal-tiled-map* ~path ~unit)\n             ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.html'>HexagonalTiledMapRenderer</a> with the tiled map file at <code>path</code> and <code>unit</code> scale.</p><pre>\n&#40;hexagonal-tiled-map &quot;level1.tmx&quot; &#40;/ 1 8&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(hexagonal-tiled-map! screen k & options)], :java [["hexagonal-tiled-map!" {:text "", :items [{:args [], :name ":dispose"} {:args [], :type "TiledMap", :name ":get-map"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "float", :name ":get-unit-scale"} {:args [], :type "Rectangle", :name ":get-view-bounds"} {:args [], :name ":render"} {:args [["int[]" "layers"]], :name ":render"} {:args [["MapObject" "object"]], :name ":render-object"} {:args [["TiledMapTileLayer" "layer"]], :name ":render-tile-layer"} {:args [["TiledMap" "map"]], :name ":set-map"} {:args [["OrthographicCamera" "camera"]], :name ":set-view"} {:args [["Matrix4" "projection"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":set-view"}]}]], :name "hexagonal-tiled-map!", :type :code, :raw "(defmacro hexagonal-tiled-map!\n  [screen k & options]\n  `(let [^HexagonalTiledMapRenderer object# (u/get-obj ~screen :renderer)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>hexagonal-tiled-map</code>.</p>"} {:raw* "(defn stage*\n  []\n  (Stage.))", :arglists [(stage & options)], :java [["stage" {:text "A 2D scene graph containing hierarchies of {@link Actor actors}. Stage handles the viewport and distributes input events.\n <p>\n {@link #setViewport(Viewport)} controls the coordinates used within the stage and sets up the camera used to convert between\n stage coordinates and screen coordinates.\n <p>\n A stage must receive input events so it can distribute them to actors. This is typically done by passing the stage to\n {@link Input#setInputProcessor(com.badlogic.gdx.InputProcessor) Gdx.input.setInputProcessor}. An {@link InputMultiplexer} may be\n used to handle input events before or after the stage does. If an actor handles an event by returning true from the input\n method, then the stage's input method will also return true, causing subsequent InputProcessors to not receive the event.\n <p>\n The Stage and its constituents (like Actors and Listeners) are not thread-safe and should only be updated and queried from a\n single thread (presumably the main render thread). Methods should be reentrant, so you can update Actors and Stages from within\n callbacks and handlers.", :items [{:args [], :text "Calls {@link #act(float)} with {@link Graphics#getDeltaTime()}.", :name ":act"} {:args [["float" "delta"]], :text "Calls the {@link Actor#act(float)} method on each actor in the stage. Typically called each frame. This method also fires\n enter and exit events.", :name ":act"} {:args [["Action" "action"]], :text "Adds an action to the root of the stage.", :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor to the root of the stage.", :name ":add-actor"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a capture listener to the root.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener to the root.", :name ":add-listener"} {:args [["EventListener" "listener"] ["Actor" "listener-actor"] ["Actor" "target"] ["int" "pointer"] ["int" "button"]], :text "Adds the listener to be notified for all touchDragged and touchUp events for the specified pointer and button. The actor\n will be used as the {@link Event#getListenerActor() listener actor} and {@link Event#getTarget() target}.", :name ":add-touch-focus"} {:args [["Rectangle" "area"] ["Rectangle" "scissor"]], :name ":calculate-scissors"} {:args [], :text "Sends a touchUp event to all listeners that are registered to receive touchDragged and touchUp events and removes their\n touch focus. This method removes all touch focus listeners, but sends a touchUp event so that the state of the listeners\n remains consistent (listeners typically expect to receive touchUp eventually). The location of the touchUp is\n {@link Integer#MIN_VALUE}. Listeners can use {@link InputEvent#isTouchFocusCancel()} to ignore this event if needed.", :name ":cancel-touch-focus"} {:args [["EventListener" "listener"] ["Actor" "actor"]], :text "Cancels touch focus for all listeners except the specified listener.", :name ":cancel-touch-focus"} {:args [], :text "Removes the root's children, actions, and listeners.", :name ":clear"} {:args [], :name ":dispose"} {:args [], :name ":draw"} {:args [], :type "Array", :text "Returns the root's child actors.", :name ":get-actors"} {:args [], :type "Camera", :text "The viewport's camera.", :name ":get-camera"} {:args [], :type "float", :text "The viewport's world height.", :name ":get-height"} {:args [], :type "Actor", :text "Gets the actor that will receive key events.", :name ":get-keyboard-focus"} {:args [], :type "Group", :text "Returns the root group which holds all actors in the stage.", :name ":get-root"} {:args [], :type "Actor", :text "Gets the actor that will receive scroll events.", :name ":get-scroll-focus"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "Viewport", :name ":get-viewport"} {:args [], :type "float", :text "The viewport's world width.", :name ":get-width"} {:args [["float" "stage-x"] ["float" "stage-y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the {@link Actor} at the specified location in stage coordinates. Hit testing is performed in the order the actors\n were inserted into the stage, last inserted actors being tested first. To get stage coordinates from screen coordinates, use\n {@link #screenToStageCoordinates(Vector2)}.", :name ":hit"} {:args [["int" "keycode"]], :type "boolean", :name ":key-down"} {:args [["int" "key-code"]], :type "boolean", :text "Applies a key down event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns\n true if the event was {@link Event#handle() handled}.", :name ":key-down"} {:args [["char" "character"]], :type "boolean", :name ":key-typed"} {:args [["char" "character"]], :type "boolean", :text "Applies a key typed event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns\n true if the event was {@link Event#handle() handled}.", :name ":key-typed"} {:args [["int" "keycode"]], :type "boolean", :name ":key-up"} {:args [["int" "key-code"]], :type "boolean", :text "Applies a key up event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns true\n if the event was {@link Event#handle() handled}.", :name ":key-up"} {:args [["int" "screen-x"] ["int" "screen-y"]], :type "boolean", :name ":mouse-moved"} {:args [["int" "screen-x"] ["int" "screen-y"]], :type "boolean", :text "Applies a mouse moved event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.\n This event only occurs on the desktop.", :name ":mouse-moved"} {:args [["EventListener" "listener"]], :type "boolean", :text "Removes a listener from the root.", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Removes a listener from the root.", :name ":remove-listener"} {:args [["EventListener" "listener"] ["Actor" "listener-actor"] ["Actor" "target"] ["int" "pointer"] ["int" "button"]], :text "Removes the listener from being notified for all touchDragged and touchUp events for the specified pointer and button. Note\n the listener may never receive a touchUp event if this method is used.", :name ":remove-touch-focus"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the screen coordinates to stage coordinates.", :name ":screen-to-stage-coordinates"} {:args [["int" "amount"]], :type "boolean", :name ":scrolled"} {:args [["int" "amount"]], :type "boolean", :text "Applies a mouse scroll event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the\n event. This event only occurs on the desktop.", :name ":scrolled"} {:args [["Actor" "actor"]], :text "Sets the actor that will receive key events.", :name ":set-keyboard-focus"} {:args [["Actor" "actor"]], :text "Sets the actor that will receive scroll events.", :name ":set-scroll-focus"} {:args [["Viewport" "viewport"]], :name ":set-viewport"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the stage coordinates to screen coordinates.", :name ":stage-to-screen-coordinates"} {:args [["Vector2" "coords"] ["Matrix4" "transform-matrix"]], :type "Vector2", :text "Transforms the coordinates to screen coordinates. The coordinates can be anywhere in the stage since the transform matrix\n describes how to convert them. The transform matrix is typically obtained from {@link Batch#getTransformMatrix()} during\n {@link Actor#draw(Batch, float)}.", :name ":to-screen-coordinates"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-down"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :text "Applies a touch down event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.", :name ":touch-down"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"]], :type "boolean", :name ":touch-dragged"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"]], :type "boolean", :text "Applies a touch moved event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.\n Only {@link InputListener listeners} that returned true for touchDown will receive this event.", :name ":touch-dragged"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-up"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :text "Applies a touch up event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.\n Only {@link InputListener listeners} that returned true for touchDown will receive this event.", :name ":touch-up"} {:args [["Actor" "actor"]], :text "Removes the touch, keyboard, and scroll focus for the specified actor and any descendants.", :name ":unfocus"} {:args [], :text "Removes the touch, keyboard, and scroll focused actors.", :name ":unfocus-all"}]}]], :name "stage", :type :code, :raw "(defmacro stage\n  [& options]\n  `(u/calls! ^Stage (stage*) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/Stage.html'>Stage</a>.</p><pre>\n&#40;stage&#41;\n</pre>"} {:raw* nil, :arglists [(stage! screen k & options)], :java [["stage!" {:text "A 2D scene graph containing hierarchies of {@link Actor actors}. Stage handles the viewport and distributes input events.\n <p>\n {@link #setViewport(Viewport)} controls the coordinates used within the stage and sets up the camera used to convert between\n stage coordinates and screen coordinates.\n <p>\n A stage must receive input events so it can distribute them to actors. This is typically done by passing the stage to\n {@link Input#setInputProcessor(com.badlogic.gdx.InputProcessor) Gdx.input.setInputProcessor}. An {@link InputMultiplexer} may be\n used to handle input events before or after the stage does. If an actor handles an event by returning true from the input\n method, then the stage's input method will also return true, causing subsequent InputProcessors to not receive the event.\n <p>\n The Stage and its constituents (like Actors and Listeners) are not thread-safe and should only be updated and queried from a\n single thread (presumably the main render thread). Methods should be reentrant, so you can update Actors and Stages from within\n callbacks and handlers.", :items [{:args [], :text "Calls {@link #act(float)} with {@link Graphics#getDeltaTime()}.", :name ":act"} {:args [["float" "delta"]], :text "Calls the {@link Actor#act(float)} method on each actor in the stage. Typically called each frame. This method also fires\n enter and exit events.", :name ":act"} {:args [["Action" "action"]], :text "Adds an action to the root of the stage.", :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor to the root of the stage.", :name ":add-actor"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a capture listener to the root.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener to the root.", :name ":add-listener"} {:args [["EventListener" "listener"] ["Actor" "listener-actor"] ["Actor" "target"] ["int" "pointer"] ["int" "button"]], :text "Adds the listener to be notified for all touchDragged and touchUp events for the specified pointer and button. The actor\n will be used as the {@link Event#getListenerActor() listener actor} and {@link Event#getTarget() target}.", :name ":add-touch-focus"} {:args [["Rectangle" "area"] ["Rectangle" "scissor"]], :name ":calculate-scissors"} {:args [], :text "Sends a touchUp event to all listeners that are registered to receive touchDragged and touchUp events and removes their\n touch focus. This method removes all touch focus listeners, but sends a touchUp event so that the state of the listeners\n remains consistent (listeners typically expect to receive touchUp eventually). The location of the touchUp is\n {@link Integer#MIN_VALUE}. Listeners can use {@link InputEvent#isTouchFocusCancel()} to ignore this event if needed.", :name ":cancel-touch-focus"} {:args [["EventListener" "listener"] ["Actor" "actor"]], :text "Cancels touch focus for all listeners except the specified listener.", :name ":cancel-touch-focus"} {:args [], :text "Removes the root's children, actions, and listeners.", :name ":clear"} {:args [], :name ":dispose"} {:args [], :name ":draw"} {:args [], :type "Array", :text "Returns the root's child actors.", :name ":get-actors"} {:args [], :type "Camera", :text "The viewport's camera.", :name ":get-camera"} {:args [], :type "float", :text "The viewport's world height.", :name ":get-height"} {:args [], :type "Actor", :text "Gets the actor that will receive key events.", :name ":get-keyboard-focus"} {:args [], :type "Group", :text "Returns the root group which holds all actors in the stage.", :name ":get-root"} {:args [], :type "Actor", :text "Gets the actor that will receive scroll events.", :name ":get-scroll-focus"} {:args [], :type "Batch", :name ":get-sprite-batch"} {:args [], :type "Viewport", :name ":get-viewport"} {:args [], :type "float", :text "The viewport's world width.", :name ":get-width"} {:args [["float" "stage-x"] ["float" "stage-y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the {@link Actor} at the specified location in stage coordinates. Hit testing is performed in the order the actors\n were inserted into the stage, last inserted actors being tested first. To get stage coordinates from screen coordinates, use\n {@link #screenToStageCoordinates(Vector2)}.", :name ":hit"} {:args [["int" "keycode"]], :type "boolean", :name ":key-down"} {:args [["int" "key-code"]], :type "boolean", :text "Applies a key down event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns\n true if the event was {@link Event#handle() handled}.", :name ":key-down"} {:args [["char" "character"]], :type "boolean", :name ":key-typed"} {:args [["char" "character"]], :type "boolean", :text "Applies a key typed event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns\n true if the event was {@link Event#handle() handled}.", :name ":key-typed"} {:args [["int" "keycode"]], :type "boolean", :name ":key-up"} {:args [["int" "key-code"]], :type "boolean", :text "Applies a key up event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns true\n if the event was {@link Event#handle() handled}.", :name ":key-up"} {:args [["int" "screen-x"] ["int" "screen-y"]], :type "boolean", :name ":mouse-moved"} {:args [["int" "screen-x"] ["int" "screen-y"]], :type "boolean", :text "Applies a mouse moved event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.\n This event only occurs on the desktop.", :name ":mouse-moved"} {:args [["EventListener" "listener"]], :type "boolean", :text "Removes a listener from the root.", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Removes a listener from the root.", :name ":remove-listener"} {:args [["EventListener" "listener"] ["Actor" "listener-actor"] ["Actor" "target"] ["int" "pointer"] ["int" "button"]], :text "Removes the listener from being notified for all touchDragged and touchUp events for the specified pointer and button. Note\n the listener may never receive a touchUp event if this method is used.", :name ":remove-touch-focus"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the screen coordinates to stage coordinates.", :name ":screen-to-stage-coordinates"} {:args [["int" "amount"]], :type "boolean", :name ":scrolled"} {:args [["int" "amount"]], :type "boolean", :text "Applies a mouse scroll event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the\n event. This event only occurs on the desktop.", :name ":scrolled"} {:args [["Actor" "actor"]], :text "Sets the actor that will receive key events.", :name ":set-keyboard-focus"} {:args [["Actor" "actor"]], :text "Sets the actor that will receive scroll events.", :name ":set-scroll-focus"} {:args [["Viewport" "viewport"]], :name ":set-viewport"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the stage coordinates to screen coordinates.", :name ":stage-to-screen-coordinates"} {:args [["Vector2" "coords"] ["Matrix4" "transform-matrix"]], :type "Vector2", :text "Transforms the coordinates to screen coordinates. The coordinates can be anywhere in the stage since the transform matrix\n describes how to convert them. The transform matrix is typically obtained from {@link Batch#getTransformMatrix()} during\n {@link Actor#draw(Batch, float)}.", :name ":to-screen-coordinates"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-down"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :text "Applies a touch down event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.", :name ":touch-down"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"]], :type "boolean", :name ":touch-dragged"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"]], :type "boolean", :text "Applies a touch moved event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.\n Only {@link InputListener listeners} that returned true for touchDown will receive this event.", :name ":touch-dragged"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-up"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :text "Applies a touch up event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.\n Only {@link InputListener listeners} that returned true for touchDown will receive this event.", :name ":touch-up"} {:args [["Actor" "actor"]], :text "Removes the touch, keyboard, and scroll focus for the specified actor and any descendants.", :name ":unfocus"} {:args [], :text "Removes the touch, keyboard, and scroll focused actors.", :name ":unfocus-all"}]}]], :name "stage!", :type :code, :raw "(defmacro stage!\n  [screen k & options]\n  `(let [^Stage object# (u/get-obj ~screen :renderer)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>stage</code>.</p>"} {:raw* nil, :arglists [(render-map! screen & [k & layer-names])], :java [], :name "render-map!", :type :code, :raw "(defn render-map!\n  [{:keys [^BatchTiledMapRenderer renderer ^Camera camera] :as screen}\n   & [k & layer-names]]\n  (when camera (.setView renderer camera))\n  (if k\n    (let [all-layer-names (map-layer-names screen)]\n      ; make sure the layer names exist\n      (doseq [n layer-names]\n        (when-not (contains? (set all-layer-names) n)\n          (throw (Exception. (format \"Layer \\\"%s\\\" does not exist.\" n)))))\n      ; render with or without the supplied layers\n      (->> (case k\n             :with (set layer-names)\n             :without (clojure.set/difference (set all-layer-names)\n                                              (set layer-names))\n             (u/throw-key-not-found k))\n           (map #(.indexOf ^java.util.List all-layer-names %))\n           int-array\n           (.render renderer)))\n    (.render renderer))\n  nil)", :docstring "<p>Calls the tiled-map renderer from <code>screen</code>, optionally allowing you to specify which layers to render with or without.</p><pre>\n&#40;render-map! screen :with &quot;water&quot; &quot;grass&quot;&#41;\n&#40;render-map! screen :without &quot;desert&quot; &quot;rocks&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(render-stage! screen)], :java [], :name "render-stage!", :type :code, :raw "(defn render-stage!\n  [{:keys [^Stage renderer] :as screen}]\n  (doto renderer .act .draw)\n  nil)", :docstring "<p>Calls the stage renderer from <code>screen</code>.</p>"} {:raw* nil, :arglists [(render! screen) (render! screen entities)], :java [], :name "render!", :type :code, :raw "(defn render!\n  ([{:keys [renderer] :as screen}]\n    (cond\n      (isa? (type renderer) BatchTiledMapRenderer)\n      (render-map! screen)\n      (isa? (type renderer) Stage)\n      (render-stage! screen)))\n  ([screen entities]\n    (render! screen)\n    (draw! screen entities)))", :docstring "<p>Calls the renderer from <code>screen</code> and optionally draws and returns the <code>entities</code>.</p><pre>\n&#40;render! screen entities&#41;\n</pre>"} {:raw* nil, :arglists [(render-sorted! screen layer-names entities) (render-sorted! screen sort-fn layer-names entities)], :java [], :name "render-sorted!", :type :code, :raw "(defn render-sorted!\n  ([screen layer-names entities]\n    (render-sorted! sort-by-y screen layer-names entities))\n  ([{:keys [^BatchTiledMapRenderer renderer\n            ^Camera camera\n            update-fn!]\n     :as screen}\n    sort-fn layer-names entities]\n    (doseq [ln layer-names]\n      (when-not (get-in screen [:layers ln])\n        (update-fn! assoc-in [[:layers ln] (split-layer screen ln)])))\n    (when camera (.setView renderer camera))\n    (let [^SpriteBatch batch (.getSpriteBatch renderer)]\n      (.begin batch)\n      (doseq [entity (->> (map #(get-in screen [:layers %]) layer-names)\n                          (apply concat entities)\n                          sort-fn)]\n        (if-let [layer (:layer entity)]\n          (.renderTileLayer renderer layer)\n          (e/draw-entity! entity screen batch)))\n      (.end batch))\n    entities))", :docstring "<p>Draws the specified layer tiles and entities sorted by their position on the y axis. A custom sort function may be provided. This is primarily intended for games with isometric tiled maps, where the layer tiles often need to be sorted to overlap correctly with the entities.</p><pre>\n&#40;render-sorted! screen &#91;&quot;walls&quot;&#93; entities&#41;\n&#40;render-sorted! screen #&#40;sort-by :y %&#41; &#91;&quot;walls&quot;&#93; entities&#41;\n</pre>"})} {:ns "", :groups ({:raw* nil, :arglists [(input-processor! screen k & options)], :java [["input-processor!" {:text "An InputProcessor is used to receive input events from the keyboard and the touch screen (mouse on the desktop). For this it\n has to be registered with the {@link Input#setInputProcessor(InputProcessor)} method. It will be called each frame before the\n call to {@link ApplicationListener#render()}. Each method returns a boolean in case you want to use this with the\n {@link InputMultiplexer} to chain input processors.", :items [{:args [["int" "keycode"]], :type "boolean", :text "Called when a key was pressed", :name ":key-down"} {:args [["char" "character"]], :type "boolean", :text "Called when a key was typed", :name ":key-typed"} {:args [["int" "keycode"]], :type "boolean", :text "Called when a key was released", :name ":key-up"} {:args [["int" "screen-x"] ["int" "screen-y"]], :type "boolean", :text "Called when the mouse was moved without any buttons being pressed. Will not be called on either Android or iOS.", :name ":mouse-moved"} {:args [["int" "amount"]], :type "boolean", :text "Called when the mouse wheel was scrolled. Will not be called on either Android or iOS.", :name ":scrolled"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :text "Called when the screen was touched or a mouse button was pressed. The button parameter will be {@link Buttons#LEFT} on\n Android and iOS.", :name ":touch-down"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"]], :type "boolean", :text "Called when a finger or the mouse was dragged.", :name ":touch-dragged"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :text "Called when a finger was lifted or a mouse button was released. The button parameter will be {@link Buttons#LEFT} on Android\n and iOS.", :name ":touch-up"}]}]], :name "input-processor!", :type :code, :raw "(defmacro input-processor!\n  [screen k & options]\n  `(let [listeners# (u/get-obj ~screen :input-listeners)\n         ^InputProcessor object# (u/get-obj listeners# :input-processor)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/InputProcessor.html'>InputProcessor</a> in the <code>screen</code>.</p>"} {:raw* nil, :arglists [(gesture-detector! screen k & options)], :java [["gesture-detector!" {:text "{@link InputProcessor} implementation that detects gestures (tap, long press, fling, pan, zoom, pinch) and hands them to a\n {@link GestureListener}.", :items [{:args [], :text "No further gesture events will be triggered for the current touch, if any.", :name ":cancel"} {:args [], :text "The tap square will not longer be used for the current touch.", :name ":invalidate-tap-square"} {:args [], :type "boolean", :name ":is-long-pressed"} {:args [["float" "duration"]], :type "boolean", :name ":is-long-pressed"} {:args [], :type "boolean", :name ":is-panning"} {:args [["int" "keycode"]], :type "boolean", :name ":key-down"} {:args [["char" "character"]], :type "boolean", :name ":key-typed"} {:args [["int" "keycode"]], :type "boolean", :name ":key-up"} {:args [["int" "screen-x"] ["int" "screen-y"]], :type "boolean", :name ":mouse-moved"} {:args [], :name ":reset"} {:args [["int" "amount"]], :type "boolean", :name ":scrolled"} {:args [["float" "long-press-seconds"]], :name ":set-long-press-seconds"} {:args [["long" "max-fling-delay"]], :name ":set-max-fling-delay"} {:args [["float" "tap-count-interval"]], :name ":set-tap-count-interval"} {:args [["float" "tap-square-size"]], :name ":set-tap-square-size"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-down"} {:args [["int" "x"] ["int" "y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-down"} {:args [["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-down"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"]], :type "boolean", :name ":touch-dragged"} {:args [["int" "x"] ["int" "y"] ["int" "pointer"]], :type "boolean", :name ":touch-dragged"} {:args [["float" "x"] ["float" "y"] ["int" "pointer"]], :type "boolean", :name ":touch-dragged"} {:args [["int" "screen-x"] ["int" "screen-y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-up"} {:args [["int" "x"] ["int" "y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-up"} {:args [["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-up"}]}]], :name "gesture-detector!", :type :code, :raw "(defmacro gesture-detector!\n  [screen k & options]\n  `(let [listeners# (u/get-obj ~screen :input-listeners)\n         ^GestureDetector object# (u/get-obj listeners# :gesture-detector)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/input/GestureDetector.html'>GestureDetector</a> in the <code>screen</code>.</p>"})} {:ns "", :groups ({:raw* nil, :arglists [(on-gl & body)], :java [], :name "on-gl", :type :code, :raw "(defmacro on-gl\n  [& body]\n  `(app! :post-runnable (fn [] ~@body)))", :docstring "<p>Runs the macro body on the GL thread.</p><pre>\n&#40;on-gl &#40;set-screen! my-game main-screen&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(bundle & entities)], :java [], :name "bundle", :type :code, :raw "(defn bundle\n  [& entities]\n  (BundleEntity. entities))", :docstring "<p>Returns an entity containing other entities. This is a useful way to keep related entities together. They will be drawn in the order they appear in the internal :entities vector. Any keys in the bundle, such as :x and :y, will override the equivalent keys in each entity when being drawn.</p><pre>\n&#40;bundle &#40;shape :filled&#41; &#40;shape :line&#41;&#41;\n&#40;assoc &#40;bundle &#40;shape :filled&#41; &#40;shape :line&#41;&#41;\n       :x 100 :y 100&#41;\n</pre>"} {:raw* nil, :arglists [(bundle? entity)], :java [], :name "bundle?", :type :code, :raw "(defn bundle?\n  [entity]\n  (isa? (type entity) BundleEntity))", :docstring "<p>Returns true if <code>entity</code> is a <code>bundle</code>.</p>"} {:raw* nil, :arglists [(screenshot!) (screenshot! path)], :java [], :name "screenshot!", :type :code, :raw "(defn screenshot!\n  ([]\n    (let [^Pixmap$Format pic-f (Pixmap$Format/RGBA8888)\n          ^Pixmap pic (Pixmap. ^long (game :width) ^long (game :height) pic-f)\n          pixel-data (ScreenUtils/getFrameBufferPixels true)\n          pixels (.getPixels pic)]\n      (doto pixels\n        (.clear)\n        (.put pixel-data)\n        (.position 0))\n      pic))\n  ([path]\n    (let [pic (screenshot!)\n          handle (if (string? path)\n                   (files! :local path)\n                   path)]\n      (PixmapIO/writePNG handle pic)\n      (pixmap! pic :dispose))))", :docstring "<p>Captures a screenshot and either returns it as a <code>pixmap</code> or saves it to the specified path.</p><pre>\n&#40;screenshot!&#41;\n&#40;screenshot! &quot;out.png&quot;&#41;\n&#40;screenshot! &#40;files! :external &quot;out.png&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(pref! name k & options)], :java [["pref!" {:text "<p>\n A Preference instance is a hash map holding different values. It is stored alongside your application (SharedPreferences on\n Android, LocalStorage on GWT, on the desktop a Java Preferences file in a \".prefs\" directory will be created, and on iOS an\n NSMutableDictionary will be written to the given file). CAUTION: On the desktop platform, all libgdx applications share the same\n \".prefs\" directory. To avoid collisions use specific names like \"com.myname.game1.settings\" instead of \"settings\"\n </p>\n \n <p>\n Changes to a preferences instance will be cached in memory until {@link #flush()} is invoked.\n </p>\n \n <p>\n Use {@link Application#getPreferences(String)} to look up a specific preferences instance. Note that on several backends the\n preferences name will be used as the filename, so make sure the name is valid for a filename.\n </p>", :items [{:args [], :name ":clear"} {:args [["String" "key"]], :type "boolean", :name ":contains"} {:args [], :text "Makes sure the preferences are persisted.", :name ":flush"} {:args [], :type "Map", :text "Returns a read only Map<String, Object> with all the key, objects of the preferences.", :name ":get"} {:args [["String" "key"]], :type "boolean", :name ":get-boolean"} {:args [["String" "key"] ["boolean" "def-value"]], :type "boolean", :name ":get-boolean"} {:args [["String" "key"]], :type "float", :name ":get-float"} {:args [["String" "key"] ["float" "def-value"]], :type "float", :name ":get-float"} {:args [["String" "key"]], :type "int", :name ":get-integer"} {:args [["String" "key"] ["int" "def-value"]], :type "int", :name ":get-integer"} {:args [["String" "key"]], :type "long", :name ":get-long"} {:args [["String" "key"] ["long" "def-value"]], :type "long", :name ":get-long"} {:args [["String" "key"]], :type "String", :name ":get-string"} {:args [["String" "key"] ["String" "def-value"]], :type "String", :name ":get-string"} {:args [["java.util.Map" "vals"]], :name ":put"} {:args [["String" "key"] ["boolean" "val"]], :name ":put-boolean"} {:args [["String" "key"] ["float" "val"]], :name ":put-float"} {:args [["String" "key"] ["int" "val"]], :name ":put-integer"} {:args [["String" "key"] ["long" "val"]], :name ":put-long"} {:args [["String" "key"] ["String" "val"]], :name ":put-string"} {:args [["String" "key"]], :name ":remove"}]}]], :name "pref!", :type :code, :raw "(defmacro pref!\n  [name k & options]\n  `(let [^Preferences p# (if (string? ~name)\n                           (app! :get-preferences ~name)\n                           ~name)]\n     (u/call! p# ~k ~@options)))", :docstring "<p>Retrieves and stores preferences. The <code>name</code> should be a unique string.</p><pre>\n; define the name we'll be using\n&#40;def &#94;:const pref-name &quot;my-game.settings&quot;&#41;\n; store a single preference\n&#40;pref! pref-name :put-float &quot;player-health&quot; 40&#41;\n; store multiple preferences\n&#40;pref! pref-name :put {&quot;player-health&quot; 40\n                       &quot;player-x&quot; 20\n                       &quot;player-y&quot; 50}&#41;\n; save the changes to the disk\n&#40;pref! pref-name :flush&#41;\n; retrieve a single preference\n&#40;pref! pref-name :get-float &quot;player-health&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(scaling k)], :java [["scaling" {:text "Various scaling types for fitting one rectangle into another.", :items [{:text "Scales the source to fill the target while keeping the same aspect ratio. This may cause the source to be larger than the\n target in one direction.", :name ":fill"} {:text "Scales the source to fill the target in the x direction while keeping the same aspect ratio. This may cause the source to be\n smaller or larger than the target in the y direction.", :name ":fill-x"} {:text "Scales the source to fill the target in the y direction while keeping the same aspect ratio. This may cause the source to be\n smaller or larger than the target in the x direction.", :name ":fill-y"} {:text "Scales the source to fit the target while keeping the same aspect ratio. This may cause the source to be smaller than the\n target in one direction.", :name ":fit"} {:text "The source is not scaled.", :name ":none"} {:text "Scales the source to fill the target. This may cause the source to not keep the same aspect ratio.", :name ":stretch"} {:text "Scales the source to fill the target in the x direction, without changing the y direction. This may cause the source to not\n keep the same aspect ratio.", :name ":stretch-x"} {:text "Scales the source to fill the target in the y direction, without changing the x direction. This may cause the source to not\n keep the same aspect ratio.", :name ":stretch-y"}]}]], :name "scaling", :type :code, :raw "(defmacro scaling\n  [k]\n  `~(u/gdx-field :utils :Scaling k))", :docstring "<p>Returns a static field from <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/utils/Scaling.html'>Scaling</a>.</p><pre>\n&#40;scaling :fill&#41;\n</pre>"} {:raw* nil, :arglists [(usage k)], :java [["usage" {:text "The usage of a vertex attribute.", :items [{:name ":bi-normal"} {:name ":bone-weight"} {:name ":color"} {:name ":color-packed"} {:name ":generic"} {:name ":normal"} {:name ":position"} {:name ":tangent"} {:name ":texture-coordinates"}]}]], :name "usage", :type :code, :raw "(defmacro usage\n  [k]\n  `~(u/gdx-field :graphics \"VertexAttributes$Usage\" (u/key->pascal k)))", :docstring "<p>Returns a static field in <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/VertexAttributes.Usage.html'>VertexAttributes.Usage</a>.</p>"} {:raw* nil, :arglists [(add-timer! screen id delay) (add-timer! screen id delay interval) (add-timer! screen id delay interval repeat)], :java [], :name "add-timer!", :type :code, :raw "(defn add-timer!\n  ([screen id delay]\n    (doto (create-and-add-timer! screen id)\n      (.scheduleTask (task* screen id) delay)))\n  ([screen id delay interval]\n    (doto (create-and-add-timer! screen id)\n      (.scheduleTask (task* screen id) delay interval)))\n  ([screen id delay interval repeat]\n    (doto (create-and-add-timer! screen id)\n      (.scheduleTask (task* screen id) delay interval repeat))))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/utils/Timer.html'>Timer</a> that runs the :on-timer function according to the given arguments.</p><pre>\n; wait 2 seconds and run once\n&#40;add-timer! screen :spawn-enemy 2&#41;\n; wait 2 seconds and run forever at 10 second intervals\n&#40;add-timer! screen :spawn-enemy 2 10&#41;\n; wait 2 seconds, run once, and then run 3 more times at 10 second intervals\n&#40;add-timer! screen :spawn-enemy 2 10 3&#41;\n</pre>"} {:raw* nil, :arglists [(remove-timer! screen id)], :java [], :name "remove-timer!", :type :code, :raw "(defn remove-timer!\n  [{:keys [update-fn!] :as screen} id]\n  (when-let [timer (get-in screen [:timers id])]\n    (.stop timer)\n    (update-fn! update-in [[:timers] dissoc id])\n    timer))", :docstring "<p>Stops and removes the timer associated with <code>id</code>, returning it or nil if not found.</p>"} {:raw* "(defn asset-manager*\n  ([]\n    (doto (AssetManager.) set-loaders!))\n  ([resolver]\n    (doto (AssetManager. resolver) (set-loaders! resolver))))", :arglists [(asset-manager & options)], :java [["asset-manager" {:text "Loads and stores assets like textures, bitmapfonts, tile maps, sounds, music and so on.", :items [{:args [], :text "Clears and disposes all assets and the preloading queue.", :name ":clear"} {:args [["Object" "asset"]], :type "boolean", :name ":contains-asset"} {:args [], :text "Disposes all assets in the manager and stops all asynchronous loading.", :name ":dispose"} {:args [], :text "blocks until all assets are loaded.", :name ":finish-loading"} {:args [["String" "file-name"]], :type "Object", :name ":get"} {:args [["String" "file-name"] ["java.lang.Class" "type"]], :type "Object", :name ":get"} {:args [["com.badlogic.gdx.assets.AssetDescriptor" "asset-descriptor"]], :type "Object", :name ":get"} {:args [["java.lang.Class" "type"] ["com.badlogic.gdx.utils.Array" "out"]], :type "Array", :name ":get-all"} {:args [["Object" "asset"]], :type "String", :name ":get-asset-file-name"} {:args [], :type "Array", :name ":get-asset-names"} {:args [["String" "file-name"]], :type "Class", :name ":get-asset-type"} {:args [["String" "file-name"]], :type "Array", :name ":get-dependencies"} {:args [], :type "String", :name ":get-diagnostics"} {:args [], :type "int", :name ":get-loaded-assets"} {:args [["java.lang.Class" "type"]], :type "AssetLoader", :text "Returns the default loader for the given type", :name ":get-loader"} {:args [["java.lang.Class" "type"] ["String" "file-name"]], :type "AssetLoader", :text "Returns the loader for the given type and the specified filename. If no loader exists for the specific filename, the default\n loader for that type is returned.", :name ":get-loader"} {:args [], :type "Logger", :name ":get-logger"} {:args [], :type "float", :name ":get-progress"} {:args [], :type "int", :name ":get-queued-assets"} {:args [["String" "file-name"]], :type "int", :text "Returns the reference count of an asset.", :name ":get-reference-count"} {:args [["String" "file-name"]], :type "boolean", :name ":is-loaded"} {:args [["String" "file-name"] ["java.lang.Class" "type"]], :type "boolean", :name ":is-loaded"} {:args [["String" "file-name"] ["java.lang.Class" "type"]], :text "Adds the given asset to the loading queue of the AssetManager.", :name ":load"} {:args [["String" "file-name"] ["java.lang.Class" "type"] ["com.badlogic.gdx.assets.AssetLoaderParameters" "parameter"]], :text "Adds the given asset to the loading queue of the AssetManager.", :name ":load"} {:args [["com.badlogic.gdx.assets.AssetDescriptor" "desc"]], :text "Adds the given asset to the loading queue of the AssetManager.", :name ":load"} {:args [["AssetErrorListener" "listener"]], :text "Sets an {@link AssetErrorListener} to be invoked in case loading an asset failed.", :name ":set-error-listener"} {:args [["java.lang.Class" "type"] ["com.badlogic.gdx.assets.loaders.AssetLoader" "loader"]], :text "Sets a new {@link AssetLoader} for the given type.", :name ":set-loader"} {:args [["java.lang.Class" "type"] ["String" "suffix"] ["com.badlogic.gdx.assets.loaders.AssetLoader" "loader"]], :text "Sets a new {@link AssetLoader} for the given type.", :name ":set-loader"} {:args [["Logger" "logger"]], :name ":set-logger"} {:args [["String" "file-name"] ["int" "ref-count"]], :text "Sets the reference count of an asset.", :name ":set-reference-count"} {:args [["String" "file-name"]], :text "Removes the asset and all its dependencies, if they are not used by other assets.", :name ":unload"} {:args [], :type "boolean", :text "Updates the AssetManager, keeping it loading any assets in the preload queue.", :name ":update"} {:args [["int" "millis"]], :type "boolean", :text "Updates the AssetManager continuously for the specified number of milliseconds, yielding the CPU to the loading thread\n between updates. This may block for less time if all loading tasks are complete. This may block for more time if the portion\n of a single task that happens in the GL thread takes a long time.", :name ":update"}]}]], :name "asset-manager", :type :code, :raw "(defmacro asset-manager\n  [& options]\n  `(let [^AssetManager object# (asset-manager*)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/assets/AssetManager.html'>AssetManager</a>.</p><pre>\n&#40;asset-manager&#41;\n</pre>"} {:raw* nil, :arglists [(asset-manager! object k & options)], :java [["asset-manager!" {:text "Loads and stores assets like textures, bitmapfonts, tile maps, sounds, music and so on.", :items [{:args [], :text "Clears and disposes all assets and the preloading queue.", :name ":clear"} {:args [["Object" "asset"]], :type "boolean", :name ":contains-asset"} {:args [], :text "Disposes all assets in the manager and stops all asynchronous loading.", :name ":dispose"} {:args [], :text "blocks until all assets are loaded.", :name ":finish-loading"} {:args [["String" "file-name"]], :type "Object", :name ":get"} {:args [["String" "file-name"] ["java.lang.Class" "type"]], :type "Object", :name ":get"} {:args [["com.badlogic.gdx.assets.AssetDescriptor" "asset-descriptor"]], :type "Object", :name ":get"} {:args [["java.lang.Class" "type"] ["com.badlogic.gdx.utils.Array" "out"]], :type "Array", :name ":get-all"} {:args [["Object" "asset"]], :type "String", :name ":get-asset-file-name"} {:args [], :type "Array", :name ":get-asset-names"} {:args [["String" "file-name"]], :type "Class", :name ":get-asset-type"} {:args [["String" "file-name"]], :type "Array", :name ":get-dependencies"} {:args [], :type "String", :name ":get-diagnostics"} {:args [], :type "int", :name ":get-loaded-assets"} {:args [["java.lang.Class" "type"]], :type "AssetLoader", :text "Returns the default loader for the given type", :name ":get-loader"} {:args [["java.lang.Class" "type"] ["String" "file-name"]], :type "AssetLoader", :text "Returns the loader for the given type and the specified filename. If no loader exists for the specific filename, the default\n loader for that type is returned.", :name ":get-loader"} {:args [], :type "Logger", :name ":get-logger"} {:args [], :type "float", :name ":get-progress"} {:args [], :type "int", :name ":get-queued-assets"} {:args [["String" "file-name"]], :type "int", :text "Returns the reference count of an asset.", :name ":get-reference-count"} {:args [["String" "file-name"]], :type "boolean", :name ":is-loaded"} {:args [["String" "file-name"] ["java.lang.Class" "type"]], :type "boolean", :name ":is-loaded"} {:args [["String" "file-name"] ["java.lang.Class" "type"]], :text "Adds the given asset to the loading queue of the AssetManager.", :name ":load"} {:args [["String" "file-name"] ["java.lang.Class" "type"] ["com.badlogic.gdx.assets.AssetLoaderParameters" "parameter"]], :text "Adds the given asset to the loading queue of the AssetManager.", :name ":load"} {:args [["com.badlogic.gdx.assets.AssetDescriptor" "desc"]], :text "Adds the given asset to the loading queue of the AssetManager.", :name ":load"} {:args [["AssetErrorListener" "listener"]], :text "Sets an {@link AssetErrorListener} to be invoked in case loading an asset failed.", :name ":set-error-listener"} {:args [["java.lang.Class" "type"] ["com.badlogic.gdx.assets.loaders.AssetLoader" "loader"]], :text "Sets a new {@link AssetLoader} for the given type.", :name ":set-loader"} {:args [["java.lang.Class" "type"] ["String" "suffix"] ["com.badlogic.gdx.assets.loaders.AssetLoader" "loader"]], :text "Sets a new {@link AssetLoader} for the given type.", :name ":set-loader"} {:args [["Logger" "logger"]], :name ":set-logger"} {:args [["String" "file-name"] ["int" "ref-count"]], :text "Sets the reference count of an asset.", :name ":set-reference-count"} {:args [["String" "file-name"]], :text "Removes the asset and all its dependencies, if they are not used by other assets.", :name ":unload"} {:args [], :type "boolean", :text "Updates the AssetManager, keeping it loading any assets in the preload queue.", :name ":update"} {:args [["int" "millis"]], :type "boolean", :text "Updates the AssetManager continuously for the specified number of milliseconds, yielding the CPU to the loading thread\n between updates. This may block for less time if all loading tasks are complete. This may block for more time if the portion\n of a single task that happens in the GL thread takes a long time.", :name ":update"}]}]], :name "asset-manager!", :type :code, :raw "(defmacro asset-manager!\n  [object k & options]\n  `(let [^AssetManager object# ~object]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method in an <code>asset-manager</code>.</p><pre>\n&#40;asset-manager! object :clear&#41;\n</pre>"} {:raw* nil, :arglists [(set-asset-manager! am)], :java [], :name "set-asset-manager!", :type :code, :raw "(defn set-asset-manager!\n  [am]\n  (intern 'play-clj.utils '*asset-manager* am))", :docstring "<p>Sets a global asset manager, which will keep track of objects that need to be manually disposed, such as <code>texture</code> entities and <code>pixmap</code> objects. The asset manager will then allow you to dispose them all at once.</p><pre>\n; create an asset manager\n&#40;defonce manager &#40;asset-manager&#41;&#41;\n; set it to be used by play-clj\n&#40;set-asset-manager! manager&#41;\n; dispose all assets at once\n&#40;asset-manager! manager :clear&#41;\n</pre>"})} {:ns "play-clj.g2d", :groups ({:raw* "(defn bitmap-font*\n  [path]\n  (if (nil? path)\n    (BitmapFont.)\n    (let [^Files files (Gdx/files)\n          ^FileHandle fh (if (string? path)\n                           (.internal files path)\n                           path)]\n      (or (u/load-asset (.path fh) BitmapFont)\n          (BitmapFont. fh)))))", :arglists [(bitmap-font & [path & options])], :java [["bitmap-font" {:text "Renders bitmap fonts. The font consists of 2 files: an image file or {@link TextureRegion} containing the glyphs and a file in\n the AngleCode BMFont text format that describes where each glyph is on the image. Currently only a single image of glyphs is\n supported.<br>\n <br>\n Text is drawn using a {@link Batch}. Text can be cached in a {@link BitmapFontCache} for faster rendering of static text, which\n saves needing to compute the location of each glyph each frame.<br>\n <br>\n * The texture for a BitmapFont loaded from a file is managed. {@link #dispose()} must be called to free the texture when no\n longer needed. A BitmapFont loaded using a {@link TextureRegion} is managed if the region's texture is managed. Disposing the\n BitmapFont disposes the region's texture, which may not be desirable if the texture is still being used elsewhere.<br>\n <br>\n The code was originally based on Matthias Mann's TWL BitmapFont class. Thanks for sharing, Matthias! :)", :items [{:args [["CharSequence" "str"] ["FloatArray" "glyph-advances"] ["FloatArray" "glyph-positions"]], :text "Computes the glyph advances for the given character sequence and stores them in the provided {@link FloatArray}. The float\n arrays are cleared. An additional element is added at the end.", :name ":compute-glyph-advances-and-positions"} {:args [["CharSequence" "str"] ["int" "start"] ["int" "end"] ["float" "available-width"]], :type "int", :text "Returns the number of glyphs from the substring that can be rendered in the specified width.", :name ":compute-visible-glyphs"} {:args [["char" "character"]], :type "boolean", :text "Checks whether this BitmapFont data contains a given character.", :name ":contains-character"} {:args [], :text "Disposes the texture used by this BitmapFont's region IF this BitmapFont created the texture.", :name ":dispose"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"]], :type "BitmapFont.TextBounds", :text "Draws a string at the specified position.", :name ":draw"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"] ["int" "start"] ["int" "end"]], :type "BitmapFont.TextBounds", :text "Draws a string at the specified position.", :name ":draw"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"]], :type "BitmapFont.TextBounds", :text "Draws a string, which may contain newlines (\\n), at the specified position.", :name ":draw-multi-line"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"] ["float" "alignment-width"] ["BitmapFont.HAlignment" "alignment"]], :type "BitmapFont.TextBounds", :text "Draws a string, which may contain newlines (\\n), at the specified position.", :name ":draw-multi-line"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"] ["float" "wrap-width"]], :type "BitmapFont.TextBounds", :text "Draws a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped within the\n specified width.", :name ":draw-wrapped"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"] ["float" "wrap-width"] ["BitmapFont.HAlignment" "alignment"]], :type "BitmapFont.TextBounds", :text "Draws a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped within the\n specified width.", :name ":draw-wrapped"} {:args [], :type "float", :text "Returns the ascent, which is the distance from the cap height to the top of the tallest glyph.", :name ":get-ascent"} {:args [["CharSequence" "str"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text. Note the returned TextBounds instance is reused.", :name ":get-bounds"} {:args [["CharSequence" "str"] ["BitmapFont.TextBounds" "text-bounds"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text.", :name ":get-bounds"} {:args [["CharSequence" "str"] ["int" "start"] ["int" "end"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text. Note the returned TextBounds instance is reused.", :name ":get-bounds"} {:args [["CharSequence" "str"] ["int" "start"] ["int" "end"] ["BitmapFont.TextBounds" "text-bounds"]], :type "BitmapFont.TextBounds", :text "Returns the size of the specified string. The height is the distance from the top of most capital letters in the font (the\n {@link #getCapHeight() cap height}) to the baseline.", :name ":get-bounds"} {:args [], :type "BitmapFontCache", :text "For expert usage -- returns the BitmapFontCache used by this font, for rendering to a sprite batch. This can be used, for\n example, to manipulate glyph colors within a specific index.", :name ":get-cache"} {:args [], :type "float", :text "Returns the cap height, which is the distance from the top of most uppercase characters to the baseline. Since the drawing\n position is the cap height of the first line, the cap height can be used to get the location of the baseline.", :name ":get-cap-height"} {:args [], :type "Color", :text "Returns the color of this font. Changing the returned color will have no affect, {@link #setColor(Color)} or\n {@link #setColor(float, float, float, float)} must be used.", :name ":get-color"} {:args [], :type "BitmapFont.BitmapFontData", :text "Gets the underlying {@link BitmapFontData} for this BitmapFont.", :name ":get-data"} {:args [], :type "float", :text "Returns the descent, which is the distance from the bottom of the glyph that extends the lowest to the baseline. This number\n is negative.", :name ":get-descent"} {:args [], :type "float", :text "Returns the line height, which is the distance from one line of text to the next.", :name ":get-line-height"} {:args [["CharSequence" "str"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text, which may contain newlines.", :name ":get-multi-line-bounds"} {:args [["CharSequence" "str"] ["BitmapFont.TextBounds" "text-bounds"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text, which may contain newlines. The height is the distance from the top of most\n capital letters in the font (the {@link #getCapHeight() cap height}) to the baseline of the last line of text.", :name ":get-multi-line-bounds"} {:args [], :type "TextureRegion", :text "Returns the first texture region. This is included for backwards-compatibility, and for convenience since most fonts only\n use one texture page. For multi-page fonts, use getRegions().", :name ":get-region"} {:args [["int" "index"]], :type "TextureRegion", :text "Returns the texture page at the given index.", :name ":get-region"} {:args [], :type "TextureRegion", :text "Returns the array of TextureRegions that represents each texture page of glyphs.", :name ":get-regions"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :text "Returns the width of the space character.", :name ":get-space-width"} {:args [["CharSequence" "str"] ["float" "wrap-width"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text, which may contain newlines and is wrapped within the specified width.", :name ":get-wrapped-bounds"} {:args [["CharSequence" "str"] ["float" "wrap-width"] ["BitmapFont.TextBounds" "text-bounds"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text, which may contain newlines and is wrapped within the specified width. The height\n is the distance from the top of most capital letters in the font (the {@link #getCapHeight() cap height}) to the baseline of\n the last line of text.", :name ":get-wrapped-bounds"} {:args [], :type "float", :text "Returns the x-height, which is the distance from the top of most lowercase characters to the baseline.", :name ":get-xheight"} {:args [], :type "boolean", :text "Returns true if this BitmapFont has been flipped for use with a y-down coordinate system.", :name ":is-flipped"} {:args [], :type "boolean", :name ":owns-texture"} {:args [["float" "amount"]], :text "Sets the font's scale relative to the current scale.", :name ":scale"} {:args [["float" "color"]], :name ":set-color"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["CharSequence" "glyphs"]], :text "Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally\n centering a score or loading percentage text, it will not jump around as different numbers are shown.", :name ":set-fixed-width-glyphs"} {:args [["boolean" "owns-texture"]], :text "Sets whether the font owns the texture or not. In case it does, the font will also dispose of the texture when\n {@link #dispose()} is called. Use with care!", :name ":set-owns-texture"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Scales the font by the specified amounts on both axes <br>\n <br>\n Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}. The\n default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.", :name ":set-scale"} {:args [["float" "scale-xy"]], :text "Scales the font by the specified amount in both directions.", :name ":set-scale"} {:args [["boolean" "integer"]], :text "Specifies whether to use integer positions or not. Default is to use them so filtering doesn't kick in as badly.", :name ":set-use-integer-positions"} {:args [], :type "boolean", :text "Checks whether this font uses integer positions for drawing.", :name ":uses-integer-positions"}]}]], :name "bitmap-font", :type :code, :raw "(defmacro bitmap-font\n  [& [path & options]]\n  `(let [^BitmapFont object# (bitmap-font* ~path)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/BitmapFont.html'>BitmapFont</a>.</p><pre>\n&#40;bitmap-font&#41;\n&#40;bitmap-font &quot;default.fnt&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(bitmap-font! object k & options)], :java [["bitmap-font!" {:text "Renders bitmap fonts. The font consists of 2 files: an image file or {@link TextureRegion} containing the glyphs and a file in\n the AngleCode BMFont text format that describes where each glyph is on the image. Currently only a single image of glyphs is\n supported.<br>\n <br>\n Text is drawn using a {@link Batch}. Text can be cached in a {@link BitmapFontCache} for faster rendering of static text, which\n saves needing to compute the location of each glyph each frame.<br>\n <br>\n * The texture for a BitmapFont loaded from a file is managed. {@link #dispose()} must be called to free the texture when no\n longer needed. A BitmapFont loaded using a {@link TextureRegion} is managed if the region's texture is managed. Disposing the\n BitmapFont disposes the region's texture, which may not be desirable if the texture is still being used elsewhere.<br>\n <br>\n The code was originally based on Matthias Mann's TWL BitmapFont class. Thanks for sharing, Matthias! :)", :items [{:args [["CharSequence" "str"] ["FloatArray" "glyph-advances"] ["FloatArray" "glyph-positions"]], :text "Computes the glyph advances for the given character sequence and stores them in the provided {@link FloatArray}. The float\n arrays are cleared. An additional element is added at the end.", :name ":compute-glyph-advances-and-positions"} {:args [["CharSequence" "str"] ["int" "start"] ["int" "end"] ["float" "available-width"]], :type "int", :text "Returns the number of glyphs from the substring that can be rendered in the specified width.", :name ":compute-visible-glyphs"} {:args [["char" "character"]], :type "boolean", :text "Checks whether this BitmapFont data contains a given character.", :name ":contains-character"} {:args [], :text "Disposes the texture used by this BitmapFont's region IF this BitmapFont created the texture.", :name ":dispose"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"]], :type "BitmapFont.TextBounds", :text "Draws a string at the specified position.", :name ":draw"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"] ["int" "start"] ["int" "end"]], :type "BitmapFont.TextBounds", :text "Draws a string at the specified position.", :name ":draw"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"]], :type "BitmapFont.TextBounds", :text "Draws a string, which may contain newlines (\\n), at the specified position.", :name ":draw-multi-line"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"] ["float" "alignment-width"] ["BitmapFont.HAlignment" "alignment"]], :type "BitmapFont.TextBounds", :text "Draws a string, which may contain newlines (\\n), at the specified position.", :name ":draw-multi-line"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"] ["float" "wrap-width"]], :type "BitmapFont.TextBounds", :text "Draws a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped within the\n specified width.", :name ":draw-wrapped"} {:args [["Batch" "batch"] ["CharSequence" "str"] ["float" "x"] ["float" "y"] ["float" "wrap-width"] ["BitmapFont.HAlignment" "alignment"]], :type "BitmapFont.TextBounds", :text "Draws a string, which may contain newlines (\\n), with the specified position. Each line is automatically wrapped within the\n specified width.", :name ":draw-wrapped"} {:args [], :type "float", :text "Returns the ascent, which is the distance from the cap height to the top of the tallest glyph.", :name ":get-ascent"} {:args [["CharSequence" "str"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text. Note the returned TextBounds instance is reused.", :name ":get-bounds"} {:args [["CharSequence" "str"] ["BitmapFont.TextBounds" "text-bounds"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text.", :name ":get-bounds"} {:args [["CharSequence" "str"] ["int" "start"] ["int" "end"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text. Note the returned TextBounds instance is reused.", :name ":get-bounds"} {:args [["CharSequence" "str"] ["int" "start"] ["int" "end"] ["BitmapFont.TextBounds" "text-bounds"]], :type "BitmapFont.TextBounds", :text "Returns the size of the specified string. The height is the distance from the top of most capital letters in the font (the\n {@link #getCapHeight() cap height}) to the baseline.", :name ":get-bounds"} {:args [], :type "BitmapFontCache", :text "For expert usage -- returns the BitmapFontCache used by this font, for rendering to a sprite batch. This can be used, for\n example, to manipulate glyph colors within a specific index.", :name ":get-cache"} {:args [], :type "float", :text "Returns the cap height, which is the distance from the top of most uppercase characters to the baseline. Since the drawing\n position is the cap height of the first line, the cap height can be used to get the location of the baseline.", :name ":get-cap-height"} {:args [], :type "Color", :text "Returns the color of this font. Changing the returned color will have no affect, {@link #setColor(Color)} or\n {@link #setColor(float, float, float, float)} must be used.", :name ":get-color"} {:args [], :type "BitmapFont.BitmapFontData", :text "Gets the underlying {@link BitmapFontData} for this BitmapFont.", :name ":get-data"} {:args [], :type "float", :text "Returns the descent, which is the distance from the bottom of the glyph that extends the lowest to the baseline. This number\n is negative.", :name ":get-descent"} {:args [], :type "float", :text "Returns the line height, which is the distance from one line of text to the next.", :name ":get-line-height"} {:args [["CharSequence" "str"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text, which may contain newlines.", :name ":get-multi-line-bounds"} {:args [["CharSequence" "str"] ["BitmapFont.TextBounds" "text-bounds"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text, which may contain newlines. The height is the distance from the top of most\n capital letters in the font (the {@link #getCapHeight() cap height}) to the baseline of the last line of text.", :name ":get-multi-line-bounds"} {:args [], :type "TextureRegion", :text "Returns the first texture region. This is included for backwards-compatibility, and for convenience since most fonts only\n use one texture page. For multi-page fonts, use getRegions().", :name ":get-region"} {:args [["int" "index"]], :type "TextureRegion", :text "Returns the texture page at the given index.", :name ":get-region"} {:args [], :type "TextureRegion", :text "Returns the array of TextureRegions that represents each texture page of glyphs.", :name ":get-regions"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :text "Returns the width of the space character.", :name ":get-space-width"} {:args [["CharSequence" "str"] ["float" "wrap-width"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text, which may contain newlines and is wrapped within the specified width.", :name ":get-wrapped-bounds"} {:args [["CharSequence" "str"] ["float" "wrap-width"] ["BitmapFont.TextBounds" "text-bounds"]], :type "BitmapFont.TextBounds", :text "Returns the bounds of the specified text, which may contain newlines and is wrapped within the specified width. The height\n is the distance from the top of most capital letters in the font (the {@link #getCapHeight() cap height}) to the baseline of\n the last line of text.", :name ":get-wrapped-bounds"} {:args [], :type "float", :text "Returns the x-height, which is the distance from the top of most lowercase characters to the baseline.", :name ":get-xheight"} {:args [], :type "boolean", :text "Returns true if this BitmapFont has been flipped for use with a y-down coordinate system.", :name ":is-flipped"} {:args [], :type "boolean", :name ":owns-texture"} {:args [["float" "amount"]], :text "Sets the font's scale relative to the current scale.", :name ":scale"} {:args [["float" "color"]], :name ":set-color"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["CharSequence" "glyphs"]], :text "Makes the specified glyphs fixed width. This can be useful to make the numbers in a font fixed width. Eg, when horizontally\n centering a score or loading percentage text, it will not jump around as different numbers are shown.", :name ":set-fixed-width-glyphs"} {:args [["boolean" "owns-texture"]], :text "Sets whether the font owns the texture or not. In case it does, the font will also dispose of the texture when\n {@link #dispose()} is called. Use with care!", :name ":set-owns-texture"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Scales the font by the specified amounts on both axes <br>\n <br>\n Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}. The\n default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.", :name ":set-scale"} {:args [["float" "scale-xy"]], :text "Scales the font by the specified amount in both directions.", :name ":set-scale"} {:args [["boolean" "integer"]], :text "Specifies whether to use integer positions or not. Default is to use them so filtering doesn't kick in as badly.", :name ":set-use-integer-positions"} {:args [], :type "boolean", :text "Checks whether this font uses integer positions for drawing.", :name ":uses-integer-positions"}]}]], :name "bitmap-font!", :type :code, :raw "(defmacro bitmap-font!\n  [object k & options]\n  `(u/call! ^BitmapFont ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>bitmap-font</code>.</p>"} {:raw* "(defn texture*\n  [arg]\n  (TextureEntity.\n    (cond\n      (string? arg)\n      (-> (or (u/load-asset arg Texture)\n              (Texture. ^String arg))\n          TextureRegion.)\n      (isa? (type arg) Pixmap)\n      (-> ^Pixmap arg Texture. TextureRegion.)\n      (isa? (type arg) TextureRegion)\n      arg\n      (:object arg)\n      (TextureRegion. ^TextureRegion (:object arg))\n      :else\n      (TextureRegion. arg))))", :arglists [(texture arg & options)], :java [["texture" {:text "Defines a rectangular area of a texture. The coordinate system used has its origin in the upper left corner with the x-axis\n pointing to the right and the y axis pointing downwards.", :items [{:args [["boolean" "x"] ["boolean" "y"]], :name ":flip"} {:args [], :type "int", :text "Returns the region's height.", :name ":get-region-height"} {:args [], :type "int", :text "Returns the region's width.", :name ":get-region-width"} {:args [], :type "int", :name ":get-region-x"} {:args [], :type "int", :name ":get-region-y"} {:args [], :type "Texture", :name ":get-texture"} {:args [], :type "float", :name ":get-u"} {:args [], :type "float", :name ":get-u2"} {:args [], :type "float", :name ":get-v"} {:args [], :type "float", :name ":get-v2"} {:args [], :type "boolean", :name ":is-flip-x"} {:args [], :type "boolean", :name ":is-flip-y"} {:args [["float" "x-amount"] ["float" "y-amount"]], :text "Offsets the region relative to the current region. Generally the region's size should be the entire size of the texture in\n the direction(s) it is scrolled.", :name ":scroll"} {:args [["Texture" "texture"]], :text "Sets the texture and sets the coordinates to the size of the specified texture.", :name ":set-region"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :name ":set-region"} {:args [["float" "u"] ["float" "v"] ["float" "u2"] ["float" "v2"]], :name ":set-region"} {:args [["TextureRegion" "region"]], :text "Sets the texture and coordinates to the specified region.", :name ":set-region"} {:args [["TextureRegion" "region"] ["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :text "Sets the texture to that of the specified region and sets the coordinates relative to the specified region.", :name ":set-region"} {:args [["int" "height"]], :name ":set-region-height"} {:args [["int" "width"]], :name ":set-region-width"} {:args [["int" "x"]], :name ":set-region-x"} {:args [["int" "y"]], :name ":set-region-y"} {:args [["Texture" "texture"]], :name ":set-texture"} {:args [["float" "u"]], :name ":set-u"} {:args [["float" "u2"]], :name ":set-u2"} {:args [["float" "v"]], :name ":set-v"} {:args [["float" "v2"]], :name ":set-v2"} {:args [["int" "tile-width"] ["int" "tile-height"]], :type "TextureRegion", :text "Helper function to create tiles out of this TextureRegion starting from the top left corner going to the right and ending at\n the bottom right corner. Only complete tiles will be returned so if the region's width or height are not a multiple of the\n tile width and height not all of the region will be used. This will not work on texture regions returned form a TextureAtlas\n that either have whitespace removed or where flipped before the region is split.", :name ":split"}]}]], :name "texture", :type :code, :raw "(defmacro texture\n  [arg & options]\n  `(let [entity# (texture* ~arg)]\n     (u/calls! ^TextureRegion (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/TextureRegion.html'>TextureRegion</a>.</p><pre>\n; load image.png\n&#40;texture &quot;image.png&quot;&#41;\n; load image.png, flip it, and only display the specified region\n&#40;texture &quot;image.png&quot;\n         :flip true false\n         :set-region 0 0 100 100&#41;\n; create a new texture based on an existing one\n&#40;texture &#40;texture &quot;image.png&quot;&#41;&#41;\n; rotate a texture 45 degress\n&#40;assoc &#40;texture &quot;image.png&quot;&#41;\n       :angle 45&#41;\n</pre>"} {:raw* nil, :arglists [(texture! entity k & options)], :java [["texture!" {:text "Defines a rectangular area of a texture. The coordinate system used has its origin in the upper left corner with the x-axis\n pointing to the right and the y axis pointing downwards.", :items [{:args [["boolean" "x"] ["boolean" "y"]], :name ":flip"} {:args [], :type "int", :text "Returns the region's height.", :name ":get-region-height"} {:args [], :type "int", :text "Returns the region's width.", :name ":get-region-width"} {:args [], :type "int", :name ":get-region-x"} {:args [], :type "int", :name ":get-region-y"} {:args [], :type "Texture", :name ":get-texture"} {:args [], :type "float", :name ":get-u"} {:args [], :type "float", :name ":get-u2"} {:args [], :type "float", :name ":get-v"} {:args [], :type "float", :name ":get-v2"} {:args [], :type "boolean", :name ":is-flip-x"} {:args [], :type "boolean", :name ":is-flip-y"} {:args [["float" "x-amount"] ["float" "y-amount"]], :text "Offsets the region relative to the current region. Generally the region's size should be the entire size of the texture in\n the direction(s) it is scrolled.", :name ":scroll"} {:args [["Texture" "texture"]], :text "Sets the texture and sets the coordinates to the size of the specified texture.", :name ":set-region"} {:args [["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :name ":set-region"} {:args [["float" "u"] ["float" "v"] ["float" "u2"] ["float" "v2"]], :name ":set-region"} {:args [["TextureRegion" "region"]], :text "Sets the texture and coordinates to the specified region.", :name ":set-region"} {:args [["TextureRegion" "region"] ["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :text "Sets the texture to that of the specified region and sets the coordinates relative to the specified region.", :name ":set-region"} {:args [["int" "height"]], :name ":set-region-height"} {:args [["int" "width"]], :name ":set-region-width"} {:args [["int" "x"]], :name ":set-region-x"} {:args [["int" "y"]], :name ":set-region-y"} {:args [["Texture" "texture"]], :name ":set-texture"} {:args [["float" "u"]], :name ":set-u"} {:args [["float" "u2"]], :name ":set-u2"} {:args [["float" "v"]], :name ":set-v"} {:args [["float" "v2"]], :name ":set-v2"} {:args [["int" "tile-width"] ["int" "tile-height"]], :type "TextureRegion", :text "Helper function to create tiles out of this TextureRegion starting from the top left corner going to the right and ending at\n the bottom right corner. Only complete tiles will be returned so if the region's width or height are not a multiple of the\n tile width and height not all of the region will be used. This will not work on texture regions returned form a TextureAtlas\n that either have whitespace removed or where flipped before the region is split.", :name ":split"}]}]], :name "texture!", :type :code, :raw "(defmacro texture!\n  [entity k & options]\n  `(u/call! ^TextureRegion (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>texture</code>.</p><pre>\n&#40;texture! entity :flip true false&#41;\n&#40;texture! entity :get-region-width&#41;\n</pre>"} {:raw* nil, :arglists [(texture? entity)], :java [], :name "texture?", :type :code, :raw "(defn texture?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) TextureRegion))", :docstring "<p>Returns true if <code>entity</code> is a <code>texture</code>.</p>"} {:raw* "(defn nine-patch*\n  [arg]\n  (NinePatchEntity.\n    (cond\n      (string? arg)\n      (-> (or (u/load-asset arg Texture)\n              (Texture. ^String arg))\n          TextureRegion.\n          NinePatch.)\n      (:object arg)\n      (NinePatch. (:object arg))\n      (map? arg)\n      (let [{:keys [region left right top bottom]} arg]\n        (NinePatch. region left right top bottom))\n      :else\n      arg)))", :arglists [(nine-patch arg & options)], :java [["nine-patch" {:text "A 3x3 grid of texture regions. Any of the regions may be omitted. Padding may be set as a hint on how to inset content on top\n of the ninepatch (by default the eight \"edge\" textures of the nine-patch define the padding). When drawn the eight \"edge\"\n patches will not be scaled, only the interior patch will be scaled.\n \n <p>\n <b>NOTE</b>: This class expects a \"post-processed\" nine-patch, and not a raw \".9.png\" texture. That is, the textures given to\n this class should <em>not</em> include the meta-data pixels from a \".9.png\" that describe the layout of the ninepatch over the\n interior of the graphic. That information should be passed into the constructor either implicitly as the size of the individual\n patch textures, or via the <code>left, right, top, bottom</code> parameters to {@link #NinePatch(Texture, int, int, int, int)}\n or {@link #NinePatch(TextureRegion, int, int, int, int)}.\n \n <p>\n A correctly created {@link TextureAtlas} is one way to generate a post-processed nine-patch from a \".9.png\" file.", :items [{:args [["Batch" "batch"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":draw"} {:args [], :type "float", :name ":get-bottom-height"} {:args [], :type "Color", :name ":get-color"} {:args [], :type "float", :name ":get-left-width"} {:args [], :type "float", :name ":get-middle-height"} {:args [], :type "float", :name ":get-middle-width"} {:args [], :type "float", :text "Returns the bottom padding if set, else returns {@link #getBottomHeight()}.", :name ":get-pad-bottom"} {:args [], :type "float", :text "Returns the left padding if set, else returns {@link #getLeftWidth()}.", :name ":get-pad-left"} {:args [], :type "float", :text "Returns the right padding if set, else returns {@link #getRightWidth()}.", :name ":get-pad-right"} {:args [], :type "float", :text "Returns the top padding if set, else returns {@link #getTopHeight()}.", :name ":get-pad-top"} {:args [], :type "float", :name ":get-right-width"} {:args [], :type "Texture", :name ":get-texture"} {:args [], :type "float", :name ":get-top-height"} {:args [], :type "float", :name ":get-total-height"} {:args [], :type "float", :name ":get-total-width"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Multiplies the top/left/bottom/right sizes and padding by the specified amount.", :name ":scale"} {:args [["float" "bottom-height"]], :text "Set the draw-time height of the three bottom edge patches", :name ":set-bottom-height"} {:args [["Color" "color"]], :text "Copy given color. The color will be blended with the batch color, then combined with the texture colors at\n {@link NinePatch#draw(Batch, float, float, float, float) draw} time. Default is {@link Color#WHITE}.", :name ":set-color"} {:args [["float" "left-width"]], :text "Set the draw-time width of the three left edge patches", :name ":set-left-width"} {:args [["float" "middle-height"]], :text "Set the height of the middle row of the patch. At render time, this is implicitly the requested render-height of the entire\n nine patch, minus the top and bottom height. This value is only used for computing the {@link #getTotalHeight() default\n total height}.", :name ":set-middle-height"} {:args [["float" "middle-width"]], :text "Set the width of the middle column of the patch. At render time, this is implicitly the requested render-width of the entire\n nine patch, minus the left and right width. This value is only used for computing the {@link #getTotalWidth() default total\n width}.", :name ":set-middle-width"} {:args [["int" "bottom"]], :text "See {@link #setPadding(int, int, int, int)}", :name ":set-pad-bottom"} {:args [["int" "left"]], :text "See {@link #setPadding(int, int, int, int)}", :name ":set-pad-left"} {:args [["int" "right"]], :text "See {@link #setPadding(int, int, int, int)}", :name ":set-pad-right"} {:args [["int" "top"]], :text "See {@link #setPadding(int, int, int, int)}", :name ":set-pad-top"} {:args [["int" "left"] ["int" "right"] ["int" "top"] ["int" "bottom"]], :text "Set the padding for content inside this ninepatch. By default the padding is set to match the exterior of the ninepatch, so\n the content should fit exactly within the middle patch.", :name ":set-padding"} {:args [["float" "right-width"]], :text "Set the draw-time width of the three right edge patches", :name ":set-right-width"} {:args [["float" "top-height"]], :text "Set the draw-time height of the three top edge patches", :name ":set-top-height"}]}]], :name "nine-patch", :type :code, :raw "(defmacro nine-patch\n  [arg & options]\n  `(let [entity# (nine-patch* ~arg)]\n     (u/calls! ^NinePatch (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/NinePatch.html'>NinePatch</a>.</p><pre>\n&#40;nine-patch &quot;image.png&quot;&#41;\n&#40;nine-patch &quot;image.png&quot; :set-color &#40;color :blue&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(nine-patch! entity k & options)], :java [["nine-patch!" {:text "A 3x3 grid of texture regions. Any of the regions may be omitted. Padding may be set as a hint on how to inset content on top\n of the ninepatch (by default the eight \"edge\" textures of the nine-patch define the padding). When drawn the eight \"edge\"\n patches will not be scaled, only the interior patch will be scaled.\n \n <p>\n <b>NOTE</b>: This class expects a \"post-processed\" nine-patch, and not a raw \".9.png\" texture. That is, the textures given to\n this class should <em>not</em> include the meta-data pixels from a \".9.png\" that describe the layout of the ninepatch over the\n interior of the graphic. That information should be passed into the constructor either implicitly as the size of the individual\n patch textures, or via the <code>left, right, top, bottom</code> parameters to {@link #NinePatch(Texture, int, int, int, int)}\n or {@link #NinePatch(TextureRegion, int, int, int, int)}.\n \n <p>\n A correctly created {@link TextureAtlas} is one way to generate a post-processed nine-patch from a \".9.png\" file.", :items [{:args [["Batch" "batch"] ["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :name ":draw"} {:args [], :type "float", :name ":get-bottom-height"} {:args [], :type "Color", :name ":get-color"} {:args [], :type "float", :name ":get-left-width"} {:args [], :type "float", :name ":get-middle-height"} {:args [], :type "float", :name ":get-middle-width"} {:args [], :type "float", :text "Returns the bottom padding if set, else returns {@link #getBottomHeight()}.", :name ":get-pad-bottom"} {:args [], :type "float", :text "Returns the left padding if set, else returns {@link #getLeftWidth()}.", :name ":get-pad-left"} {:args [], :type "float", :text "Returns the right padding if set, else returns {@link #getRightWidth()}.", :name ":get-pad-right"} {:args [], :type "float", :text "Returns the top padding if set, else returns {@link #getTopHeight()}.", :name ":get-pad-top"} {:args [], :type "float", :name ":get-right-width"} {:args [], :type "Texture", :name ":get-texture"} {:args [], :type "float", :name ":get-top-height"} {:args [], :type "float", :name ":get-total-height"} {:args [], :type "float", :name ":get-total-width"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Multiplies the top/left/bottom/right sizes and padding by the specified amount.", :name ":scale"} {:args [["float" "bottom-height"]], :text "Set the draw-time height of the three bottom edge patches", :name ":set-bottom-height"} {:args [["Color" "color"]], :text "Copy given color. The color will be blended with the batch color, then combined with the texture colors at\n {@link NinePatch#draw(Batch, float, float, float, float) draw} time. Default is {@link Color#WHITE}.", :name ":set-color"} {:args [["float" "left-width"]], :text "Set the draw-time width of the three left edge patches", :name ":set-left-width"} {:args [["float" "middle-height"]], :text "Set the height of the middle row of the patch. At render time, this is implicitly the requested render-height of the entire\n nine patch, minus the top and bottom height. This value is only used for computing the {@link #getTotalHeight() default\n total height}.", :name ":set-middle-height"} {:args [["float" "middle-width"]], :text "Set the width of the middle column of the patch. At render time, this is implicitly the requested render-width of the entire\n nine patch, minus the left and right width. This value is only used for computing the {@link #getTotalWidth() default total\n width}.", :name ":set-middle-width"} {:args [["int" "bottom"]], :text "See {@link #setPadding(int, int, int, int)}", :name ":set-pad-bottom"} {:args [["int" "left"]], :text "See {@link #setPadding(int, int, int, int)}", :name ":set-pad-left"} {:args [["int" "right"]], :text "See {@link #setPadding(int, int, int, int)}", :name ":set-pad-right"} {:args [["int" "top"]], :text "See {@link #setPadding(int, int, int, int)}", :name ":set-pad-top"} {:args [["int" "left"] ["int" "right"] ["int" "top"] ["int" "bottom"]], :text "Set the padding for content inside this ninepatch. By default the padding is set to match the exterior of the ninepatch, so\n the content should fit exactly within the middle patch.", :name ":set-padding"} {:args [["float" "right-width"]], :text "Set the draw-time width of the three right edge patches", :name ":set-right-width"} {:args [["float" "top-height"]], :text "Set the draw-time height of the three top edge patches", :name ":set-top-height"}]}]], :name "nine-patch!", :type :code, :raw "(defmacro nine-patch!\n  [entity k & options]\n  `(u/call! ^NinePatch (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>nine-patch</code>.</p><pre>\n&#40;nine-patch! entity :set-color &#40;color :blue&#41;&#41;\n&#40;nine-patch! entity :get-middle-width&#41;\n</pre>"} {:raw* nil, :arglists [(nine-patch? entity)], :java [], :name "nine-patch?", :type :code, :raw "(defn nine-patch?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) NinePatch))", :docstring "<p>Returns true if <code>entity</code> is a <code>nine-patch</code>.</p>"} {:raw* "(defn particle-effect*\n  [path]\n  (ParticleEffectEntity.\n    (if (nil? path)\n      (ParticleEffect.)\n      (let [^Files files (Gdx/files)\n            ^FileHandle fh (if (string? path)\n                             (.internal files path)\n                             path)]\n        (or (u/load-asset (.path fh) ParticleEffect)\n            (doto (ParticleEffect.)\n              (.load fh (.parent fh))))))))", :arglists [(particle-effect & [path & options])], :java [["particle-effect" {:text "See <a href=\"http://www.badlogicgames.com/wordpress/?p=1255\">http://www.badlogicgames.com/wordpress/?p=1255</a>", :items [{:args [], :name ":allow-completion"} {:args [], :text "Disposes the texture for each sprite for each ParticleEmitter.", :name ":dispose"} {:args [["Batch" "sprite-batch"]], :name ":draw"} {:args [["Batch" "sprite-batch"] ["float" "delta"]], :name ":draw"} {:args [["String" "name"]], :type "ParticleEmitter", :text "Returns the emitter with the specified name, or null.", :name ":find-emitter"} {:args [], :name ":flip-y"} {:args [], :type "BoundingBox", :text "Returns the bounding box for all active particles. z axis will always be zero.", :name ":get-bounding-box"} {:args [], :type "Array", :name ":get-emitters"} {:args [], :type "boolean", :name ":is-complete"} {:args [["FileHandle" "effect-file"] ["FileHandle" "images-dir"]], :name ":load"} {:args [["FileHandle" "effect-file"] ["TextureAtlas" "atlas"]], :name ":load"} {:args [["TextureAtlas" "atlas"]], :name ":load-emitter-images"} {:args [["FileHandle" "images-dir"]], :name ":load-emitter-images"} {:args [["FileHandle" "effect-file"]], :name ":load-emitters"} {:args [], :name ":reset"} {:args [["Writer" "output"]], :name ":save"} {:args [["int" "duration"]], :name ":set-duration"} {:args [["boolean" "flip-x"] ["boolean" "flip-y"]], :name ":set-flip"} {:args [["float" "x"] ["float" "y"]], :name ":set-position"} {:args [], :name ":start"} {:args [["float" "delta"]], :name ":update"}]}]], :name "particle-effect", :type :code, :raw "(defmacro particle-effect\n  [& [path & options]]\n  `(let [entity# (particle-effect* ~path)]\n     (u/calls! ^ParticleEffect (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/ParticleEffect.html'>ParticleEffect</a>.</p><pre>\n&#40;particle-effect&#41;\n&#40;particle-effect &quot;particles/fire.p&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(particle-effect! entity k & options)], :java [["particle-effect!" {:text "See <a href=\"http://www.badlogicgames.com/wordpress/?p=1255\">http://www.badlogicgames.com/wordpress/?p=1255</a>", :items [{:args [], :name ":allow-completion"} {:args [], :text "Disposes the texture for each sprite for each ParticleEmitter.", :name ":dispose"} {:args [["Batch" "sprite-batch"]], :name ":draw"} {:args [["Batch" "sprite-batch"] ["float" "delta"]], :name ":draw"} {:args [["String" "name"]], :type "ParticleEmitter", :text "Returns the emitter with the specified name, or null.", :name ":find-emitter"} {:args [], :name ":flip-y"} {:args [], :type "BoundingBox", :text "Returns the bounding box for all active particles. z axis will always be zero.", :name ":get-bounding-box"} {:args [], :type "Array", :name ":get-emitters"} {:args [], :type "boolean", :name ":is-complete"} {:args [["FileHandle" "effect-file"] ["FileHandle" "images-dir"]], :name ":load"} {:args [["FileHandle" "effect-file"] ["TextureAtlas" "atlas"]], :name ":load"} {:args [["TextureAtlas" "atlas"]], :name ":load-emitter-images"} {:args [["FileHandle" "images-dir"]], :name ":load-emitter-images"} {:args [["FileHandle" "effect-file"]], :name ":load-emitters"} {:args [], :name ":reset"} {:args [["Writer" "output"]], :name ":save"} {:args [["int" "duration"]], :name ":set-duration"} {:args [["boolean" "flip-x"] ["boolean" "flip-y"]], :name ":set-flip"} {:args [["float" "x"] ["float" "y"]], :name ":set-position"} {:args [], :name ":start"} {:args [["float" "delta"]], :name ":update"}]}]], :name "particle-effect!", :type :code, :raw "(defmacro particle-effect!\n  [entity k & options]\n  `(u/call! ^ParticleEffect (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>particle-effect</code>.</p><pre>\n&#40;particle-effect! entity :set-position 10 10&#41;\n</pre>"} {:raw* nil, :arglists [(particle-effect? entity)], :java [], :name "particle-effect?", :type :code, :raw "(defn particle-effect?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) ParticleEffect))", :docstring "<p>Returns true if <code>entity</code> is a <code>particle-effect</code>.</p>"} {:raw* "(defn texture-atlas*\n  [^String path]\n  (or (u/load-asset path TextureAtlas)\n      (TextureAtlas. path)))", :arglists [(texture-atlas path & options)], :java [["texture-atlas" {:text "Loads images from texture atlases created by TexturePacker.<br>\n <br>\n A TextureAtlas must be disposed to free up the resources consumed by the backing textures.", :items [{:args [["String" "name"] ["Texture" "texture"] ["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :type "TextureAtlas.AtlasRegion", :text "Adds a region to the atlas. The specified texture will be disposed when the atlas is disposed.", :name ":add-region"} {:args [["String" "name"] ["TextureRegion" "texture-region"]], :type "TextureAtlas.AtlasRegion", :text "Adds a region to the atlas. The texture for the specified region will be disposed when the atlas is disposed.", :name ":add-region"} {:args [["String" "name"]], :type "NinePatch", :text "Returns the first region found with the specified name as a {@link NinePatch}. The region must have been packed with\n ninepatch splits. This method uses string comparison to find the region and constructs a new ninepatch, so the result should\n be cached rather than calling this method multiple times.", :name ":create-patch"} {:args [["String" "name"]], :type "Sprite", :text "Returns the first region found with the specified name as a sprite. If whitespace was stripped from the region when it was\n packed, the sprite is automatically positioned as if whitespace had not been stripped. This method uses string comparison to\n find the region and constructs a new sprite, so the result should be cached rather than calling this method multiple times.", :name ":create-sprite"} {:args [["String" "name"] ["int" "index"]], :type "Sprite", :text "Returns the first region found with the specified name and index as a sprite. This method uses string comparison to find the\n region and constructs a new sprite, so the result should be cached rather than calling this method multiple times.", :name ":create-sprite"} {:args [], :type "Array", :text "Returns all regions in the atlas as sprites. This method creates a new sprite for each region, so the result should be\n stored rather than calling this method multiple times.", :name ":create-sprites"} {:args [["String" "name"]], :type "Array", :text "Returns all regions with the specified name as sprites, ordered by smallest to largest {@link AtlasRegion#index index}. This\n method uses string comparison to find the regions and constructs new sprites, so the result should be cached rather than\n calling this method multiple times.", :name ":create-sprites"} {:args [], :text "Releases all resources associated with this TextureAtlas instance. This releases all the textures backing all TextureRegions\n and Sprites, which should no longer be used after calling dispose.", :name ":dispose"} {:args [["String" "name"]], :type "TextureAtlas.AtlasRegion", :text "Returns the first region found with the specified name. This method uses string comparison to find the region, so the result\n should be cached rather than calling this method multiple times.", :name ":find-region"} {:args [["String" "name"] ["int" "index"]], :type "TextureAtlas.AtlasRegion", :text "Returns the first region found with the specified name and index. This method uses string comparison to find the region, so\n the result should be cached rather than calling this method multiple times.", :name ":find-region"} {:args [["String" "name"]], :type "Array", :text "Returns all regions with the specified name, ordered by smallest to largest {@link AtlasRegion#index index}. This method\n uses string comparison to find the regions, so the result should be cached rather than calling this method multiple times.", :name ":find-regions"} {:args [], :type "Array", :text "Returns all regions in the atlas.", :name ":get-regions"} {:args [], :type "ObjectSet", :name ":get-textures"}]}]], :name "texture-atlas", :type :code, :raw "(defmacro texture-atlas\n  [path & options]\n  `(let [^TextureAtlas object# (texture-atlas* path)]\n     (u/calls! object# ~@options)\n     object#))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/TextureAtlas.html'>TextureAtlas</a>.</p><pre>\n&#40;texture-atlas &quot;packed.txt&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(texture-atlas! object k & options)], :java [["texture-atlas!" {:text "Loads images from texture atlases created by TexturePacker.<br>\n <br>\n A TextureAtlas must be disposed to free up the resources consumed by the backing textures.", :items [{:args [["String" "name"] ["Texture" "texture"] ["int" "x"] ["int" "y"] ["int" "width"] ["int" "height"]], :type "TextureAtlas.AtlasRegion", :text "Adds a region to the atlas. The specified texture will be disposed when the atlas is disposed.", :name ":add-region"} {:args [["String" "name"] ["TextureRegion" "texture-region"]], :type "TextureAtlas.AtlasRegion", :text "Adds a region to the atlas. The texture for the specified region will be disposed when the atlas is disposed.", :name ":add-region"} {:args [["String" "name"]], :type "NinePatch", :text "Returns the first region found with the specified name as a {@link NinePatch}. The region must have been packed with\n ninepatch splits. This method uses string comparison to find the region and constructs a new ninepatch, so the result should\n be cached rather than calling this method multiple times.", :name ":create-patch"} {:args [["String" "name"]], :type "Sprite", :text "Returns the first region found with the specified name as a sprite. If whitespace was stripped from the region when it was\n packed, the sprite is automatically positioned as if whitespace had not been stripped. This method uses string comparison to\n find the region and constructs a new sprite, so the result should be cached rather than calling this method multiple times.", :name ":create-sprite"} {:args [["String" "name"] ["int" "index"]], :type "Sprite", :text "Returns the first region found with the specified name and index as a sprite. This method uses string comparison to find the\n region and constructs a new sprite, so the result should be cached rather than calling this method multiple times.", :name ":create-sprite"} {:args [], :type "Array", :text "Returns all regions in the atlas as sprites. This method creates a new sprite for each region, so the result should be\n stored rather than calling this method multiple times.", :name ":create-sprites"} {:args [["String" "name"]], :type "Array", :text "Returns all regions with the specified name as sprites, ordered by smallest to largest {@link AtlasRegion#index index}. This\n method uses string comparison to find the regions and constructs new sprites, so the result should be cached rather than\n calling this method multiple times.", :name ":create-sprites"} {:args [], :text "Releases all resources associated with this TextureAtlas instance. This releases all the textures backing all TextureRegions\n and Sprites, which should no longer be used after calling dispose.", :name ":dispose"} {:args [["String" "name"]], :type "TextureAtlas.AtlasRegion", :text "Returns the first region found with the specified name. This method uses string comparison to find the region, so the result\n should be cached rather than calling this method multiple times.", :name ":find-region"} {:args [["String" "name"] ["int" "index"]], :type "TextureAtlas.AtlasRegion", :text "Returns the first region found with the specified name and index. This method uses string comparison to find the region, so\n the result should be cached rather than calling this method multiple times.", :name ":find-region"} {:args [["String" "name"]], :type "Array", :text "Returns all regions with the specified name, ordered by smallest to largest {@link AtlasRegion#index index}. This method\n uses string comparison to find the regions, so the result should be cached rather than calling this method multiple times.", :name ":find-regions"} {:args [], :type "Array", :text "Returns all regions in the atlas.", :name ":get-regions"} {:args [], :type "ObjectSet", :name ":get-textures"}]}]], :name "texture-atlas!", :type :code, :raw "(defmacro texture-atlas!\n  [object k & options]\n  `(u/call! ^TextureAtlas ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>texture-atlas</code>.</p><pre>\n&#40;texture-atlas! object :create-patch &quot;test&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(play-mode k)], :java [["play-mode" {:text "Defines possible playback modes for an {@link Animation}.", :items [{:name ":loop"} {:name ":loop-pingpong"} {:name ":loop-random"} {:name ":loop-reversed"} {:name ":normal"} {:name ":reversed"}]}]], :name "play-mode", :type :code, :raw "(defmacro play-mode\n  [k]\n  `~(u/gdx-field :graphics :g2d \"Animation$PlayMode\" (u/key->upper k)))", :docstring "<p>Returns a static field from <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/Animation.PlayMode.html'>Animation.PlayMode</a>.</p><pre>\n&#40;play-mode :loop&#41;\n</pre>"} {:raw* "(defn animation*\n  [duration textures]\n  (Animation. duration\n              (u/gdx-array (map #(u/get-obj % :object) textures))\n              (play-mode :normal)))", :arglists [(animation duration textures & options)], :java [["animation" {:text "<p>\n An Animation stores a list of {@link TextureRegion}s representing an animated sequence, e.g. for running or jumping. Each\n region of an Animation is called a key frame, multiple key frames make up the animation.\n </p>", :items [{:args [["float" "state-time"] ["boolean" "looping"]], :type "TextureRegion", :text "Returns a {@link TextureRegion} based on the so called state time. This is the amount of seconds an object has spent in the\n state this Animation instance represents, e.g. running, jumping and so on. The mode specifies whether the animation is\n looping or not.", :name ":get-key-frame"} {:args [["float" "state-time"]], :type "TextureRegion", :text "Returns a {@link TextureRegion} based on the so called state time. This is the amount of seconds an object has spent in the\n state this Animation instance represents, e.g. running, jumping and so on using the mode specified by\n {@link #setPlayMode(PlayMode)} method.", :name ":get-key-frame"} {:args [["float" "state-time"]], :type "int", :text "Returns the current frame number.", :name ":get-key-frame-index"} {:args [], :type "TextureRegion", :text "Returns the keyFrames[] array where all the TextureRegions of the animation are stored.", :name ":get-key-frames"} {:args [], :type "Animation.PlayMode", :text "Returns the animation play mode.", :name ":get-play-mode"} {:args [["float" "state-time"]], :type "boolean", :text "Whether the animation would be finished if played without looping (PlayMode#NORMAL), given the state time.", :name ":is-animation-finished"} {:args [["Animation.PlayMode" "play-mode"]], :text "Sets the animation play mode.", :name ":set-play-mode"}]}]], :name "animation", :type :code, :raw "(defmacro animation\n  [duration textures & options]\n  `(u/calls! ^Animation (animation* ~duration ~textures) ~@options))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/Animation.html'>Animation</a>.</p><pre>\n&#40;animation 0.2\n           &#91;walk-1 walk-2 walk-3&#93;\n           :set-play-mode &#40;play-mode :loop-pingpong&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(animation! object k & options)], :java [["animation!" {:text "<p>\n An Animation stores a list of {@link TextureRegion}s representing an animated sequence, e.g. for running or jumping. Each\n region of an Animation is called a key frame, multiple key frames make up the animation.\n </p>", :items [{:args [["float" "state-time"] ["boolean" "looping"]], :type "TextureRegion", :text "Returns a {@link TextureRegion} based on the so called state time. This is the amount of seconds an object has spent in the\n state this Animation instance represents, e.g. running, jumping and so on. The mode specifies whether the animation is\n looping or not.", :name ":get-key-frame"} {:args [["float" "state-time"]], :type "TextureRegion", :text "Returns a {@link TextureRegion} based on the so called state time. This is the amount of seconds an object has spent in the\n state this Animation instance represents, e.g. running, jumping and so on using the mode specified by\n {@link #setPlayMode(PlayMode)} method.", :name ":get-key-frame"} {:args [["float" "state-time"]], :type "int", :text "Returns the current frame number.", :name ":get-key-frame-index"} {:args [], :type "TextureRegion", :text "Returns the keyFrames[] array where all the TextureRegions of the animation are stored.", :name ":get-key-frames"} {:args [], :type "Animation.PlayMode", :text "Returns the animation play mode.", :name ":get-play-mode"} {:args [["float" "state-time"]], :type "boolean", :text "Whether the animation would be finished if played without looping (PlayMode#NORMAL), given the state time.", :name ":is-animation-finished"} {:args [["Animation.PlayMode" "play-mode"]], :text "Sets the animation play mode.", :name ":set-play-mode"}]}]], :name "animation!", :type :code, :raw "(defmacro animation!\n  [object k & options]\n  `(u/call! ^Animation ~object ~k ~@options))", :docstring "<p>Calls a single method on an <code>animation</code>.</p><pre>\n&#40;animation! object :set-play-mode &#40;play-mode :loop&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(animation->texture screen animation) (animation->texture screen animation is-looping?)], :java [], :name "animation->texture", :type :code, :raw "(defn animation->texture\n  ([{:keys [total-time] :as screen} ^Animation animation]\n    (texture* (.getKeyFrame animation total-time true)))\n  ([{:keys [total-time] :as screen} ^Animation animation is-looping?]\n    (texture* (.getKeyFrame animation total-time is-looping?))))", :docstring "<p>Returns a <code>texture</code> entity with a frame from <code>animation</code> based on the total time the <code>screen</code> has been showing.</p><pre>\n&#40;animation-&gt;texture screen anim&#41;\n</pre>"})} {:ns "play-clj.g2d-physics", :groups ({:raw* "(defn box-2d*\n  ([]\n    (box-2d* 0 0 true))\n  ([gravity-x gravity-y]\n    (box-2d* gravity-x gravity-y true))\n  ([gravity-x gravity-y sleep?]\n    ; use reflection to instantiate in order to avoid the static initializer\n    (some-> (try (Class/forName \"com.badlogic.gdx.physics.box2d.World\")\n              (catch Exception _))\n            .getDeclaredConstructors\n            first\n            (.newInstance\n              (object-array [(m/vector-2 gravity-x gravity-y) sleep?])))))", :arglists [(box-2d gravity-x gravity-y & options)], :java [["box-2d" {:text "The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient\n memory management facilities.", :items [{:args [], :text "Manually clear the force buffer on all bodies. By default, forces are cleared automatically after each call to Step. The\n default behavior is modified by calling SetAutoClearForces. The purpose of this function is to support sub-stepping.\n Sub-stepping is often used to maintain a fixed sized time step under a variable frame-rate. When you perform sub-stepping\n you will disable auto clearing of forces and instead call ClearForces after all sub-steps are complete in one pass of your\n game loop. {@link #setAutoClearForces(boolean)}", :name ":clear-forces"} {:args [["BodyDef" "def"]], :type "Body", :text "Create a rigid body given a definition. No reference to the definition is retained.\n Bodies created by this method are pooled internally by the World object.\n They will be freed upon calling {@link World#destroyBody(Body)}", :name ":create-body"} {:args [["JointDef" "def"]], :type "Joint", :text "Create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected bodies\n to cease colliding.", :name ":create-joint"} {:args [["Body" "body"]], :text "Destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during\n callbacks.", :name ":destroy-body"} {:args [["Joint" "joint"]], :text "Destroy a joint. This may cause the connected bodies to begin colliding.", :name ":destroy-joint"} {:args [], :name ":dispose"} {:args [], :type "boolean", :text "Get the flag that controls automatic clearing of forces after each time step.", :name ":get-auto-clear-forces"} {:args [["com.badlogic.gdx.utils.Array" "bodies"]], :name ":get-bodies"} {:args [], :type "int", :text "Get the number of bodies.", :name ":get-body-count"} {:args [], :type "int", :text "Get the number of contacts (each may have 0 or more contact points).", :name ":get-contact-count"} {:args [], :type "Array", :text "Returns the list of {@link Contact} instances produced by the last call to {@link #step(float, int, int)}. Note that the\n returned list will have O(1) access times when using indexing. contacts are created and destroyed in the middle of a time\n step. Use {@link ContactListener} to avoid missing contacts", :name ":get-contact-list"} {:args [], :type "Vector2", :name ":get-gravity"} {:args [], :type "int", :text "Get the number of joints.", :name ":get-joint-count"} {:args [["com.badlogic.gdx.utils.Array" "joints"]], :name ":get-joints"} {:args [], :type "int", :text "Get the number of broad-phase proxies.", :name ":get-proxy-count"} {:args [], :type "boolean", :text "Is the world locked (in the middle of a time step).", :name ":is-locked"} {:args [["QueryCallback" "callback"] ["float" "lower-x"] ["float" "lower-y"] ["float" "upper-x"] ["float" "upper-y"]], :text "Query the world for all fixtures that potentially overlap the provided AABB.", :name ":query-aabb"} {:args [["RayCastCallback" "callback"] ["Vector2" "point1"] ["Vector2" "point2"]], :text "Ray-cast the world for all fixtures in the path of the ray. The ray-cast ignores shapes that contain the starting point.", :name ":ray-cast"} {:args [["boolean" "flag"]], :text "Set flag to control automatic clearing of forces after each time step.", :name ":set-auto-clear-forces"} {:args [["ContactFilter" "filter"]], :text "Register a contact filter to provide specific control over collision. Otherwise the default filter is used\n (b2_defaultFilter). The listener is owned by you and must remain in scope.", :name ":set-contact-filter"} {:args [["ContactListener" "listener"]], :text "Register a contact event listener. The listener is owned by you and must remain in scope.", :name ":set-contact-listener"} {:args [["boolean" "flag"]], :text "Enable/disable continuous physics. For testing.", :name ":set-continuous-physics"} {:args [["DestructionListener" "listener"]], :text "Register a destruction listener. The listener is owned by you and must remain in scope.", :name ":set-destruction-listener"} {:args [["Vector2" "gravity"]], :text "Change the global gravity vector.", :name ":set-gravity"} {:args [["boolean" "flag"]], :text "Enable/disable warm starting. For testing.", :name ":set-warm-starting"} {:args [["float" "time-step"] ["int" "velocity-iterations"] ["int" "position-iterations"]], :text "Take a time step. This performs collision detection, integration, and constraint solution.", :name ":step"}]}]], :name "box-2d", :type :code, :raw "(defmacro box-2d\n  [gravity-x gravity-y & options]\n  `(let [object# (box-2d* ~gravity-x ~gravity-y)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/World.html'>World</a>.</p><pre>\n&#40;box-2d 0 0&#41;\n</pre>"} {:raw* nil, :arglists [(box-2d! screen k & options)], :java [["box-2d!" {:text "The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient\n memory management facilities.", :items [{:args [], :text "Manually clear the force buffer on all bodies. By default, forces are cleared automatically after each call to Step. The\n default behavior is modified by calling SetAutoClearForces. The purpose of this function is to support sub-stepping.\n Sub-stepping is often used to maintain a fixed sized time step under a variable frame-rate. When you perform sub-stepping\n you will disable auto clearing of forces and instead call ClearForces after all sub-steps are complete in one pass of your\n game loop. {@link #setAutoClearForces(boolean)}", :name ":clear-forces"} {:args [["BodyDef" "def"]], :type "Body", :text "Create a rigid body given a definition. No reference to the definition is retained.\n Bodies created by this method are pooled internally by the World object.\n They will be freed upon calling {@link World#destroyBody(Body)}", :name ":create-body"} {:args [["JointDef" "def"]], :type "Joint", :text "Create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected bodies\n to cease colliding.", :name ":create-joint"} {:args [["Body" "body"]], :text "Destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during\n callbacks.", :name ":destroy-body"} {:args [["Joint" "joint"]], :text "Destroy a joint. This may cause the connected bodies to begin colliding.", :name ":destroy-joint"} {:args [], :name ":dispose"} {:args [], :type "boolean", :text "Get the flag that controls automatic clearing of forces after each time step.", :name ":get-auto-clear-forces"} {:args [["com.badlogic.gdx.utils.Array" "bodies"]], :name ":get-bodies"} {:args [], :type "int", :text "Get the number of bodies.", :name ":get-body-count"} {:args [], :type "int", :text "Get the number of contacts (each may have 0 or more contact points).", :name ":get-contact-count"} {:args [], :type "Array", :text "Returns the list of {@link Contact} instances produced by the last call to {@link #step(float, int, int)}. Note that the\n returned list will have O(1) access times when using indexing. contacts are created and destroyed in the middle of a time\n step. Use {@link ContactListener} to avoid missing contacts", :name ":get-contact-list"} {:args [], :type "Vector2", :name ":get-gravity"} {:args [], :type "int", :text "Get the number of joints.", :name ":get-joint-count"} {:args [["com.badlogic.gdx.utils.Array" "joints"]], :name ":get-joints"} {:args [], :type "int", :text "Get the number of broad-phase proxies.", :name ":get-proxy-count"} {:args [], :type "boolean", :text "Is the world locked (in the middle of a time step).", :name ":is-locked"} {:args [["QueryCallback" "callback"] ["float" "lower-x"] ["float" "lower-y"] ["float" "upper-x"] ["float" "upper-y"]], :text "Query the world for all fixtures that potentially overlap the provided AABB.", :name ":query-aabb"} {:args [["RayCastCallback" "callback"] ["Vector2" "point1"] ["Vector2" "point2"]], :text "Ray-cast the world for all fixtures in the path of the ray. The ray-cast ignores shapes that contain the starting point.", :name ":ray-cast"} {:args [["boolean" "flag"]], :text "Set flag to control automatic clearing of forces after each time step.", :name ":set-auto-clear-forces"} {:args [["ContactFilter" "filter"]], :text "Register a contact filter to provide specific control over collision. Otherwise the default filter is used\n (b2_defaultFilter). The listener is owned by you and must remain in scope.", :name ":set-contact-filter"} {:args [["ContactListener" "listener"]], :text "Register a contact event listener. The listener is owned by you and must remain in scope.", :name ":set-contact-listener"} {:args [["boolean" "flag"]], :text "Enable/disable continuous physics. For testing.", :name ":set-continuous-physics"} {:args [["DestructionListener" "listener"]], :text "Register a destruction listener. The listener is owned by you and must remain in scope.", :name ":set-destruction-listener"} {:args [["Vector2" "gravity"]], :text "Change the global gravity vector.", :name ":set-gravity"} {:args [["boolean" "flag"]], :text "Enable/disable warm starting. For testing.", :name ":set-warm-starting"} {:args [["float" "time-step"] ["int" "velocity-iterations"] ["int" "position-iterations"]], :text "Take a time step. This performs collision detection, integration, and constraint solution.", :name ":step"}]}]], :name "box-2d!", :type :code, :raw "(defmacro box-2d!\n  [screen k & options]\n  `(let [object# (u/get-obj ~screen :world)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>box-2d</code>.</p>"} {:raw* nil, :arglists [(body-def k & options)], :java [["body-def" {:text "A body definition holds all the data needed to construct a rigid body. You can safely re-use body definitions. Shapes are added\n to a body after construction.", :items [{:args [["boolean" "value"]], :text "Does this body start out active?", :name ":active"} {:args [["boolean" "value"]], :text "Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.", :name ":allow-sleep"} {:args [["float" "value"]], :text "The world angle of the body in radians.", :name ":angle"} {:args [["float" "value"]], :text "Angular damping is use to reduce the angular velocity. The damping parameter can be larger than 1.0f but the damping effect\n becomes sensitive to the time step when the damping parameter is large.", :name ":angular-damping"} {:args [["float" "value"]], :text "The angular velocity of the body.", :name ":angular-velocity"} {:args [["boolean" "value"]], :text "Is this body initially awake or sleeping?", :name ":awake"} {:args [["boolean" "value"]], :text "Is this a fast moving body that should be prevented from tunneling through other moving bodies? Note that all bodies are\n prevented from tunneling through kinematic and static bodies. This setting is only considered on dynamic bodies.", :name ":bullet"} {:args [["boolean" "value"]], :text "Should this body be prevented from rotating? Useful for characters.", :name ":fixed-rotation"} {:args [["float" "value"]], :text "Scale the gravity applied to this body.", :name ":gravity-scale"} {:args [["float" "value"]], :text "Linear damping is use to reduce the linear velocity. The damping parameter can be larger than 1.0f but the damping effect\n becomes sensitive to the time step when the damping parameter is large.", :name ":linear-damping"} {:args [["Vector2" "value"]], :text "The linear velocity of the body's origin in world co-ordinates.", :name ":linear-velocity"} {:args [["Vector2" "value"]], :text "The world position of the body. Avoid creating bodies at the origin since this can lead to many overlapping shapes.", :name ":position"} {:args [["BodyDef.BodyType" "value"]], :text "The body type: static, kinematic, or dynamic. Note: if a dynamic body would have zero mass, the mass is set to one.", :name ":type"}]}]], :name "body-def", :type :code, :raw "(defmacro body-def\n  [k & options]\n  `(let [^BodyDef object# (BodyDef.)]\n     (u/fields! object# :type ~(body-type k) ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/BodyDef.html'>BodyDef</a>.</p><pre>\n&#40;body-def :dynamic&#41;\n</pre>"} {:raw* nil, :arglists [(body! entity k & options)], :java [["body!" {:text "A rigid body. These are created via World.CreateBody.", :items [{:args [["float" "impulse"] ["boolean" "wake"]], :text "Apply an angular impulse.", :name ":apply-angular-impulse"} {:args [["Vector2" "force"] ["Vector2" "point"] ["boolean" "wake"]], :text "Apply a force at a world point. If the force is not applied at the center of mass, it will generate a torque and affect the\n angular velocity. This wakes up the body.", :name ":apply-force"} {:args [["float" "force-x"] ["float" "force-y"] ["float" "point-x"] ["float" "point-y"] ["boolean" "wake"]], :text "Apply a force at a world point. If the force is not applied at the center of mass, it will generate a torque and affect the\n angular velocity. This wakes up the body.", :name ":apply-force"} {:args [["Vector2" "force"] ["boolean" "wake"]], :text "Apply a force to the center of mass. This wakes up the body.", :name ":apply-force-to-center"} {:args [["float" "force-x"] ["float" "force-y"] ["boolean" "wake"]], :text "Apply a force to the center of mass. This wakes up the body.", :name ":apply-force-to-center"} {:args [["Vector2" "impulse"] ["Vector2" "point"] ["boolean" "wake"]], :text "Apply an impulse at a point. This immediately modifies the velocity. It also modifies the angular velocity if the point of\n application is not at the center of mass. This wakes up the body.", :name ":apply-linear-impulse"} {:args [["float" "impulse-x"] ["float" "impulse-y"] ["float" "point-x"] ["float" "point-y"] ["boolean" "wake"]], :text "Apply an impulse at a point. This immediately modifies the velocity. It also modifies the angular velocity if the point of\n application is not at the center of mass. This wakes up the body.", :name ":apply-linear-impulse"} {:args [["float" "torque"] ["boolean" "wake"]], :text "Apply a torque. This affects the angular velocity without affecting the linear velocity of the center of mass. This wakes up\n the body.", :name ":apply-torque"} {:args [["FixtureDef" "def"]], :type "Fixture", :text "Creates a fixture and attach it to this body. Use this function if you need to set some fixture parameters, like friction.\n Otherwise you can create the fixture directly from a shape. If the density is non-zero, this function automatically updates\n the mass of the body. Contacts are not created until the next time step.", :name ":create-fixture"} {:args [["Shape" "shape"] ["float" "density"]], :type "Fixture", :text "Creates a fixture from a shape and attach it to this body. This is a convenience function. Use b2FixtureDef if you need to\n set parameters like friction, restitution, user data, or filtering. If the density is non-zero, this function automatically\n updates the mass of the body.", :name ":create-fixture"} {:args [["Fixture" "fixture"]], :text "Destroy a fixture. This removes the fixture from the broad-phase and destroys all contacts associated with this fixture.\n This will automatically adjust the mass of the body if the body is dynamic and the fixture has positive density. All\n fixtures attached to a body are implicitly destroyed when the body is destroyed.", :name ":destroy-fixture"} {:args [], :type "float", :text "Get the angle in radians.", :name ":get-angle"} {:args [], :type "float", :text "Get the angular damping of the body.", :name ":get-angular-damping"} {:args [], :type "float", :text "Get the angular velocity.", :name ":get-angular-velocity"} {:args [], :type "Array", :text "Get the list of all fixtures attached to this body. Do not modify the list!", :name ":get-fixture-list"} {:args [], :type "float", :name ":get-gravity-scale"} {:args [], :type "float", :text "Get the rotational inertia of the body about the local origin.", :name ":get-inertia"} {:args [], :type "Array", :text "Get the list of all joints attached to this body. Do not modify the list!", :name ":get-joint-list"} {:args [], :type "float", :text "Get the linear damping of the body.", :name ":get-linear-damping"} {:args [], :type "Vector2", :text "Get the linear velocity of the center of mass.", :name ":get-linear-velocity"} {:args [["Vector2" "local-point"]], :type "Vector2", :text "Get the world velocity of a local point.", :name ":get-linear-velocity-from-local-point"} {:args [["Vector2" "world-point"]], :type "Vector2", :text "Get the world linear velocity of a world point attached to this body.", :name ":get-linear-velocity-from-world-point"} {:args [], :type "Vector2", :text "Get the local position of the center of mass.", :name ":get-local-center"} {:args [["Vector2" "world-point"]], :type "Vector2", :text "Gets a local point relative to the body's origin given a world point.", :name ":get-local-point"} {:args [["Vector2" "world-vector"]], :type "Vector2", :text "Gets a local vector given a world vector.", :name ":get-local-vector"} {:args [], :type "float", :text "Get the total mass of the body.", :name ":get-mass"} {:args [], :type "MassData", :text "Get the mass data of the body.", :name ":get-mass-data"} {:args [], :type "Vector2", :text "Get the world body origin position.", :name ":get-position"} {:args [], :type "Transform", :text "Get the body transform for the body's origin.", :name ":get-transform"} {:args [], :type "BodyDef.BodyType", :text "Get the type of this body.", :name ":get-type"} {:args [], :type "Object", :text "Get the user data", :name ":get-user-data"} {:args [], :type "World", :text "Get the parent world of this body.", :name ":get-world"} {:args [], :type "Vector2", :text "Get the world position of the center of mass.", :name ":get-world-center"} {:args [["Vector2" "local-point"]], :type "Vector2", :text "Get the world coordinates of a point given the local coordinates.", :name ":get-world-point"} {:args [["Vector2" "local-vector"]], :type "Vector2", :text "Get the world coordinates of a vector given the local coordinates.", :name ":get-world-vector"} {:args [], :type "boolean", :text "Get the active state of the body.", :name ":is-active"} {:args [], :type "boolean", :text "Get the sleeping state of this body.", :name ":is-awake"} {:args [], :type "boolean", :text "Is this body treated like a bullet for continuous collision detection?", :name ":is-bullet"} {:args [], :type "boolean", :text "Does this body have fixed rotation?", :name ":is-fixed-rotation"} {:args [], :type "boolean", :text "Is this body allowed to sleep", :name ":is-sleeping-allowed"} {:args [], :text "This resets the mass properties to the sum of the mass properties of the fixtures. This normally does not need to be called\n unless you called SetMassData to override the mass and you later want to reset the mass.", :name ":reset-mass-data"} {:args [["boolean" "flag"]], :text "Set the active state of the body. An inactive body is not simulated and cannot be collided with or woken up. If you pass a\n flag of true, all fixtures will be added to the broad-phase. If you pass a flag of false, all fixtures will be removed from\n the broad-phase and all contacts will be destroyed. Fixtures and joints are otherwise unaffected. You may continue to\n create/destroy fixtures and joints on inactive bodies. Fixtures on an inactive body are implicitly inactive and will not\n participate in collisions, ray-casts, or queries. Joints connected to an inactive body are implicitly inactive. An inactive\n body is still owned by a b2World object and remains in the body list.", :name ":set-active"} {:args [["float" "angular-damping"]], :text "Set the angular damping of the body.", :name ":set-angular-damping"} {:args [["float" "omega"]], :text "Set the angular velocity.", :name ":set-angular-velocity"} {:args [["boolean" "flag"]], :text "Set the sleep state of the body. A sleeping body has very low CPU cost.", :name ":set-awake"} {:args [["boolean" "flag"]], :text "Should this body be treated like a bullet for continuous collision detection?", :name ":set-bullet"} {:args [["boolean" "flag"]], :text "Set this body to have fixed rotation. This causes the mass to be reset.", :name ":set-fixed-rotation"} {:args [["float" "scale"]], :text "Sets the gravity scale of the body", :name ":set-gravity-scale"} {:args [["float" "linear-damping"]], :text "Set the linear damping of the body.", :name ":set-linear-damping"} {:args [["Vector2" "v"]], :text "Set the linear velocity of the center of mass.", :name ":set-linear-velocity"} {:args [["float" "v-x"] ["float" "v-y"]], :text "Set the linear velocity of the center of mass.", :name ":set-linear-velocity"} {:args [["MassData" "data"]], :text "Set the mass properties to override the mass properties of the fixtures. Note that this changes the center of mass position.\n Note that creating or destroying fixtures can also alter the mass. This function has no effect if the body isn't dynamic.", :name ":set-mass-data"} {:args [["boolean" "flag"]], :text "You can disable sleeping on this body. If you disable sleeping, the", :name ":set-sleeping-allowed"} {:args [["Vector2" "position"] ["float" "angle"]], :text "Set the position of the body's origin and rotation. This breaks any contacts and wakes the other bodies. Manipulating a\n body's transform may cause non-physical behavior.", :name ":set-transform"} {:args [["float" "x"] ["float" "y"] ["float" "angle"]], :text "Set the position of the body's origin and rotation. This breaks any contacts and wakes the other bodies. Manipulating a\n body's transform may cause non-physical behavior.", :name ":set-transform"} {:args [["BodyDef.BodyType" "type"]], :text "Set the type of this body. This may alter the mass and velocity.", :name ":set-type"} {:args [["Object" "user-data"]], :text "Set the user data", :name ":set-user-data"}]}]], :name "body!", :type :code, :raw "(defmacro body!\n  [entity k & options]\n  `(let [^Body object# (u/get-obj ~entity :body)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a body.</p>"} {:raw* nil, :arglists [(add-body! screen b-def)], :java [], :name "add-body!", :type :code, :raw "(defn add-body!\n  [screen b-def]\n  (box-2d! screen :create-body b-def))", :docstring "<p>Creates a body from <code>b-def</code>, adds it to the <code>screen</code> and returns it.</p><pre>\n&#40;add-body! screen &#40;body-def :dynamic&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(body-position! entity x y angle)], :java [], :name "body-position!", :type :code, :raw "(defn body-position!\n  [entity x y angle]\n  (body! entity :set-transform x y (* angle MathUtils/degreesToRadians)))", :docstring "<p>Changes the position of the body in <code>entity</code>. The angle is in degrees.</p>"} {:raw* nil, :arglists [(body-x! entity x)], :java [], :name "body-x!", :type :code, :raw "(defn body-x!\n  [entity x]\n  (body-position! entity x (body-y entity) (body-angle entity)))", :docstring "<p>Changes the <code>x</code> of the body in <code>entity</code>.</p>"} {:raw* nil, :arglists [(body-y! entity y)], :java [], :name "body-y!", :type :code, :raw "(defn body-y!\n  [entity y]\n  (body-position! entity (body-x entity) y (body-angle entity)))", :docstring "<p>Changes the <code>y</code> of the body in <code>entity</code>.</p>"} {:raw* nil, :arglists [(body-angle! entity angle)], :java [], :name "body-angle!", :type :code, :raw "(defn body-angle!\n  [entity angle]\n  (body-position! entity (body-x entity) (body-y entity) angle))", :docstring "<p>Changes the <code>angle</code> (degrees) of the body in <code>entity</code>.</p>"} {:raw* nil, :arglists [(first-entity screen entities)], :java [], :name "first-entity", :type :code, :raw "(defn first-entity\n  [screen entities]\n  (let [^Contact contact (u/get-obj screen :contact)]\n    (-> contact .getFixtureA .getBody (find-body entities))))", :docstring "<p>Returns the first entity in a contact. May only be used in contact functions such as :on-begin-contact.</p>"} {:raw* nil, :arglists [(second-entity screen entities)], :java [], :name "second-entity", :type :code, :raw "(defn second-entity\n  [screen entities]\n  (let [^Contact contact (u/get-obj screen :contact)]\n    (-> contact .getFixtureB .getBody (find-body entities))))", :docstring "<p>Returns the second entity in a contact. May only be used in contact functions such as :on-begin-contact.</p>"} {:raw* nil, :arglists [(joint-def k & options)], :java [["joint-def" {:text "Rope joint definition. This requires two body anchor points and a maximum lengths. Note: by default the connected objects will\n not collide. see collideConnected in b2JointDef.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":rope :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":rope :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":rope :collide-connected"} {:args [["Vector2" "value"]], :text "The local anchor point relative to bodyA's origin.", :name ":rope :local-anchor-a"} {:args [["Vector2" "value"]], :text "The local anchor point relative to bodyB's origin.", :name ":rope :local-anchor-b"} {:args [["float" "value"]], :text "The maximum length of the rope. Warning: this must be larger than b2_linearSlop or the joint will have no effect.", :name ":rope :max-length"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":rope :type"}]}] ["joint-def" {:text "Mouse joint definition. This requires a world target point, tuning parameters, and the time step.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":mouse :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":mouse :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":mouse :collide-connected"} {:args [["float" "value"]], :text "The damping ratio. 0 = no damping, 1 = critical damping.", :name ":mouse :damping-ratio"} {:args [["float" "value"]], :text "The response speed.", :name ":mouse :frequency-hz"} {:args [["float" "value"]], :text "The maximum constraint force that can be exerted to move the candidate body. Usually you will express as some multiple of\n the weight (multiplier * mass * gravity).", :name ":mouse :max-force"} {:args [["Vector2" "value"]], :text "The initial world target point. This is assumed to coincide with the body anchor initially.", :name ":mouse :target"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":mouse :type"}]}] ["joint-def" {:text "Wheel joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local\n anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is\n zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a\n game.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":wheel :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":wheel :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":wheel :collide-connected"} {:args [["float" "value"]], :text "Suspension damping ratio, one indicates critical damping", :name ":wheel :damping-ratio"} {:args [["boolean" "value"]], :text "Enable/disable the joint motor.", :name ":wheel :enable-motor"} {:args [["float" "value"]], :text "Suspension frequency, zero indicates no suspension", :name ":wheel :frequency-hz"} {:args [["Vector2" "value"]], :text "The local anchor point relative to body1's origin.", :name ":wheel :local-anchor-a"} {:args [["Vector2" "value"]], :text "The local anchor point relative to body2's origin.", :name ":wheel :local-anchor-b"} {:args [["Vector2" "value"]], :text "The local translation axis in body1.", :name ":wheel :local-axis-a"} {:args [["float" "value"]], :text "The maximum motor torque, usually in N-m.", :name ":wheel :max-motor-torque"} {:args [["float" "value"]], :text "The desired motor speed in radians per second.", :name ":wheel :motor-speed"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":wheel :type"}]}] ["joint-def" {:text "Distance joint definition. This requires defining an anchor point on both bodies and the non-zero length of the distance joint.\n The definition uses local anchor points so that the initial configuration can violate the constraint slightly. This helps when\n saving and loading a game.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":distance :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":distance :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":distance :collide-connected"} {:args [["float" "value"]], :text "The damping ratio. 0 = no damping, 1 = critical damping.", :name ":distance :damping-ratio"} {:args [["float" "value"]], :text "The mass-spring-damper frequency in Hertz.", :name ":distance :frequency-hz"} {:args [["float" "value"]], :text "The natural length between the anchor points.", :name ":distance :length"} {:args [["Vector2" "value"]], :text "The local anchor point relative to body1's origin.", :name ":distance :local-anchor-a"} {:args [["Vector2" "value"]], :text "The local anchor point relative to body2's origin.", :name ":distance :local-anchor-b"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":distance :type"}]}] ["joint-def" {:text "Gear joint definition. This definition requires two existing revolute or prismatic joints (any combination will work). The\n provided joints must attach a dynamic body to a static body.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":gear :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":gear :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":gear :collide-connected"} {:args [["Joint" "value"]], :text "The first revolute/prismatic joint attached to the gear joint.", :name ":gear :joint1"} {:args [["Joint" "value"]], :text "The second revolute/prismatic joint attached to the gear joint.", :name ":gear :joint2"} {:args [["float" "value"]], :text "The gear ratio.", :name ":gear :ratio"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":gear :type"}]}] ["joint-def" {:text "", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":weld :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":weld :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":weld :collide-connected"} {:args [["Vector2" "value"]], :name ":weld :local-anchor-a"} {:args [["Vector2" "value"]], :name ":weld :local-anchor-b"} {:args [["float" "value"]], :name ":weld :reference-angle"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":weld :type"}]}] ["joint-def" {:text "Revolute joint definition. This requires defining an anchor point where the bodies are joined. The definition uses local anchor\n points so that the initial configuration can violate the constraint slightly. You also need to specify the initial relative\n angle for joint limits. This helps when saving and loading a game. The local anchor points are measured from the body's origin\n rather than the center of mass because: 1. you might not know where the center of mass will be. 2. if you add/remove shapes\n from a body and recompute the mass, the joints will be broken.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":revolute :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":revolute :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":revolute :collide-connected"} {:args [["boolean" "value"]], :text "A flag to enable joint limits.", :name ":revolute :enable-limit"} {:args [["boolean" "value"]], :text "A flag to enable the joint motor.", :name ":revolute :enable-motor"} {:args [["Vector2" "value"]], :text "The local anchor point relative to body1's origin.", :name ":revolute :local-anchor-a"} {:args [["Vector2" "value"]], :text "The local anchor point relative to body2's origin.", :name ":revolute :local-anchor-b"} {:args [["float" "value"]], :text "The lower angle for the joint limit (radians).", :name ":revolute :lower-angle"} {:args [["float" "value"]], :text "The maximum motor torque used to achieve the desired motor speed. Usually in N-m.", :name ":revolute :max-motor-torque"} {:args [["float" "value"]], :text "The desired motor speed. Usually in radians per second.", :name ":revolute :motor-speed"} {:args [["float" "value"]], :text "The body2 angle minus body1 angle in the reference state (radians).", :name ":revolute :reference-angle"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":revolute :type"} {:args [["float" "value"]], :text "The upper angle for the joint limit (radians).", :name ":revolute :upper-angle"}]}] ["joint-def" {:text "Friction joint definition.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":friction :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":friction :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":friction :collide-connected"} {:args [["Vector2" "value"]], :text "The local anchor point relative to bodyA's origin.", :name ":friction :local-anchor-a"} {:args [["Vector2" "value"]], :text "The local anchor point relative to bodyB's origin.", :name ":friction :local-anchor-b"} {:args [["float" "value"]], :text "The maximum friction force in N.", :name ":friction :max-force"} {:args [["float" "value"]], :text "The maximum friction torque in N-m.", :name ":friction :max-torque"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":friction :type"}]}] ["joint-def" {:text "Pulley joint definition. This requires two ground anchors, two dynamic body anchor points, max lengths for each side, and a\n pulley ratio.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":pulley :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":pulley :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":pulley :collide-connected"} {:args [["Vector2" "value"]], :text "The first ground anchor in world coordinates. This point never moves.", :name ":pulley :ground-anchor-a"} {:args [["Vector2" "value"]], :text "The second ground anchor in world coordinates. This point never moves.", :name ":pulley :ground-anchor-b"} {:args [["float" "value"]], :text "The a reference length for the segment attached to bodyA.", :name ":pulley :length-a"} {:args [["float" "value"]], :text "The a reference length for the segment attached to bodyB.", :name ":pulley :length-b"} {:args [["Vector2" "value"]], :text "The local anchor point relative to bodyA's origin.", :name ":pulley :local-anchor-a"} {:args [["Vector2" "value"]], :text "The local anchor point relative to bodyB's origin.", :name ":pulley :local-anchor-b"} {:args [["float" "value"]], :text "The pulley ratio, used to simulate a block-and-tackle.", :name ":pulley :ratio"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":pulley :type"}]}] ["joint-def" {:text "Prismatic joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses\n local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint\n translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when\n saving and loading a game.", :items [{:args [["Body" "value"]], :text "The first attached body.", :name ":prismatic :body-a"} {:args [["Body" "value"]], :text "The second attached body", :name ":prismatic :body-b"} {:args [["boolean" "value"]], :text "Set this flag to true if the attached bodies should collide.", :name ":prismatic :collide-connected"} {:args [["boolean" "value"]], :text "Enable/disable the joint limit.", :name ":prismatic :enable-limit"} {:args [["boolean" "value"]], :text "Enable/disable the joint motor.", :name ":prismatic :enable-motor"} {:args [["Vector2" "value"]], :text "The local anchor point relative to body1's origin.", :name ":prismatic :local-anchor-a"} {:args [["Vector2" "value"]], :text "The local anchor point relative to body2's origin.", :name ":prismatic :local-anchor-b"} {:args [["Vector2" "value"]], :text "The local translation axis in body1.", :name ":prismatic :local-axis-a"} {:args [["float" "value"]], :text "The lower translation limit, usually in meters.", :name ":prismatic :lower-translation"} {:args [["float" "value"]], :text "The maximum motor torque, usually in N-m.", :name ":prismatic :max-motor-force"} {:args [["float" "value"]], :text "The desired motor speed in radians per second.", :name ":prismatic :motor-speed"} {:args [["float" "value"]], :text "The constrained angle between the bodies: body2_angle - body1_angle.", :name ":prismatic :reference-angle"} {:args [["JointDef.JointType" "value"]], :text "The joint type is set automatically for concrete joint types.", :name ":prismatic :type"} {:args [["float" "value"]], :text "The upper translation limit, usually in meters.", :name ":prismatic :upper-translation"}]}]], :name "joint-def", :type :code, :raw "(defmacro joint-def\n  [k & options]\n  `(let [object# (~(joint-init k))]\n     (u/fields! object# ~@options)))", :docstring "<p>Returns a subclass of <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/JointDef.html'>JointDef</a>.</p><pre>\n&#40;joint-def :rope&#41;\n</pre>"} {:raw* nil, :arglists [(joint! object k & options)], :java [["joint!" {:text "", :items [{:args [], :type "Vector2", :name ":get-anchor-a"} {:args [], :type "Vector2", :name ":get-anchor-b"} {:args [], :type "Body", :text "Get the first body attached to this joint.", :name ":get-body-a"} {:args [], :type "Body", :text "Get the second body attached to this joint.", :name ":get-body-b"} {:args [], :type "boolean", :name ":get-collide-connected"} {:args [["float" "inv-dt"]], :type "Vector2", :name ":get-reaction-force"} {:args [["float" "inv-dt"]], :type "float", :text "Get the reaction torque on body2 in N*m.", :name ":get-reaction-torque"} {:args [], :type "JointDef.JointType", :text "Get the type of the concrete joint.", :name ":get-type"} {:args [], :type "Object", :text "Get the user data", :name ":get-user-data"} {:args [], :type "boolean", :text "Short-cut function to determine if either body is inactive.", :name ":is-active"} {:args [["Object" "user-data"]], :text "Set the user data", :name ":set-user-data"}]}]], :name "joint!", :type :code, :raw "(defmacro joint!\n  [object k & options]\n  `(u/call! ^Joint ~object ~k ~@options))", :docstring "<p>Calls a single method on a joint.</p>"} {:raw* nil, :arglists [(add-joint! screen j-def)], :java [], :name "add-joint!", :type :code, :raw "(defn add-joint!\n  [screen j-def]\n  (box-2d! screen :create-joint j-def))", :docstring "<p>Adds the <code>joint</code> to the <code>screen</code> for physics simulations and returns it.</p>"} {:raw* nil, :arglists [(fixture-def & options)], :java [["fixture-def" {:text "A fixture definition is used to create a fixture. This class defines an abstract fixture definition. You can reuse fixture\n definitions safely.", :items [{:args [["float" "value"]], :text "The density, usually in kg/m^2.", :name ":density"} {:args [["Filter" "value"]], :text "Contact filtering data.", :name ":filter"} {:args [["float" "value"]], :text "The friction coefficient, usually in the range [0,1].", :name ":friction"} {:args [["boolean" "value"]], :text "A sensor shape collects contact information but never generates a collision response.", :name ":is-sensor"} {:args [["float" "value"]], :text "The restitution (elasticity) usually in the range [0,1].", :name ":restitution"} {:args [["Shape" "value"]], :text "The shape, this must be set. The shape will be cloned, so you can create the shape on the stack.", :name ":shape"}]}]], :name "fixture-def", :type :code, :raw "(defmacro fixture-def\n  [& options]\n  `(let [^FixtureDef object# (FixtureDef.)]\n     (u/fields! object# ~@options)\n     object#))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/FixtureDef.html'>FixtureDef</a>.</p>"} {:raw* nil, :arglists [(fixture! object k & options)], :java [["fixture!" {:text "", :items [{:args [], :type "Body", :text "Get the parent body of this fixture. This is NULL if the fixture is not attached.", :name ":get-body"} {:args [], :type "float", :text "Get the density of this fixture.", :name ":get-density"} {:args [], :type "Filter", :name ":get-filter-data"} {:args [], :type "float", :text "Get the coefficient of friction.", :name ":get-friction"} {:args [], :type "float", :text "Get the coefficient of restitution.", :name ":get-restitution"} {:args [], :type "Shape", :text "Returns the shape of this fixture", :name ":get-shape"} {:args [], :type "Shape.Type", :text "Get the type of the child shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Object", :name ":get-user-data"} {:args [], :type "boolean", :text "Is this fixture a sensor (non-solid)?", :name ":is-sensor"} {:args [], :text "Call this if you want to establish collision that was previously disabled by b2ContactFilter::ShouldCollide.", :name ":refilter"} {:args [["float" "density"]], :text "Set the density of this fixture. This will _not_ automatically adjust the mass of the body. You must call\n b2Body::ResetMassData to update the body's mass.", :name ":set-density"} {:args [["Filter" "filter"]], :text "Set the contact filtering data. This will not update contacts until the next time step when either parent body is active and\n awake. This automatically calls Refilter.", :name ":set-filter-data"} {:args [["float" "friction"]], :text "Set the coefficient of friction.", :name ":set-friction"} {:args [["float" "restitution"]], :text "Set the coefficient of restitution.", :name ":set-restitution"} {:args [["boolean" "sensor"]], :text "Set if this fixture is a sensor.", :name ":set-sensor"} {:args [["Object" "user-data"]], :text "Sets custom user data.", :name ":set-user-data"} {:args [["Vector2" "p"]], :type "boolean", :text "Test a point for containment in this fixture.", :name ":test-point"} {:args [["float" "x"] ["float" "y"]], :type "boolean", :text "Test a point for containment in this fixture.", :name ":test-point"}]}]], :name "fixture!", :type :code, :raw "(defmacro fixture!\n  [object k & options]\n  `(u/call! ^Fixture ~object ~k ~@options))", :docstring "<p>Calls a single method on a fixture.</p>"} {:raw* "(defn chain-shape*\n  []\n  (ChainShape.))", :arglists [(chain-shape & options)], :java [["chain-shape" {:text "", :items [{:args [["float[]" "vertices"]], :text "Create a chain with isolated end vertices.", :name ":create-chain"} {:args [["com.badlogic.gdx.math.Vector2[]" "vertices"]], :text "Create a chain with isolated end vertices.", :name ":create-chain"} {:args [["float[]" "vertices"]], :text "Create a loop. This automatically adjusts connectivity.", :name ":create-loop"} {:args [["com.badlogic.gdx.math.Vector2[]" "vertices"]], :text "Create a loop. This automatically adjusts connectivity.", :name ":create-loop"} {:args [], :text "Needs to be called when the shape is no longer used, e.g. after a fixture was created based on the shape.", :name ":dispose"} {:args [], :type "int", :text "Get the number of child primitives.", :name ":get-child-count"} {:args [], :type "float", :text "Returns the radius of this shape", :name ":get-radius"} {:args [], :type "Shape.Type", :text "Get the type of this shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Shape.Type", :name ":get-type"} {:args [["int" "index"] ["Vector2" "vertex"]], :text "Returns the vertex at the given position.", :name ":get-vertex"} {:args [], :type "int", :name ":get-vertex-count"} {:args [], :type "boolean", :name ":is-looped"} {:args [["Vector2" "next-vertex"]], :text "Establish connectivity to a vertex that follows the last vertex. Don't call this for loops.", :name ":set-next-vertex"} {:args [["float" "next-vertex-x"] ["float" "next-vertex-y"]], :text "Establish connectivity to a vertex that follows the last vertex. Don't call this for loops.", :name ":set-next-vertex"} {:args [["Vector2" "prev-vertex"]], :text "Establish connectivity to a vertex that precedes the first vertex. Don't call this for loops.", :name ":set-prev-vertex"} {:args [["float" "prev-vertex-x"] ["float" "prev-vertex-y"]], :text "Establish connectivity to a vertex that precedes the first vertex. Don't call this for loops.", :name ":set-prev-vertex"} {:args [["float" "radius"]], :text "Sets the radius of this shape", :name ":set-radius"}]}]], :name "chain-shape", :type :code, :raw "(defmacro chain-shape\n  [& options]\n  `(u/calls! ^ChainShape (chain-shape*) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/ChainShape.html'>ChainShape</a>.</p>"} {:raw* nil, :arglists [(chain-shape! object k & options)], :java [["chain-shape!" {:text "", :items [{:args [["float[]" "vertices"]], :text "Create a chain with isolated end vertices.", :name ":create-chain"} {:args [["com.badlogic.gdx.math.Vector2[]" "vertices"]], :text "Create a chain with isolated end vertices.", :name ":create-chain"} {:args [["float[]" "vertices"]], :text "Create a loop. This automatically adjusts connectivity.", :name ":create-loop"} {:args [["com.badlogic.gdx.math.Vector2[]" "vertices"]], :text "Create a loop. This automatically adjusts connectivity.", :name ":create-loop"} {:args [], :text "Needs to be called when the shape is no longer used, e.g. after a fixture was created based on the shape.", :name ":dispose"} {:args [], :type "int", :text "Get the number of child primitives.", :name ":get-child-count"} {:args [], :type "float", :text "Returns the radius of this shape", :name ":get-radius"} {:args [], :type "Shape.Type", :text "Get the type of this shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Shape.Type", :name ":get-type"} {:args [["int" "index"] ["Vector2" "vertex"]], :text "Returns the vertex at the given position.", :name ":get-vertex"} {:args [], :type "int", :name ":get-vertex-count"} {:args [], :type "boolean", :name ":is-looped"} {:args [["Vector2" "next-vertex"]], :text "Establish connectivity to a vertex that follows the last vertex. Don't call this for loops.", :name ":set-next-vertex"} {:args [["float" "next-vertex-x"] ["float" "next-vertex-y"]], :text "Establish connectivity to a vertex that follows the last vertex. Don't call this for loops.", :name ":set-next-vertex"} {:args [["Vector2" "prev-vertex"]], :text "Establish connectivity to a vertex that precedes the first vertex. Don't call this for loops.", :name ":set-prev-vertex"} {:args [["float" "prev-vertex-x"] ["float" "prev-vertex-y"]], :text "Establish connectivity to a vertex that precedes the first vertex. Don't call this for loops.", :name ":set-prev-vertex"} {:args [["float" "radius"]], :text "Sets the radius of this shape", :name ":set-radius"}]}]], :name "chain-shape!", :type :code, :raw "(defmacro chain-shape!\n  [object k & options]\n  `(u/call! ^ChainShape ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>chain-shape</code>.</p>"} {:raw* "(defn circle-shape*\n  ([]\n    (CircleShape.))\n  ([radius]\n    (doto ^CircleShape (circle-shape*)\n      (.setRadius radius)\n      (.setPosition (m/vector-2 radius radius)))))", :arglists [(circle-shape radius & options)], :java [["circle-shape" {:text "A circle shape.", :items [{:args [], :text "Needs to be called when the shape is no longer used, e.g. after a fixture was created based on the shape.", :name ":dispose"} {:args [], :type "int", :text "Get the number of child primitives.", :name ":get-child-count"} {:args [], :type "Vector2", :name ":get-position"} {:args [], :type "float", :text "Returns the radius of this shape", :name ":get-radius"} {:args [], :type "Shape.Type", :text "Get the type of this shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Shape.Type", :text "{@inheritDoc}", :name ":get-type"} {:args [["Vector2" "position"]], :text "Sets the position of the shape", :name ":set-position"} {:args [["float" "radius"]], :text "Sets the radius of this shape", :name ":set-radius"}]}]], :name "circle-shape", :type :code, :raw "(defmacro circle-shape\n  [radius & options]\n  `(u/calls! ^CircleShape (circle-shape* ~radius) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/CircleShape.html'>CircleShape</a>.</p>"} {:raw* nil, :arglists [(circle-shape! object k & options)], :java [["circle-shape!" {:text "A circle shape.", :items [{:args [], :text "Needs to be called when the shape is no longer used, e.g. after a fixture was created based on the shape.", :name ":dispose"} {:args [], :type "int", :text "Get the number of child primitives.", :name ":get-child-count"} {:args [], :type "Vector2", :name ":get-position"} {:args [], :type "float", :text "Returns the radius of this shape", :name ":get-radius"} {:args [], :type "Shape.Type", :text "Get the type of this shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Shape.Type", :text "{@inheritDoc}", :name ":get-type"} {:args [["Vector2" "position"]], :text "Sets the position of the shape", :name ":set-position"} {:args [["float" "radius"]], :text "Sets the radius of this shape", :name ":set-radius"}]}]], :name "circle-shape!", :type :code, :raw "(defmacro circle-shape!\n  [object k & options]\n  `(u/call! ^CircleShape ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>circle-shape</code>.</p>"} {:raw* "(defn edge-shape*\n  []\n  (EdgeShape.))", :arglists [(edge-shape & options)], :java [["edge-shape" {:text "A line segment (edge) shape. These can be connected in chains or loops to other edge shapes. The connectivity information is\n used to ensure correct contact normals.", :items [{:args [], :text "Needs to be called when the shape is no longer used, e.g. after a fixture was created based on the shape.", :name ":dispose"} {:args [], :type "int", :text "Get the number of child primitives.", :name ":get-child-count"} {:args [], :type "float", :text "Returns the radius of this shape", :name ":get-radius"} {:args [], :type "Shape.Type", :text "Get the type of this shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Shape.Type", :name ":get-type"} {:args [["Vector2" "vec"]], :name ":get-vertex1"} {:args [["Vector2" "vec"]], :name ":get-vertex2"} {:args [["Vector2" "v1"] ["Vector2" "v2"]], :text "Set this as an isolated edge.", :name ":set"} {:args [["float" "v1x"] ["float" "v1y"] ["float" "v2x"] ["float" "v2y"]], :text "Set this as an isolated edge.", :name ":set"} {:args [["float" "radius"]], :text "Sets the radius of this shape", :name ":set-radius"}]}]], :name "edge-shape", :type :code, :raw "(defmacro edge-shape\n  [& options]\n  `(u/calls! ^EdgeShape (edge-shape*) ~@options))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/EdgeShape.html'>EdgeShape</a>.</p>"} {:raw* nil, :arglists [(edge-shape! object k & options)], :java [["edge-shape!" {:text "A line segment (edge) shape. These can be connected in chains or loops to other edge shapes. The connectivity information is\n used to ensure correct contact normals.", :items [{:args [], :text "Needs to be called when the shape is no longer used, e.g. after a fixture was created based on the shape.", :name ":dispose"} {:args [], :type "int", :text "Get the number of child primitives.", :name ":get-child-count"} {:args [], :type "float", :text "Returns the radius of this shape", :name ":get-radius"} {:args [], :type "Shape.Type", :text "Get the type of this shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Shape.Type", :name ":get-type"} {:args [["Vector2" "vec"]], :name ":get-vertex1"} {:args [["Vector2" "vec"]], :name ":get-vertex2"} {:args [["Vector2" "v1"] ["Vector2" "v2"]], :text "Set this as an isolated edge.", :name ":set"} {:args [["float" "v1x"] ["float" "v1y"] ["float" "v2x"] ["float" "v2y"]], :text "Set this as an isolated edge.", :name ":set"} {:args [["float" "radius"]], :text "Sets the radius of this shape", :name ":set-radius"}]}]], :name "edge-shape!", :type :code, :raw "(defmacro edge-shape!\n  [object k & options]\n  `(u/call! ^EdgeShape ~object ~k ~@options))", :docstring "<p>Calls a single method on an <code>edge-shape</code>.</p>"} {:raw* "(defn polygon-shape*\n  []\n  (PolygonShape.))", :arglists [(polygon-shape & options)], :java [["polygon-shape" {:text "", :items [{:args [], :text "Needs to be called when the shape is no longer used, e.g. after a fixture was created based on the shape.", :name ":dispose"} {:args [], :type "int", :text "Get the number of child primitives.", :name ":get-child-count"} {:args [], :type "float", :text "Returns the radius of this shape", :name ":get-radius"} {:args [], :type "Shape.Type", :text "Get the type of this shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Shape.Type", :text "{@inheritDoc}", :name ":get-type"} {:args [["int" "index"] ["Vector2" "vertex"]], :text "Returns the vertex at the given position.", :name ":get-vertex"} {:args [], :type "int", :name ":get-vertex-count"} {:args [["com.badlogic.gdx.math.Vector2[]" "vertices"]], :text "Copy vertices. This assumes the vertices define a convex polygon. It is assumed that the exterior is the the right of each\n edge.", :name ":set"} {:args [["float[]" "vertices"]], :text "Copy vertices from the given float array. It is assumed the vertices are in x,y order and define a convex polygon. It is\n assumed that the exterior is the the right of each edge.", :name ":set"} {:args [["float[]" "vertices"] ["int" "offset"] ["int" "len"]], :text "Copy vertices from the given float array, taking into account the offset and length. It is assumed the vertices are in\n x,y order and define a convex polygon. It is assumed that the exterior is the the right of each edge.", :name ":set"} {:args [["float" "hx"] ["float" "hy"]], :text "Build vertices to represent an axis-aligned box.", :name ":set-as-box"} {:args [["float" "hx"] ["float" "hy"] ["Vector2" "center"] ["float" "angle"]], :text "Build vertices to represent an oriented box.", :name ":set-as-box"} {:args [["float" "radius"]], :text "Sets the radius of this shape", :name ":set-radius"}]}]], :name "polygon-shape", :type :code, :raw "(defmacro polygon-shape\n  [& options]\n  `(u/calls! ^PolygonShape (polygon-shape*) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/physics/box2d/PolygonShape.html'>PolygonShape</a>.</p>"} {:raw* nil, :arglists [(polygon-shape! object k & options)], :java [["polygon-shape!" {:text "", :items [{:args [], :text "Needs to be called when the shape is no longer used, e.g. after a fixture was created based on the shape.", :name ":dispose"} {:args [], :type "int", :text "Get the number of child primitives.", :name ":get-child-count"} {:args [], :type "float", :text "Returns the radius of this shape", :name ":get-radius"} {:args [], :type "Shape.Type", :text "Get the type of this shape. You can use this to down cast to the concrete shape.", :name ":get-type"} {:args [], :type "Shape.Type", :text "{@inheritDoc}", :name ":get-type"} {:args [["int" "index"] ["Vector2" "vertex"]], :text "Returns the vertex at the given position.", :name ":get-vertex"} {:args [], :type "int", :name ":get-vertex-count"} {:args [["com.badlogic.gdx.math.Vector2[]" "vertices"]], :text "Copy vertices. This assumes the vertices define a convex polygon. It is assumed that the exterior is the the right of each\n edge.", :name ":set"} {:args [["float[]" "vertices"]], :text "Copy vertices from the given float array. It is assumed the vertices are in x,y order and define a convex polygon. It is\n assumed that the exterior is the the right of each edge.", :name ":set"} {:args [["float[]" "vertices"] ["int" "offset"] ["int" "len"]], :text "Copy vertices from the given float array, taking into account the offset and length. It is assumed the vertices are in\n x,y order and define a convex polygon. It is assumed that the exterior is the the right of each edge.", :name ":set"} {:args [["float" "hx"] ["float" "hy"]], :text "Build vertices to represent an axis-aligned box.", :name ":set-as-box"} {:args [["float" "hx"] ["float" "hy"] ["Vector2" "center"] ["float" "angle"]], :text "Build vertices to represent an oriented box.", :name ":set-as-box"} {:args [["float" "radius"]], :text "Sets the radius of this shape", :name ":set-radius"}]}]], :name "polygon-shape!", :type :code, :raw "(defmacro polygon-shape!\n  [object k & options]\n  `(u/call! ^PolygonShape ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>polygon-shape</code>.</p>"} {:raw* nil, :arglists [(step! screen) (step! screen entities)], :java [], :name "step!", :type :code, :raw "(defn step!\n  ([{:keys [world time-step velocity-iterations position-iterations]\n     :or {time-step (/ 1 60) velocity-iterations 10 position-iterations 10}\n     :as screen}]\n    (.step world time-step velocity-iterations position-iterations))\n  ([screen entities]\n    (step! screen)\n    (map (fn [e]\n           (if (:body e)\n             (assoc e\n                    :x (body-x e)\n                    :y (body-y e)\n                    :angle (body-angle e)\n                    :origin-x (body-origin-x e)\n                    :origin-y (body-origin-y e))\n             e))\n         entities)))", :docstring "<p>Runs the physics simulations for a single frame and optionally returns the <code>entities</code> with their positions updated.</p>"})} {:ns "play-clj.g3d", :groups ({:raw* "(defn animation-controller*\n  [entity]\n  (AnimationController. (u/get-obj entity :object)))", :arglists [(animation-controller entity & options)], :java [["animation-controller" {:text "Class to control one or more {@link Animation}s on a {@link ModelInstance}. Use the\n {@link #setAnimation(String, int, float, AnimationListener)} method to change the current animation. Use the\n {@link #animate(String, int, float, AnimationListener, float)} method to start an animation, optionally blending onto the\n current animation. Use the {@link #queue(String, int, float, AnimationListener, float)} method to queue an animation to be\n played when the current animation is finished. Use the {@link #action(String, int, float, AnimationListener, float)} method to\n play a (short) animation on top of the current animation.\n \n You can use multiple AnimationControllers on the same ModelInstance, as long as they don't interfere with each other (don't\n affect the same {@link Node}s).", :items [{:args [["String" "id"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Apply an action animation on top of the current animation.", :name ":action"} {:args [["String" "id"] ["float" "offset"] ["float" "duration"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Apply an action animation on top of the current animation.", :name ":action"} {:args [["String" "id"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["int" "loop-count"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["float" "offset"] ["float" "duration"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Queue an animation to be applied when the {@link #current} animation is finished. If the current animation is continuously\n looping it will be synchronized on next loop.", :name ":queue"} {:args [["String" "id"] ["float" "offset"] ["float" "duration"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Queue an animation to be applied when the {@link #current} animation is finished. If the current animation is continuously\n looping it will be synchronized on next loop.", :name ":queue"} {:args [["String" "id"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["int" "loop-count"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["AnimationController.AnimationListener" "listener"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["int" "loop-count"] ["AnimationController.AnimationListener" "listener"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["float" "offset"] ["float" "duration"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["float" "delta"]], :text "Update any animations currently being played.", :name ":update"}]}]], :name "animation-controller", :type :code, :raw "(defmacro animation-controller\n  [entity & options]\n  `(let [^AnimationController object# (animation-controller* ~entity)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/utils/AnimationController.html'>AnimationController</a>.</p><pre>\n&#40;animation-controller model-entity&#41;\n</pre>"} {:raw* nil, :arglists [(animation-controller! object k & options)], :java [["animation-controller!" {:text "Class to control one or more {@link Animation}s on a {@link ModelInstance}. Use the\n {@link #setAnimation(String, int, float, AnimationListener)} method to change the current animation. Use the\n {@link #animate(String, int, float, AnimationListener, float)} method to start an animation, optionally blending onto the\n current animation. Use the {@link #queue(String, int, float, AnimationListener, float)} method to queue an animation to be\n played when the current animation is finished. Use the {@link #action(String, int, float, AnimationListener, float)} method to\n play a (short) animation on top of the current animation.\n \n You can use multiple AnimationControllers on the same ModelInstance, as long as they don't interfere with each other (don't\n affect the same {@link Node}s).", :items [{:args [["String" "id"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Apply an action animation on top of the current animation.", :name ":action"} {:args [["String" "id"] ["float" "offset"] ["float" "duration"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Apply an action animation on top of the current animation.", :name ":action"} {:args [["String" "id"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["int" "loop-count"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["float" "offset"] ["float" "duration"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Changes the current animation by blending the new on top of the old during the transition time.", :name ":animate"} {:args [["String" "id"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Queue an animation to be applied when the {@link #current} animation is finished. If the current animation is continuously\n looping it will be synchronized on next loop.", :name ":queue"} {:args [["String" "id"] ["float" "offset"] ["float" "duration"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"] ["float" "transition-time"]], :type "AnimationController.AnimationDesc", :text "Queue an animation to be applied when the {@link #current} animation is finished. If the current animation is continuously\n looping it will be synchronized on next loop.", :name ":queue"} {:args [["String" "id"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["int" "loop-count"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["AnimationController.AnimationListener" "listener"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["int" "loop-count"] ["AnimationController.AnimationListener" "listener"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["String" "id"] ["float" "offset"] ["float" "duration"] ["int" "loop-count"] ["float" "speed"] ["AnimationController.AnimationListener" "listener"]], :type "AnimationController.AnimationDesc", :text "Set the active animation, replacing any current animation.", :name ":set-animation"} {:args [["float" "delta"]], :text "Update any animations currently being played.", :name ":update"}]}]], :name "animation-controller!", :type :code, :raw "(defmacro animation-controller!\n  [object k & options]\n  `(let [^AnimationController object# ~object]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on an <code>animation-controller</code>.</p>"} {:raw* "(defn environment*\n  []\n  (Environment.))", :arglists [(environment & options)], :java [["environment" {:text "", :items [{:args [["com.badlogic.gdx.graphics.g3d.environment.BaseLight[]" "lights"]], :type "Environment", :name ":add"} {:args [["com.badlogic.gdx.utils.Array" "lights"]], :type "Environment", :name ":add"} {:args [["BaseLight" "light"]], :type "Environment", :name ":add"} {:args [], :text "Removes all attributes", :name ":clear"} {:args [], :name ":clear"} {:args [["Attribute" "arg0"] ["Attribute" "arg1"]], :type "int", :text "Used for sorting attributes", :name ":compare"} {:args [["long" "type"]], :type "Attribute", :text "Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;", :name ":get"} {:args [["java.lang.Class" "clazz"] ["long" "type"]], :type "Attribute", :text "Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;", :name ":get"} {:args [["com.badlogic.gdx.utils.Array" "out"] ["long" "type"]], :type "Array", :text "Get multiple attributes at once. Example: material.get(out, ColorAttribute.Diffuse | ColorAttribute.Specular |\n TextureAttribute.Diffuse);", :name ":get"} {:args [], :type "long", :name ":get-mask"} {:args [["long" "type"]], :type "boolean", :name ":has"} {:args [], :type "Iterator", :text "Used for iterating through the attributes", :name ":iterator"} {:args [["long" "mask"]], :text "Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.ID); Can also be used to remove multiple\n attributes also, i.e. remove(AttributeA.ID | AttributeB.ID);", :name ":remove"} {:args [["Attributes" "other"] ["boolean" "compare-values"]], :type "boolean", :text "Check if this collection has the same attributes as the other collection. If compareValues is true, it also compares the\n values of each attribute.", :name ":same"} {:args [["Attributes" "other"]], :type "boolean", :text "See {@link #same(Attributes, boolean)}", :name ":same"} {:args [["Attribute" "attribute"]], :text "Add a attribute to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"] ["Attribute" "attribute3"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"] ["Attribute" "attribute3"] ["Attribute" "attribute4"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["com.badlogic.gdx.graphics.g3d.Attribute[]" "attributes"]], :text "Add an array of attributes to this material. If the material already contains an attribute of the same type it is\n overwritten.", :name ":set"} {:args [["java.lang.Iterable" "attributes"]], :text "Add an array of attributes to this material. If the material already contains an attribute of the same type it is\n overwritten.", :name ":set"} {:args [], :type "int", :name ":size"} {:args [], :text "Sort the attributes by their ID", :name ":sort"}]}]], :name "environment", :type :code, :raw "(defmacro environment\n  [& options]\n  `(let [^Environment object# (environment*)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/Environment.html'>Environment</a>.</p><pre>\n&#40;environment&#41;\n</pre>"} {:raw* nil, :arglists [(environment! screen k & options)], :java [["environment!" {:text "", :items [{:args [["com.badlogic.gdx.graphics.g3d.environment.BaseLight[]" "lights"]], :type "Environment", :name ":add"} {:args [["com.badlogic.gdx.utils.Array" "lights"]], :type "Environment", :name ":add"} {:args [["BaseLight" "light"]], :type "Environment", :name ":add"} {:args [], :text "Removes all attributes", :name ":clear"} {:args [], :name ":clear"} {:args [["Attribute" "arg0"] ["Attribute" "arg1"]], :type "int", :text "Used for sorting attributes", :name ":compare"} {:args [["long" "type"]], :type "Attribute", :text "Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;", :name ":get"} {:args [["java.lang.Class" "clazz"] ["long" "type"]], :type "Attribute", :text "Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;", :name ":get"} {:args [["com.badlogic.gdx.utils.Array" "out"] ["long" "type"]], :type "Array", :text "Get multiple attributes at once. Example: material.get(out, ColorAttribute.Diffuse | ColorAttribute.Specular |\n TextureAttribute.Diffuse);", :name ":get"} {:args [], :type "long", :name ":get-mask"} {:args [["long" "type"]], :type "boolean", :name ":has"} {:args [], :type "Iterator", :text "Used for iterating through the attributes", :name ":iterator"} {:args [["long" "mask"]], :text "Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.ID); Can also be used to remove multiple\n attributes also, i.e. remove(AttributeA.ID | AttributeB.ID);", :name ":remove"} {:args [["Attributes" "other"] ["boolean" "compare-values"]], :type "boolean", :text "Check if this collection has the same attributes as the other collection. If compareValues is true, it also compares the\n values of each attribute.", :name ":same"} {:args [["Attributes" "other"]], :type "boolean", :text "See {@link #same(Attributes, boolean)}", :name ":same"} {:args [["Attribute" "attribute"]], :text "Add a attribute to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"] ["Attribute" "attribute3"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"] ["Attribute" "attribute3"] ["Attribute" "attribute4"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["com.badlogic.gdx.graphics.g3d.Attribute[]" "attributes"]], :text "Add an array of attributes to this material. If the material already contains an attribute of the same type it is\n overwritten.", :name ":set"} {:args [["java.lang.Iterable" "attributes"]], :text "Add an array of attributes to this material. If the material already contains an attribute of the same type it is\n overwritten.", :name ":set"} {:args [], :type "int", :name ":size"} {:args [], :text "Sort the attributes by their ID", :name ":sort"}]}]], :name "environment!", :type :code, :raw "(defmacro environment!\n  [screen k & options]\n  `(let [^Environment object# (u/get-obj ~screen :attributes)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on an <code>environment</code>.</p>"} {:raw* "(defn model-batch*\n  []\n  (ModelBatch.))", :arglists [(model-batch & options)], :java [["model-batch" {:text "Batches {@link Renderable} instances, fetches {@link Shader}s for them, sorts them and then renders them. Fetching the shaders\n is done using a {@link ShaderProvider}, which defaults to {@link DefaultShaderProvider}. Sorting the renderables is done using\n a {@link RenderableSorter}, which default to {@link DefaultRenderableSorter}.\n \n The OpenGL context between the {@link #begin(Camera)} and {@link #end()} call is maintained by the {@link RenderContext}.\n \n To provide multiple {@link Renderable}s at once a {@link RenderableProvider} can be used, e.g. a {@link ModelInstance}.", :items [{:args [["Camera" "cam"]], :text "Start rendering one or more {@link Renderable}s. Use one of the render() methods to provide the renderables. Must be\n followed by a call to {@link #end()}. The OpenGL context must not be altered between {@link #begin(Camera)} and\n {@link #end()}.", :name ":begin"} {:args [], :name ":dispose"} {:args [], :text "End rendering one or more {@link Renderable}s. Must be called after a call to {@link #begin(Camera)}. This will flush the\n batch, causing any renderables provided using one of the render() methods to be rendered. After a call to this method the\n OpenGL context can be altered again.", :name ":end"} {:args [], :text "Flushes the batch, causing all {@link Renderable}s in the batch to be rendered. Can only be called after the call to\n {@link #begin(Camera)} and before the call to {@link #end()}.", :name ":flush"} {:args [], :type "Camera", :text "Provides access to the current camera in between {@link #begin(Camera)} and {@link #end()}. Do not change the camera's\n values. Use {@link #setCamera(Camera)}, if you need to change the camera.", :name ":get-camera"} {:args [], :type "RenderContext", :name ":get-render-context"} {:args [], :type "RenderableSorter", :name ":get-renderable-sorter"} {:args [], :type "ShaderProvider", :name ":get-shader-provider"} {:args [], :type "boolean", :text "Checks whether the {@link RenderContext} returned by {@link #getRenderContext()} is owned and managed by this ModelBatch.\n When the RenderContext isn't owned by the ModelBatch, you are responsible for calling the {@link RenderContext#begin()} and\n {@link RenderContext#end()} methods yourself, as well as disposing the RenderContext.", :name ":owns-render-context"} {:args [["Renderable" "renderable"]], :text "Add a single {@link Renderable} to the batch. The {@link ShaderProvider} will be used to fetch a suitable {@link Shader}.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["RenderableProvider" "renderable-provider"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["java.lang.Iterable" "renderable-providers"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["RenderableProvider" "renderable-provider"] ["Environment" "environment"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any environment set on the returned renderables will be replaced with the given environment.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["java.lang.Iterable" "renderable-providers"] ["Environment" "environment"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any environment set on the returned renderables will be replaced with the given environment.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["RenderableProvider" "renderable-provider"] ["Shader" "shader"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any shaders set on the returned renderables will be replaced with the given {@link Shader}.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["java.lang.Iterable" "renderable-providers"] ["Shader" "shader"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any shaders set on the returned renderables will be replaced with the given {@link Shader}.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["RenderableProvider" "renderable-provider"] ["Environment" "environment"] ["Shader" "shader"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any environment set on the returned renderables will be replaced with the given environment.\n Any shaders set on the returned renderables will be replaced with the given {@link Shader}. Can only be called after a call\n to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["java.lang.Iterable" "renderable-providers"] ["Environment" "environment"] ["Shader" "shader"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any environment set on the returned renderables will be replaced with the given environment.\n Any shaders set on the returned renderables will be replaced with the given {@link Shader}. Can only be called after a call\n to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["Camera" "cam"]], :text "Change the camera in between {@link #begin(Camera)} and {@link #end()}. This causes the batch to be flushed. Can only be\n called after the call to {@link #begin(Camera)} and before the call to {@link #end()}.", :name ":set-camera"}]}]], :name "model-batch", :type :code, :raw "(defmacro model-batch\n  [& options]\n  `(let [^ModelBatch object# (model-batch*)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/ModelBatch.html'>ModelBatch</a>.</p><pre>\n&#40;model-batch&#41;\n</pre>"} {:raw* nil, :arglists [(model-batch! screen k & options)], :java [["model-batch!" {:text "Batches {@link Renderable} instances, fetches {@link Shader}s for them, sorts them and then renders them. Fetching the shaders\n is done using a {@link ShaderProvider}, which defaults to {@link DefaultShaderProvider}. Sorting the renderables is done using\n a {@link RenderableSorter}, which default to {@link DefaultRenderableSorter}.\n \n The OpenGL context between the {@link #begin(Camera)} and {@link #end()} call is maintained by the {@link RenderContext}.\n \n To provide multiple {@link Renderable}s at once a {@link RenderableProvider} can be used, e.g. a {@link ModelInstance}.", :items [{:args [["Camera" "cam"]], :text "Start rendering one or more {@link Renderable}s. Use one of the render() methods to provide the renderables. Must be\n followed by a call to {@link #end()}. The OpenGL context must not be altered between {@link #begin(Camera)} and\n {@link #end()}.", :name ":begin"} {:args [], :name ":dispose"} {:args [], :text "End rendering one or more {@link Renderable}s. Must be called after a call to {@link #begin(Camera)}. This will flush the\n batch, causing any renderables provided using one of the render() methods to be rendered. After a call to this method the\n OpenGL context can be altered again.", :name ":end"} {:args [], :text "Flushes the batch, causing all {@link Renderable}s in the batch to be rendered. Can only be called after the call to\n {@link #begin(Camera)} and before the call to {@link #end()}.", :name ":flush"} {:args [], :type "Camera", :text "Provides access to the current camera in between {@link #begin(Camera)} and {@link #end()}. Do not change the camera's\n values. Use {@link #setCamera(Camera)}, if you need to change the camera.", :name ":get-camera"} {:args [], :type "RenderContext", :name ":get-render-context"} {:args [], :type "RenderableSorter", :name ":get-renderable-sorter"} {:args [], :type "ShaderProvider", :name ":get-shader-provider"} {:args [], :type "boolean", :text "Checks whether the {@link RenderContext} returned by {@link #getRenderContext()} is owned and managed by this ModelBatch.\n When the RenderContext isn't owned by the ModelBatch, you are responsible for calling the {@link RenderContext#begin()} and\n {@link RenderContext#end()} methods yourself, as well as disposing the RenderContext.", :name ":owns-render-context"} {:args [["Renderable" "renderable"]], :text "Add a single {@link Renderable} to the batch. The {@link ShaderProvider} will be used to fetch a suitable {@link Shader}.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["RenderableProvider" "renderable-provider"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["java.lang.Iterable" "renderable-providers"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["RenderableProvider" "renderable-provider"] ["Environment" "environment"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any environment set on the returned renderables will be replaced with the given environment.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["java.lang.Iterable" "renderable-providers"] ["Environment" "environment"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any environment set on the returned renderables will be replaced with the given environment.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["RenderableProvider" "renderable-provider"] ["Shader" "shader"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any shaders set on the returned renderables will be replaced with the given {@link Shader}.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["java.lang.Iterable" "renderable-providers"] ["Shader" "shader"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any shaders set on the returned renderables will be replaced with the given {@link Shader}.\n Can only be called after a call to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["RenderableProvider" "renderable-provider"] ["Environment" "environment"] ["Shader" "shader"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any environment set on the returned renderables will be replaced with the given environment.\n Any shaders set on the returned renderables will be replaced with the given {@link Shader}. Can only be called after a call\n to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["java.lang.Iterable" "renderable-providers"] ["Environment" "environment"] ["Shader" "shader"]], :text "Calls {@link RenderableProvider#getRenderables(Array, Pool)} and adds all returned {@link Renderable} instances to the\n current batch to be rendered. Any environment set on the returned renderables will be replaced with the given environment.\n Any shaders set on the returned renderables will be replaced with the given {@link Shader}. Can only be called after a call\n to {@link #begin(Camera)} and before a call to {@link #end()}.", :name ":render"} {:args [["Camera" "cam"]], :text "Change the camera in between {@link #begin(Camera)} and {@link #end()}. This causes the batch to be flushed. Can only be\n called after the call to {@link #begin(Camera)} and before the call to {@link #end()}.", :name ":set-camera"}]}]], :name "model-batch!", :type :code, :raw "(defmacro model-batch!\n  [screen k & options]\n  `(let [^ModelBatch object# (u/get-obj ~screen :renderer)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>model-batch</code>.</p>"} {:raw* "(defn model*\n  [^String path]\n  (or (u/load-asset path Model)\n      (throw (Exception. \"Asset manager not found. See set-asset-manager!\"))))", :arglists [(model & args)], :java [["model" {:text "An instance of a {@link Model}, allows to specify global transform and modify the materials, as it has a copy of the model's\n materials. Multiple instances can be created from the same Model, all sharing the meshes and textures of the Model. The Model\n owns the meshes and textures, to dispose of these, the Model has to be disposed. Therefor, the Model must outlive all its\n ModelInstances</p>\n \n The ModelInstance creates a full copy of all materials, nodes and animations.", :items [{:args [["BoundingBox" "out"]], :type "BoundingBox", :text "Calculate the bounding box of this model instance. This is a potential slow operation, it is advised to cache the result.", :name ":calculate-bounding-box"} {:args [], :text "Calculates the local and world transform of all {@link Node} instances in this model, recursively. First each\n {@link Node#localTransform} transform is calculated based on the translation, rotation and scale of each Node. Then each\n {@link Node#calculateWorldTransform()} is calculated, based on the parent's world transform and the local transform of each\n Node. Finally, the animation bone matrices are updated accordingly.</p>\n \n This method can be used to recalculate all transforms if any of the Node's local properties (translation, rotation, scale)\n was modified.", :name ":calculate-transforms"} {:args [], :type "ModelInstance", :name ":copy"} {:args [["BoundingBox" "out"]], :type "BoundingBox", :text "Extends the bounding box with the bounds of this model instance. This is a potential slow operation, it is advised to cache\n the result.", :name ":extend-bounding-box"} {:args [["String" "id"]], :type "Animation", :name ":get-animation"} {:args [["String" "id"] ["boolean" "ignore-case"]], :type "Animation", :name ":get-animation"} {:args [["String" "id"]], :type "Material", :name ":get-material"} {:args [["String" "id"] ["boolean" "ignore-case"]], :type "Material", :name ":get-material"} {:args [["String" "id"]], :type "Node", :name ":get-node"} {:args [["String" "id"] ["boolean" "recursive"]], :type "Node", :name ":get-node"} {:args [["String" "id"] ["boolean" "recursive"] ["boolean" "ignore-case"]], :type "Node", :name ":get-node"} {:args [["Renderable" "out"]], :type "Renderable", :name ":get-renderable"} {:args [["Renderable" "out"] ["Node" "node"]], :type "Renderable", :name ":get-renderable"} {:args [["Renderable" "out"] ["Node" "node"] ["NodePart" "node-part"]], :type "Renderable", :name ":get-renderable"} {:args [["com.badlogic.gdx.utils.Array" "renderables"] ["com.badlogic.gdx.utils.Pool" "pool"]], :text "Traverses the Node hierarchy and collects {@link Renderable} instances for every node with a graphical representation.\n Renderables are obtained from the provided pool. The resulting array can be rendered via a {@link ModelBatch}.", :name ":get-renderables"}]}]], :name "model", :type :code, :raw "(defmacro model\n  [& args]\n  `(ModelEntity.\n     (let [arg1# ~(first args)]\n       (cond\n         (string? arg1#)\n         (ModelInstance. (model* arg1#))\n         (:object arg1#)\n         (ModelInstance. ^ModelInstance (:object arg1#))\n         (isa? arg1# ModelData)\n         (ModelInstance. ^Model (Model. ~@args))\n         :else\n         (ModelInstance. ~@args)))))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/ModelInstance.html'>ModelInstance</a>.</p>"} {:raw* nil, :arglists [(model! entity k & options)], :java [["model!" {:text "An instance of a {@link Model}, allows to specify global transform and modify the materials, as it has a copy of the model's\n materials. Multiple instances can be created from the same Model, all sharing the meshes and textures of the Model. The Model\n owns the meshes and textures, to dispose of these, the Model has to be disposed. Therefor, the Model must outlive all its\n ModelInstances</p>\n \n The ModelInstance creates a full copy of all materials, nodes and animations.", :items [{:args [["BoundingBox" "out"]], :type "BoundingBox", :text "Calculate the bounding box of this model instance. This is a potential slow operation, it is advised to cache the result.", :name ":calculate-bounding-box"} {:args [], :text "Calculates the local and world transform of all {@link Node} instances in this model, recursively. First each\n {@link Node#localTransform} transform is calculated based on the translation, rotation and scale of each Node. Then each\n {@link Node#calculateWorldTransform()} is calculated, based on the parent's world transform and the local transform of each\n Node. Finally, the animation bone matrices are updated accordingly.</p>\n \n This method can be used to recalculate all transforms if any of the Node's local properties (translation, rotation, scale)\n was modified.", :name ":calculate-transforms"} {:args [], :type "ModelInstance", :name ":copy"} {:args [["BoundingBox" "out"]], :type "BoundingBox", :text "Extends the bounding box with the bounds of this model instance. This is a potential slow operation, it is advised to cache\n the result.", :name ":extend-bounding-box"} {:args [["String" "id"]], :type "Animation", :name ":get-animation"} {:args [["String" "id"] ["boolean" "ignore-case"]], :type "Animation", :name ":get-animation"} {:args [["String" "id"]], :type "Material", :name ":get-material"} {:args [["String" "id"] ["boolean" "ignore-case"]], :type "Material", :name ":get-material"} {:args [["String" "id"]], :type "Node", :name ":get-node"} {:args [["String" "id"] ["boolean" "recursive"]], :type "Node", :name ":get-node"} {:args [["String" "id"] ["boolean" "recursive"] ["boolean" "ignore-case"]], :type "Node", :name ":get-node"} {:args [["Renderable" "out"]], :type "Renderable", :name ":get-renderable"} {:args [["Renderable" "out"] ["Node" "node"]], :type "Renderable", :name ":get-renderable"} {:args [["Renderable" "out"] ["Node" "node"] ["NodePart" "node-part"]], :type "Renderable", :name ":get-renderable"} {:args [["com.badlogic.gdx.utils.Array" "renderables"] ["com.badlogic.gdx.utils.Pool" "pool"]], :text "Traverses the Node hierarchy and collects {@link Renderable} instances for every node with a graphical representation.\n Renderables are obtained from the provided pool. The resulting array can be rendered via a {@link ModelBatch}.", :name ":get-renderables"}]}]], :name "model!", :type :code, :raw "(defmacro model!\n  [entity k & options]\n  `(let [^ModelInstance object# (u/get-obj ~entity :object)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>model</code>.</p>"} {:raw* nil, :arglists [(model? entity)], :java [], :name "model?", :type :code, :raw "(defn model?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) ModelInstance))", :docstring "<p>Returns true if <code>entity</code> is a <code>model</code>.</p>"} {:raw* "(defn model-builder*\n  []\n  (ModelBuilder.))", :arglists [(model-builder & options)], :java [["model-builder" {:text "Helper class to create {@link Model}s from code. To start building use the {@link #begin()} method, when finished building use\n the {@link #end()} method. The end method returns the model just build. Building cannot be nested, only one model (per\n ModelBuilder) can be build at the time. The same ModelBuilder can be used to build multiple models sequential. Use the\n {@link #node()} method to start a new node. Use one of the #part(...) methods to add a part within a node. The\n {@link #part(String, int, VertexAttributes, Material)} method will return a {@link MeshPartBuilder} which can be used to build\n the node part.", :items [{:args [], :text "Begin building a new model", :name ":begin"} {:args [["float" "x1"] ["float" "y1"] ["float" "z1"] ["float" "x2"] ["float" "y2"] ["float" "z2"] ["float" "cap-length"] ["float" "stem-thickness"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with an arrow.\n The resources the Material might contain are not managed, \n use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-arrow"} {:args [["Vector3" "from"] ["Vector3" "to"] ["Material" "material"] ["long" "attributes"]], :type "Model", :name ":create-arrow"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a box shape. The resources the Material might contain are\n not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-box"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a box shape. The resources the Material might contain are\n not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-box"} {:args [["float" "radius"] ["float" "height"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a capsule shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-capsule"} {:args [["float" "radius"] ["float" "height"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a capsule shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-capsule"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a cone shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cone"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a cone shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cone"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"] ["float" "angle-from"] ["float" "angle-to"]], :type "Model", :text "Convenience method to create a model with a single node containing a cone shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cone"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"] ["float" "angle-from"] ["float" "angle-to"]], :type "Model", :text "Convenience method to create a model with a single node containing a cone shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cone"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a cylinder shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cylinder"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a cylinder shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cylinder"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"] ["float" "angle-from"] ["float" "angle-to"]], :type "Model", :text "Convenience method to create a model with a single node containing a cylinder shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cylinder"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"] ["float" "angle-from"] ["float" "angle-to"]], :type "Model", :text "Convenience method to create a model with a single node containing a cylinder shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cylinder"} {:args [["int" "x-divisions"] ["int" "z-divisions"] ["float" "x-size"] ["float" "z-size"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model which represents a grid of lines on the XZ plane.\n The resources the Material might contain are not managed, \n use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-line-grid"} {:args [["float" "x00"] ["float" "y00"] ["float" "z00"] ["float" "x10"] ["float" "y10"] ["float" "z10"] ["float" "x11"] ["float" "y11"] ["float" "z11"] ["float" "x01"] ["float" "y01"] ["float" "z01"] ["float" "normal-x"] ["float" "normal-y"] ["float" "normal-z"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a rectangle shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-rect"} {:args [["float" "x00"] ["float" "y00"] ["float" "z00"] ["float" "x10"] ["float" "y10"] ["float" "z10"] ["float" "x11"] ["float" "y11"] ["float" "z11"] ["float" "x01"] ["float" "y01"] ["float" "z01"] ["float" "normal-x"] ["float" "normal-y"] ["float" "normal-z"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a rectangle shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-rect"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions-u"] ["int" "divisions-v"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a sphere shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-sphere"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions-u"] ["int" "divisions-v"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a sphere shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-sphere"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions-u"] ["int" "divisions-v"] ["Material" "material"] ["long" "attributes"] ["float" "angle-ufrom"] ["float" "angle-uto"] ["float" "angle-vfrom"] ["float" "angle-vto"]], :type "Model", :text "Convenience method to create a model with a single node containing a sphere shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-sphere"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions-u"] ["int" "divisions-v"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"] ["float" "angle-ufrom"] ["float" "angle-uto"] ["float" "angle-vfrom"] ["float" "angle-vto"]], :type "Model", :text "Convenience method to create a model with a single node containing a sphere shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-sphere"} {:args [["float" "axis-length"] ["float" "cap-length"] ["float" "stem-thickness"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with three orthonormal vectors shapes.\n The resources the Material might contain are not managed, \n use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-xyzcoordinates"} {:args [["float" "axis-length"] ["Material" "material"] ["long" "attributes"]], :type "Model", :name ":create-xyzcoordinates"} {:args [], :type "Model", :text "End building the model.", :name ":end"} {:args [["Disposable" "disposable"]], :text "Add the {@link Disposable} object to the model, causing it to be disposed when the model is disposed.", :name ":manage"} {:args [], :type "Node", :text "Add a node to the model. Use any of the part(...) method to add a NodePart.", :name ":node"} {:args [["String" "id"] ["Model" "model"]], :type "Node", :text "Adds the nodes of the specified model to a new node of the model being build. After this method the given model can no\n longer be used. Do not call the {@link Model#dispose()} method on that model.", :name ":node"} {:args [["MeshPart" "meshpart"] ["Material" "material"]], :text "Adds the specified MeshPart to the current Node. The Mesh will be managed by the model and disposed when the model is\n disposed. The resources the Material might contain are not managed, use {@link #manage(Disposable)} to add those to the\n model.", :name ":part"} {:args [["String" "id"] ["Mesh" "mesh"] ["int" "primitive-type"] ["int" "offset"] ["int" "size"] ["Material" "material"]], :type "MeshPart", :text "Adds the specified mesh part to the current node. The Mesh will be managed by the model and disposed when the model is\n disposed. The resources the Material might contain are not managed, use {@link #manage(Disposable)} to add those to the\n model.", :name ":part"} {:args [["String" "id"] ["Mesh" "mesh"] ["int" "primitive-type"] ["Material" "material"]], :type "MeshPart", :text "Adds the specified mesh part to the current node. The Mesh will be managed by the model and disposed when the model is\n disposed. The resources the Material might contain are not managed, use {@link #manage(Disposable)} to add those to the\n model.", :name ":part"} {:args [["String" "id"] ["int" "primitive-type"] ["long" "attributes"] ["Material" "material"]], :type "MeshPartBuilder", :text "Creates a new MeshPart within the current Node and returns a {@link MeshPartBuilder} which can be used to build the shape of\n the part. If possible a previously used {@link MeshPartBuilder} will be reused, to reduce the number of mesh binds.\n Therefore you can only build one part at a time. The resources the Material might contain are not managed, use\n {@link #manage(Disposable)} to add those to the model.", :name ":part"}]}]], :name "model-builder", :type :code, :raw "(defmacro model-builder\n  [& options]\n  `(let [^ModelBuilder object# (model-builder*)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.html'>ModelBuilder</a>.</p><pre>\n&#40;model-builder&#41;\n</pre>"} {:raw* nil, :arglists [(model-builder! object k & options)], :java [["model-builder!" {:text "Helper class to create {@link Model}s from code. To start building use the {@link #begin()} method, when finished building use\n the {@link #end()} method. The end method returns the model just build. Building cannot be nested, only one model (per\n ModelBuilder) can be build at the time. The same ModelBuilder can be used to build multiple models sequential. Use the\n {@link #node()} method to start a new node. Use one of the #part(...) methods to add a part within a node. The\n {@link #part(String, int, VertexAttributes, Material)} method will return a {@link MeshPartBuilder} which can be used to build\n the node part.", :items [{:args [], :text "Begin building a new model", :name ":begin"} {:args [["float" "x1"] ["float" "y1"] ["float" "z1"] ["float" "x2"] ["float" "y2"] ["float" "z2"] ["float" "cap-length"] ["float" "stem-thickness"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with an arrow.\n The resources the Material might contain are not managed, \n use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-arrow"} {:args [["Vector3" "from"] ["Vector3" "to"] ["Material" "material"] ["long" "attributes"]], :type "Model", :name ":create-arrow"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a box shape. The resources the Material might contain are\n not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-box"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a box shape. The resources the Material might contain are\n not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-box"} {:args [["float" "radius"] ["float" "height"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a capsule shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-capsule"} {:args [["float" "radius"] ["float" "height"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a capsule shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-capsule"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a cone shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cone"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a cone shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cone"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"] ["float" "angle-from"] ["float" "angle-to"]], :type "Model", :text "Convenience method to create a model with a single node containing a cone shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cone"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"] ["float" "angle-from"] ["float" "angle-to"]], :type "Model", :text "Convenience method to create a model with a single node containing a cone shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cone"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a cylinder shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cylinder"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a cylinder shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cylinder"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["Material" "material"] ["long" "attributes"] ["float" "angle-from"] ["float" "angle-to"]], :type "Model", :text "Convenience method to create a model with a single node containing a cylinder shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cylinder"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"] ["float" "angle-from"] ["float" "angle-to"]], :type "Model", :text "Convenience method to create a model with a single node containing a cylinder shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-cylinder"} {:args [["int" "x-divisions"] ["int" "z-divisions"] ["float" "x-size"] ["float" "z-size"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model which represents a grid of lines on the XZ plane.\n The resources the Material might contain are not managed, \n use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-line-grid"} {:args [["float" "x00"] ["float" "y00"] ["float" "z00"] ["float" "x10"] ["float" "y10"] ["float" "z10"] ["float" "x11"] ["float" "y11"] ["float" "z11"] ["float" "x01"] ["float" "y01"] ["float" "z01"] ["float" "normal-x"] ["float" "normal-y"] ["float" "normal-z"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a rectangle shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-rect"} {:args [["float" "x00"] ["float" "y00"] ["float" "z00"] ["float" "x10"] ["float" "y10"] ["float" "z10"] ["float" "x11"] ["float" "y11"] ["float" "z11"] ["float" "x01"] ["float" "y01"] ["float" "z01"] ["float" "normal-x"] ["float" "normal-y"] ["float" "normal-z"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a rectangle shape. The resources the Material might\n contain are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-rect"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions-u"] ["int" "divisions-v"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a sphere shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-sphere"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions-u"] ["int" "divisions-v"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with a single node containing a sphere shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-sphere"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions-u"] ["int" "divisions-v"] ["Material" "material"] ["long" "attributes"] ["float" "angle-ufrom"] ["float" "angle-uto"] ["float" "angle-vfrom"] ["float" "angle-vto"]], :type "Model", :text "Convenience method to create a model with a single node containing a sphere shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-sphere"} {:args [["float" "width"] ["float" "height"] ["float" "depth"] ["int" "divisions-u"] ["int" "divisions-v"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"] ["float" "angle-ufrom"] ["float" "angle-uto"] ["float" "angle-vfrom"] ["float" "angle-vto"]], :type "Model", :text "Convenience method to create a model with a single node containing a sphere shape. The resources the Material might contain\n are not managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-sphere"} {:args [["float" "axis-length"] ["float" "cap-length"] ["float" "stem-thickness"] ["int" "divisions"] ["int" "primitive-type"] ["Material" "material"] ["long" "attributes"]], :type "Model", :text "Convenience method to create a model with three orthonormal vectors shapes.\n The resources the Material might contain are not managed, \n use {@link Model#manageDisposable(Disposable)} to add those to the model.", :name ":create-xyzcoordinates"} {:args [["float" "axis-length"] ["Material" "material"] ["long" "attributes"]], :type "Model", :name ":create-xyzcoordinates"} {:args [], :type "Model", :text "End building the model.", :name ":end"} {:args [["Disposable" "disposable"]], :text "Add the {@link Disposable} object to the model, causing it to be disposed when the model is disposed.", :name ":manage"} {:args [], :type "Node", :text "Add a node to the model. Use any of the part(...) method to add a NodePart.", :name ":node"} {:args [["String" "id"] ["Model" "model"]], :type "Node", :text "Adds the nodes of the specified model to a new node of the model being build. After this method the given model can no\n longer be used. Do not call the {@link Model#dispose()} method on that model.", :name ":node"} {:args [["MeshPart" "meshpart"] ["Material" "material"]], :text "Adds the specified MeshPart to the current Node. The Mesh will be managed by the model and disposed when the model is\n disposed. The resources the Material might contain are not managed, use {@link #manage(Disposable)} to add those to the\n model.", :name ":part"} {:args [["String" "id"] ["Mesh" "mesh"] ["int" "primitive-type"] ["int" "offset"] ["int" "size"] ["Material" "material"]], :type "MeshPart", :text "Adds the specified mesh part to the current node. The Mesh will be managed by the model and disposed when the model is\n disposed. The resources the Material might contain are not managed, use {@link #manage(Disposable)} to add those to the\n model.", :name ":part"} {:args [["String" "id"] ["Mesh" "mesh"] ["int" "primitive-type"] ["Material" "material"]], :type "MeshPart", :text "Adds the specified mesh part to the current node. The Mesh will be managed by the model and disposed when the model is\n disposed. The resources the Material might contain are not managed, use {@link #manage(Disposable)} to add those to the\n model.", :name ":part"} {:args [["String" "id"] ["int" "primitive-type"] ["long" "attributes"] ["Material" "material"]], :type "MeshPartBuilder", :text "Creates a new MeshPart within the current Node and returns a {@link MeshPartBuilder} which can be used to build the shape of\n the part. If possible a previously used {@link MeshPartBuilder} will be reused, to reduce the number of mesh binds.\n Therefore you can only build one part at a time. The resources the Material might contain are not managed, use\n {@link #manage(Disposable)} to add those to the model.", :name ":part"}]}]], :name "model-builder!", :type :code, :raw "(defmacro model-builder!\n  [object k & options]\n  `(u/call! ^ModelBuilder ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>model-builder</code>.</p>"} {:raw* "(defn material*\n  []\n  (Material.))", :arglists [(material & options)], :java [["material" {:text "", :items [{:args [], :text "Removes all attributes", :name ":clear"} {:args [["Attribute" "arg0"] ["Attribute" "arg1"]], :type "int", :text "Used for sorting attributes", :name ":compare"} {:args [], :type "Material", :text "Create a copy of this material", :name ":copy"} {:args [["Material" "other"]], :type "boolean", :name ":equals"} {:args [["Object" "obj"]], :type "boolean", :name ":equals"} {:args [["long" "type"]], :type "Attribute", :text "Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;", :name ":get"} {:args [["java.lang.Class" "clazz"] ["long" "type"]], :type "Attribute", :text "Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;", :name ":get"} {:args [["com.badlogic.gdx.utils.Array" "out"] ["long" "type"]], :type "Array", :text "Get multiple attributes at once. Example: material.get(out, ColorAttribute.Diffuse | ColorAttribute.Specular |\n TextureAttribute.Diffuse);", :name ":get"} {:args [], :type "long", :name ":get-mask"} {:args [["long" "type"]], :type "boolean", :name ":has"} {:args [], :type "Iterator", :text "Used for iterating through the attributes", :name ":iterator"} {:args [["long" "mask"]], :text "Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.ID); Can also be used to remove multiple\n attributes also, i.e. remove(AttributeA.ID | AttributeB.ID);", :name ":remove"} {:args [["Attributes" "other"] ["boolean" "compare-values"]], :type "boolean", :text "Check if this collection has the same attributes as the other collection. If compareValues is true, it also compares the\n values of each attribute.", :name ":same"} {:args [["Attributes" "other"]], :type "boolean", :text "See {@link #same(Attributes, boolean)}", :name ":same"} {:args [["Attribute" "attribute"]], :text "Add a attribute to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"] ["Attribute" "attribute3"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"] ["Attribute" "attribute3"] ["Attribute" "attribute4"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["com.badlogic.gdx.graphics.g3d.Attribute[]" "attributes"]], :text "Add an array of attributes to this material. If the material already contains an attribute of the same type it is\n overwritten.", :name ":set"} {:args [["java.lang.Iterable" "attributes"]], :text "Add an array of attributes to this material. If the material already contains an attribute of the same type it is\n overwritten.", :name ":set"} {:args [], :type "int", :name ":size"} {:args [], :text "Sort the attributes by their ID", :name ":sort"}]}]], :name "material", :type :code, :raw "(defmacro material\n  [& options]\n  `(let [^Material object# (material*)]\n     (u/calls! object# ~@options)))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/Material.html'>Material</a>.</p><pre>\n&#40;material&#41;\n</pre>"} {:raw* nil, :arglists [(material! object k & options)], :java [["material!" {:text "", :items [{:args [], :text "Removes all attributes", :name ":clear"} {:args [["Attribute" "arg0"] ["Attribute" "arg1"]], :type "int", :text "Used for sorting attributes", :name ":compare"} {:args [], :type "Material", :text "Create a copy of this material", :name ":copy"} {:args [["Material" "other"]], :type "boolean", :name ":equals"} {:args [["Object" "obj"]], :type "boolean", :name ":equals"} {:args [["long" "type"]], :type "Attribute", :text "Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;", :name ":get"} {:args [["java.lang.Class" "clazz"] ["long" "type"]], :type "Attribute", :text "Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;", :name ":get"} {:args [["com.badlogic.gdx.utils.Array" "out"] ["long" "type"]], :type "Array", :text "Get multiple attributes at once. Example: material.get(out, ColorAttribute.Diffuse | ColorAttribute.Specular |\n TextureAttribute.Diffuse);", :name ":get"} {:args [], :type "long", :name ":get-mask"} {:args [["long" "type"]], :type "boolean", :name ":has"} {:args [], :type "Iterator", :text "Used for iterating through the attributes", :name ":iterator"} {:args [["long" "mask"]], :text "Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.ID); Can also be used to remove multiple\n attributes also, i.e. remove(AttributeA.ID | AttributeB.ID);", :name ":remove"} {:args [["Attributes" "other"] ["boolean" "compare-values"]], :type "boolean", :text "Check if this collection has the same attributes as the other collection. If compareValues is true, it also compares the\n values of each attribute.", :name ":same"} {:args [["Attributes" "other"]], :type "boolean", :text "See {@link #same(Attributes, boolean)}", :name ":same"} {:args [["Attribute" "attribute"]], :text "Add a attribute to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"] ["Attribute" "attribute3"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["Attribute" "attribute1"] ["Attribute" "attribute2"] ["Attribute" "attribute3"] ["Attribute" "attribute4"]], :text "Add multiple attributes to this material. If the material already contains an attribute of the same type it is overwritten.", :name ":set"} {:args [["com.badlogic.gdx.graphics.g3d.Attribute[]" "attributes"]], :text "Add an array of attributes to this material. If the material already contains an attribute of the same type it is\n overwritten.", :name ":set"} {:args [["java.lang.Iterable" "attributes"]], :text "Add an array of attributes to this material. If the material already contains an attribute of the same type it is\n overwritten.", :name ":set"} {:args [], :type "int", :name ":size"} {:args [], :text "Sort the attributes by their ID", :name ":sort"}]}]], :name "material!", :type :code, :raw "(defmacro material!\n  [object k & options]\n  `(u/call! ^Material ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>material</code>.</p>"} {:raw* nil, :arglists [(attribute type & args)], :java [["attribute" {:text "", :items [{:args [["long" "type"]], :name ":float"} {:args [["long" "type"] ["float" "value"]], :name ":float"}]}] ["attribute" {:text "", :items [{:args [["long" "type"]], :name ":cubemap"} {:args [["long" "type"] ["com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor" "texture-description"]], :name ":cubemap"} {:args [["long" "type"] ["Cubemap" "texture"]], :name ":cubemap"} {:args [["CubemapAttribute" "copy-from"]], :name ":cubemap"}]}] ["attribute" {:text "", :items [{:args [], :name ":blending"} {:args [["boolean" "blended"] ["int" "source-func"] ["int" "dest-func"] ["float" "opacity"]], :name ":blending"} {:args [["int" "source-func"] ["int" "dest-func"] ["float" "opacity"]], :name ":blending"} {:args [["int" "source-func"] ["int" "dest-func"]], :name ":blending"} {:args [["boolean" "blended"] ["float" "opacity"]], :name ":blending"} {:args [["float" "opacity"]], :name ":blending"} {:args [["BlendingAttribute" "copy-from"]], :name ":blending"}]}] ["attribute" {:text "", :items [{:args [["long" "type"]], :name ":int"} {:args [["long" "type"] ["int" "value"]], :name ":int"}]}] ["attribute" {:text "", :items [{:args [], :name ":depth-test"} {:args [["boolean" "depth-mask"]], :name ":depth-test"} {:args [["int" "depth-func"]], :name ":depth-test"} {:args [["int" "depth-func"] ["boolean" "depth-mask"]], :name ":depth-test"} {:args [["int" "depth-func"] ["float" "depth-range-near"] ["float" "depth-range-far"]], :name ":depth-test"} {:args [["int" "depth-func"] ["float" "depth-range-near"] ["float" "depth-range-far"] ["boolean" "depth-mask"]], :name ":depth-test"} {:args [["long" "type"] ["int" "depth-func"] ["float" "depth-range-near"] ["float" "depth-range-far"] ["boolean" "depth-mask"]], :name ":depth-test"} {:args [["DepthTestAttribute" "rhs"]], :name ":depth-test"}]}] ["attribute" {:text "", :items [{:args [["long" "type"]], :name ":color"} {:args [["long" "type"] ["Color" "color"]], :name ":color"} {:args [["long" "type"] ["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":color"} {:args [["ColorAttribute" "copy-from"]], :name ":color"}]}] ["attribute" {:text "", :items [{:args [["long" "type"]], :name ":texture"} {:args [["long" "type"] ["com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor" "texture-description"]], :name ":texture"} {:args [["long" "type"] ["Texture" "texture"]], :name ":texture"} {:args [["TextureAttribute" "copy-from"]], :name ":texture"}]}]], :name "attribute", :type :code, :raw "(defmacro attribute\n  [type & args]\n  `(~(attribute-init type) ~@args))", :docstring "<p>Returns a subclass of <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/Attribute.html'>Attribute</a>.</p><pre>\n&#40;attribute :color &#40;attribute-type :color :diffuse&#41; &#40;color :blue&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(attribute-type type k)], :java [["attribute-type" {:text "", :items [{:name ":float :alpha-test"} {:name ":float :alpha-test-alias"} {:name ":float :shininess"} {:name ":float :shininess-alias"}]}] ["attribute-type" {:text "", :items [{:name ":cubemap :environment-map"} {:name ":cubemap :environment-map-alias"}]}] ["attribute-type" {:text "", :items [{:name ":blending :alias"} {:name ":blending :type"}]}] ["attribute-type" {:text "", :items [{:name ":int :cull-face"} {:name ":int :cull-face-alias"}]}] ["attribute-type" {:text "", :items [{:name ":depth-test :alias"} {:name ":depth-test :type"}]}] ["attribute-type" {:text "", :items [{:name ":color :ambient"} {:name ":color :ambient-alias"} {:name ":color :ambient-light"} {:name ":color :ambient-light-alias"} {:name ":color :diffuse"} {:name ":color :diffuse-alias"} {:name ":color :emissive"} {:name ":color :emissive-alias"} {:name ":color :fog"} {:name ":color :fog-alias"} {:name ":color :reflection"} {:name ":color :reflection-alias"} {:name ":color :specular"} {:name ":color :specular-alias"}]}] ["attribute-type" {:text "", :items [{:name ":texture :bump"} {:name ":texture :bump-alias"} {:name ":texture :diffuse"} {:name ":texture :diffuse-alias"} {:name ":texture :normal"} {:name ":texture :normal-alias"} {:name ":texture :specular"} {:name ":texture :specular-alias"}]}]], :name "attribute-type", :type :code, :raw "(defmacro attribute-type\n  [type k]\n  `~(u/gdx-field :graphics :g3d :attributes\n                 (str (u/key->pascal type) \"Attribute\")\n                 (u/key->pascal k)))", :docstring "<p>Returns a static field in a subclass of <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/Attribute.html'>Attribute</a>.</p><pre>\n&#40;attribute-type :color :diffuse&#41;\n</pre>"} {:raw* nil, :arglists [(attribute! type k & options)], :java [["attribute!" {:text "", :items [{:args [["float" "value"]], :type "FloatAttribute", :name ":float :create-alpha-test"} {:args [["float" "value"]], :type "FloatAttribute", :name ":float :create-shininess"} {:args [["long" "type"]], :type "String", :name ":float :get-attribute-alias"} {:args [["String" "alias"]], :type "long", :name ":float :get-attribute-type"}]}] ["attribute!" {:text "", :items [{:args [["long" "type"]], :type "String", :name ":cubemap :get-attribute-alias"} {:args [["String" "alias"]], :type "long", :name ":cubemap :get-attribute-type"} {:args [["long" "mask"]], :type "boolean", :name ":cubemap :is"}]}] ["attribute!" {:text "", :items [{:args [["long" "type"]], :type "String", :name ":blending :get-attribute-alias"} {:args [["String" "alias"]], :type "long", :name ":blending :get-attribute-type"} {:args [["long" "mask"]], :type "boolean", :name ":blending :is"}]}] ["attribute!" {:text "", :items [{:args [["int" "value"]], :type "IntAttribute", :name ":int :create-cull-face"} {:args [["long" "type"]], :type "String", :name ":int :get-attribute-alias"} {:args [["String" "alias"]], :type "long", :name ":int :get-attribute-type"}]}] ["attribute!" {:text "", :items [{:args [["long" "type"]], :type "String", :name ":depth-test :get-attribute-alias"} {:args [["String" "alias"]], :type "long", :name ":depth-test :get-attribute-type"} {:args [["long" "mask"]], :type "boolean", :name ":depth-test :is"}]}] ["attribute!" {:text "", :items [{:args [["Color" "color"]], :type "ColorAttribute", :name ":color :create-ambient"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "ColorAttribute", :name ":color :create-ambient"} {:args [["Color" "color"]], :type "ColorAttribute", :name ":color :create-diffuse"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "ColorAttribute", :name ":color :create-diffuse"} {:args [["Color" "color"]], :type "ColorAttribute", :name ":color :create-reflection"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "ColorAttribute", :name ":color :create-reflection"} {:args [["Color" "color"]], :type "ColorAttribute", :name ":color :create-specular"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "ColorAttribute", :name ":color :create-specular"} {:args [["long" "type"]], :type "String", :name ":color :get-attribute-alias"} {:args [["String" "alias"]], :type "long", :name ":color :get-attribute-type"} {:args [["long" "mask"]], :type "boolean", :name ":color :is"}]}] ["attribute!" {:text "", :items [{:args [["Texture" "texture"]], :type "TextureAttribute", :name ":texture :create-diffuse"} {:args [["Texture" "texture"]], :type "TextureAttribute", :name ":texture :create-specular"} {:args [["long" "type"]], :type "String", :name ":texture :get-attribute-alias"} {:args [["String" "alias"]], :type "long", :name ":texture :get-attribute-type"} {:args [["long" "mask"]], :type "boolean", :name ":texture :is"}]}]], :name "attribute!", :type :code, :raw "(defmacro attribute!\n  [type k & options]\n  `(~(u/gdx-field :graphics :g3d :attributes\n                  (str (u/key->pascal type) \"Attribute\")\n                  (u/key->camel k))\n     ~@options))", :docstring "<p>Calls a static method in a subclass of <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g3d/Attribute.html'>Attribute</a>.</p><pre>\n&#40;attribute! :color :create-diffuse &#40;color :blue&#41;&#41;\n</pre>"})} {:ns "play-clj.g3d-physics", :groups ({:raw* "(defn bullet-3d*\n  [type]\n  @init-bullet\n  (case type\n    :rigid (discrete-dynamics)\n    :soft-rigid (soft-rigid-dynamics)\n    (u/throw-key-not-found type)))", :arglists [(bullet-3d type & options)], :java [], :name "bullet-3d", :type :code, :raw "(defmacro bullet-3d\n  [type & options]\n  `(let [world# (bullet-3d* ~type)\n         ^btDynamicsWorld object# (:object world#)]\n     (u/calls! object# ~@options)\n     world#))", :docstring "<p>Returns a world based on btDynamicsWorld.</p><pre>\n&#40;bullet-3d :rigid&#41; ; can only handle rigid bodies\n&#40;bullet-3d :soft-rigid&#41; ; can handle soft and rigid bodies\n</pre>"} {:raw* nil, :arglists [(bullet-3d! screen k & options)], :java [], :name "bullet-3d!", :type :code, :raw "(defmacro bullet-3d!\n  [screen k & options]\n  `(let [^btDynamicsWorld object# (:object (u/get-obj ~screen :world))]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>bullet-3d</code>.</p>"} {:raw* "(defn rigid-body*\n  [info]\n  (assoc (Body3D. (btRigidBody. info))\n         :info info))", :arglists [(rigid-body info & options)], :java [], :name "rigid-body", :type :code, :raw "(defmacro rigid-body\n  [info & options]\n  `(let [body# (rigid-body* ~info)\n         ^btRigidBody object# (:object body#)]\n     (u/calls! object# ~@options)\n     body#))", :docstring "<p>Returns a body based on btRigidBody.</p>"} {:raw* nil, :arglists [(rigid-body! object k & options)], :java [], :name "rigid-body!", :type :code, :raw "(defmacro rigid-body!\n  [object k & options]\n  `(let [^btRigidBody object# (:object (u/get-obj ~object :body))]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>rigid-body</code>.</p>"} {:raw* nil, :arglists [(rigid-body-info mass motion-state collision-shape local-inertia)], :java [], :name "rigid-body-info", :type :code, :raw "(defn rigid-body-info\n  [mass motion-state collision-shape local-inertia]\n  (btRigidBody$btRigidBodyConstructionInfo.\n    mass motion-state collision-shape local-inertia))", :docstring "<p>Returns a btRigidBodyConstructionInfo.</p>"} {:raw* "(defn soft-body*\n  [info]\n  (assoc (Body3D. (btSoftBody. info))\n         :info info))", :arglists [(soft-body info & options)], :java [], :name "soft-body", :type :code, :raw "(defmacro soft-body\n  [info & options]\n  `(let [body# (soft-body* ~info)\n         ^btSoftBody object# (:object body#)]\n     (u/calls! object# ~@options)\n     body#))", :docstring "<p>Returns a body based on btSoftBody.</p>"} {:raw* nil, :arglists [(soft-body! object k & options)], :java [], :name "soft-body!", :type :code, :raw "(defmacro soft-body!\n  [object k & options]\n  `(let [^btSoftBody object# (:object (u/get-obj ~object :body))]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on a <code>soft-body</code>.</p>"} {:raw* nil, :arglists [(soft-body-info)], :java [], :name "soft-body-info", :type :code, :raw "(defn soft-body-info\n  []\n  (btSoftBodyWorldInfo.))", :docstring "<p>Returns a btSoftBodyWorldInfo.</p>"} {:raw* nil, :arglists [(add-body! screen body)], :java [], :name "add-body!", :type :code, :raw "(defn add-body!\n  [screen body]\n  (cond\n    (isa? (type (:object body)) btRigidBody)\n    (bullet-3d! screen :add-rigid-body (:object body))\n    (isa? (type (:object body)) btSoftBody)\n    (bullet-3d! screen :add-soft-body (:object body)))\n  body)", :docstring "<p>Adds the <code>body</code> to the <code>screen</code> and returns it.</p><pre>\n&#40;add-body! screen &#40;rigid-body info&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(body-position! entity x y z)], :java [], :name "body-position!", :type :code, :raw "(defn body-position!\n  [entity x y z]\n  (let [^btCollisionObject object (:object (u/get-obj entity :body))]\n    (.setWorldTransform object\n      (doto (m/matrix-4*)\n        (m/matrix-4! :set-translation x y z)))))", :docstring "<p>Changes the position of the body in <code>entity</code>.</p>"} {:raw* nil, :arglists [(body-x! entity x)], :java [], :name "body-x!", :type :code, :raw "(defn body-x!\n  [entity x]\n  (body-position! entity x (body-y entity) (body-z entity)))", :docstring "<p>Changes the <code>x</code> of the body in <code>entity</code>.</p>"} {:raw* nil, :arglists [(body-y! entity y)], :java [], :name "body-y!", :type :code, :raw "(defn body-y!\n  [entity y]\n  (body-position! entity (body-x entity) y (body-z entity)))", :docstring "<p>Changes the <code>y</code> of the body in <code>entity</code>.</p>"} {:raw* nil, :arglists [(body-z! entity z)], :java [], :name "body-z!", :type :code, :raw "(defn body-z!\n  [entity z]\n  (body-position! entity (body-x entity) (body-y entity) z))", :docstring "<p>Changes the <code>z</code> of the body in <code>entity</code>.</p>"} {:raw* nil, :arglists [(first-entity screen entities)], :java [], :name "first-entity", :type :code, :raw "(defn first-entity\n  [screen entities]\n  (-> (u/get-obj screen :first-body)\n      (find-body entities)))", :docstring "<p>Returns the first entity in a contact. May only be used in contact functions such as :on-begin-contact.</p>"} {:raw* nil, :arglists [(second-entity screen entities)], :java [], :name "second-entity", :type :code, :raw "(defn second-entity\n  [screen entities]\n  (-> (u/get-obj screen :second-body)\n      (find-body entities)))", :docstring "<p>Returns the second entity in a contact. May only be used in contact functions such as :on-begin-contact.</p>"} {:raw* "(defn box-shape*\n  [box-half-extents]\n  (btBoxShape. box-half-extents))", :arglists [(box-shape box-half-extents & options)], :java [], :name "box-shape", :type :code, :raw "(defmacro box-shape\n  [box-half-extents & options]\n  `(u/calls! ^btBoxShape (box-shape* ~box-half-extents) ~@options))", :docstring "<p>Returns a btSphereShape.</p>"} {:raw* nil, :arglists [(box-shape! object k & options)], :java [], :name "box-shape!", :type :code, :raw "(defmacro box-shape!\n  [object k & options]\n  `(u/call! ^btBoxShape ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>box-shape</code>.</p>"} {:raw* "(defn capsule-shape*\n  [radius height]\n  (btCapsuleShape. radius height))", :arglists [(capsule-shape radius height & options)], :java [], :name "capsule-shape", :type :code, :raw "(defmacro capsule-shape\n  [radius height & options]\n  `(u/calls! ^btCapsuleShape (capsule-shape* ~radius ~height) ~@options))", :docstring "<p>Returns a btCapsuleShape.</p>"} {:raw* nil, :arglists [(capsule-shape! object k & options)], :java [], :name "capsule-shape!", :type :code, :raw "(defmacro capsule-shape!\n  [object k & options]\n  `(u/call! ^btCapsuleShape ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>capsule-shape</code>.</p>"} {:raw* "(defn cone-shape*\n  [radius height]\n  (btConeShape. radius height))", :arglists [(cone-shape radius height & options)], :java [], :name "cone-shape", :type :code, :raw "(defmacro cone-shape\n  [radius height & options]\n  `(u/calls! ^btConeShape (cone-shape* ~radius ~height) ~@options))", :docstring "<p>Returns a btConeShape.</p>"} {:raw* nil, :arglists [(cone-shape! object k & options)], :java [], :name "cone-shape!", :type :code, :raw "(defmacro cone-shape!\n  [object k & options]\n  `(u/call! ^btConeShape ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>cone-shape</code>.</p>"} {:raw* "(defn cylinder-shape*\n  [half-extents]\n  (btCylinderShape. half-extents))", :arglists [(cylinder-shape half-extents & options)], :java [], :name "cylinder-shape", :type :code, :raw "(defmacro cylinder-shape\n  [half-extents & options]\n  `(u/calls! ^btCylinderShape (cylinder-shape* ~half-extents) ~@options))", :docstring "<p>Returns a btCylinderShape.</p>"} {:raw* nil, :arglists [(cylinder-shape! object k & options)], :java [], :name "cylinder-shape!", :type :code, :raw "(defmacro cylinder-shape!\n  [object k & options]\n  `(u/call! ^btCylinderShape ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>cylinder-shape</code>.</p>"} {:raw* "(defn sphere-shape*\n  [radius]\n  (btSphereShape. radius))", :arglists [(sphere-shape radius & options)], :java [], :name "sphere-shape", :type :code, :raw "(defmacro sphere-shape\n  [radius & options]\n  `(u/calls! ^btSphereShape (sphere-shape* ~radius) ~@options))", :docstring "<p>Returns a btSphereShape.</p>"} {:raw* nil, :arglists [(sphere-shape! object k & options)], :java [], :name "sphere-shape!", :type :code, :raw "(defmacro sphere-shape!\n  [object k & options]\n  `(u/call! ^btSphereShape ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>sphere-shape</code>.</p>"} {:raw* nil, :arglists [(step! screen) (step! screen entities)], :java [], :name "step!", :type :code, :raw "(defn step!\n  ([{:keys [delta-time max-sub-steps time-step]\n     :or {max-sub-steps 5 time-step (/ 1 60)}\n     :as screen}]\n    (bullet-3d! screen :step-simulation delta-time max-sub-steps time-step))\n  ([screen entities]\n    (step! screen)\n    (map (fn [e]\n           (if (:body e)\n             (assoc e\n                    :x (body-x e)\n                    :y (body-y e)\n                    :z (body-z e))\n             e))\n         entities)))", :docstring "<p>Runs the physics simulations for a single frame and optionally returns the <code>entities</code> with their positions updated.</p>"})} {:ns "play-clj.math", :groups ({:raw* nil, :arglists [(geometry! k & options)], :java [["geometry!" {:text "", :items [{:args [["Vector2" "barycentric"]], :type "boolean", :text "Returns true if the barycentric coordinates are inside the triangle.", :name ":barycoord-inside-triangle"} {:args [["Vector2" "barycentric"] ["Vector2" "a"] ["Vector2" "b"] ["Vector2" "c"] ["Vector2" "interpolated-out"]], :type "Vector2", :text "Returns interpolated values given the barycentric coordinates of a point in a triangle and the values at each vertex.", :name ":from-barycoord"} {:args [["Vector2" "barycentric"] ["float" "a"] ["float" "b"] ["float" "c"] ["Vector2" "interpolated-out"]], :type "Vector2", :text "Returns interpolated values given the barycentric coordinates of a point in a triangle and the values at each vertex.", :name ":from-barycoord"} {:args [["float" "a"] ["float" "b"] ["float" "c"]], :type "float", :text "Returns the lowest positive root of the quadric equation given by a* x * x + b * x + c = 0. If no solution is given\n Float.Nan is returned.", :name ":lowest-positive-root"} {:args [["float[]" "polygon"] ["int" "offset"] ["int" "count"]], :type "float", :name ":polygon-area"} {:args [["float[]" "polygon"] ["int" "offset"] ["int" "count"] ["Vector2" "centroid"]], :type "Vector2", :text "Returns the centroid for the specified non-self-intersecting polygon.", :name ":polygon-centroid"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"] ["float" "x4"] ["float" "y4"] ["Vector2" "centroid"]], :type "Vector2", :name ":quadrilateral-centroid"} {:args [["Vector2" "p"] ["Vector2" "a"] ["Vector2" "b"] ["Vector2" "c"] ["Vector2" "barycentric-out"]], :type "Vector2", :text "Computes the barycentric coordinates v,w for the specified point in the triangle.\n <p>\n If barycentric.x >= 0 && barycentric.y >= 0 && barycentric.x + barycentric.y <= 1 then the point is inside the triangle.\n <p>\n If vertices a,b,c have values aa,bb,cc then to get an interpolated value at point p:\n \n <pre>\n GeometryUtils.barycentric(p, a, b, c, barycentric);\n float u = 1.f - barycentric.x - barycentric.y;\n float x = u * aa.x + barycentric.x * bb.x + barycentric.y * cc.x;\n float y = u * aa.y + barycentric.x * bb.y + barycentric.y * cc.y;\n </pre>", :name ":to-barycoord"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"]], :type "float", :name ":triangle-area"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"] ["Vector2" "centroid"]], :type "Vector2", :name ":triangle-centroid"}]}]], :name "geometry!", :type :code, :raw "(defmacro geometry!\n  [k & options]\n  `(~(u/gdx-field :math :GeometryUtils (u/key->camel k)) ~@options))", :docstring "<p>Calls a single static method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/GeometryUtils.html'>GeometryUtils</a>.</p>"} {:raw* nil, :arglists [(interpolation k)], :java [["interpolation" {:text "Takes a linear value in the range of 0-1 and outputs a (usually) non-linear, interpolated value.", :items [{:name ":bounce"} {:name ":bounce-in"} {:name ":bounce-out"} {:name ":elastic"} {:name ":elastic-in"} {:name ":elastic-out"} {:name ":exp"} {:name ":exp-in"} {:name ":exp-out"} {:name ":pow"} {:name ":pow-in"} {:name ":pow-out"} {:name ":swing"} {:name ":swing-in"} {:name ":swing-out"}]}]], :name "interpolation", :type :code, :raw "(defmacro interpolation\n  [k]\n  `~(u/gdx-class :math :Interpolation (u/key->pascal k)))", :docstring "<p>Returns a static class in <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Interpolation.html'>Interpolation</a>.</p><pre>\n&#40;interpolation :bounce&#41;\n</pre>"} {:raw* nil, :arglists [(intersector! k & options)], :java [["intersector!" {:text "Class offering various static methods for intersection testing between different geometric objects.", :items [{:args [["Vector2" "start"] ["Vector2" "end"] ["Vector2" "point"]], :type "float", :text "Returns the distance between the given line segment and point.", :name ":distance-line-point"} {:args [["float" "start-x"] ["float" "start-y"] ["float" "end-x"] ["float" "end-y"] ["float" "point-x"] ["float" "point-y"]], :type "float", :text "Returns the distance between the given line and point. Note the specified line is not a line segment.", :name ":distance-line-point"} {:args [["float" "start-x"] ["float" "start-y"] ["float" "end-x"] ["float" "end-y"] ["float" "point-x"] ["float" "point-y"]], :type "float", :text "Returns the distance between the given segment and point.", :name ":distance-segment-point"} {:args [["Vector2" "start"] ["Vector2" "end"] ["Vector2" "point"]], :type "float", :text "Returns the distance between the given segment and point.", :name ":distance-segment-point"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "x2"] ["float" "y2"] ["float" "z2"] ["Plane" "plane"] ["Vector3" "intersection"]], :type "float", :text "Intersects a line and a plane. The intersection is returned as the distance from the first point to the plane. In case an\n intersection happened, the return value is in the range [0,1]. The intersection point can be recovered by point1 + t *\n (point2 - point1) where t is the return value of this method.", :name ":intersect-line-plane"} {:args [["Vector2" "p1"] ["Vector2" "p2"] ["Polygon" "polygon"]], :type "boolean", :text "Check whether the given line and {@link Polygon} intersect.", :name ":intersect-line-polygon"} {:args [["Vector2" "p1"] ["Vector2" "p2"] ["Vector2" "p3"] ["Vector2" "p4"] ["Vector2" "intersection"]], :type "boolean", :text "Intersects the two lines and returns the intersection point in intersection.", :name ":intersect-lines"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"] ["float" "x4"] ["float" "y4"] ["Vector2" "intersection"]], :type "boolean", :text "Intersects the two lines and returns the intersection point in intersection.", :name ":intersect-lines"} {:args [["Ray" "ray"] ["BoundingBox" "box"] ["Vector3" "intersection"]], :type "boolean", :text "Intersects a {@link Ray} and a {@link BoundingBox}, returning the intersection point in intersection.", :name ":intersect-ray-bounds"} {:args [["Ray" "ray"] ["BoundingBox" "box"]], :type "boolean", :text "Quick check whether the given {@link Ray} and {@link BoundingBox} intersect.", :name ":intersect-ray-bounds-fast"} {:args [["Ray" "ray"] ["Vector3" "center"] ["Vector3" "dimensions"]], :type "boolean", :text "Quick check whether the given {@link Ray} and {@link BoundingBox} intersect.", :name ":intersect-ray-bounds-fast"} {:args [["Ray" "ray"] ["Plane" "plane"] ["Vector3" "intersection"]], :type "boolean", :text "Intersects a {@link Ray} and a {@link Plane}. The intersection point is stored in intersection in case an intersection is\n present.", :name ":intersect-ray-plane"} {:args [["Ray" "ray"] ["Vector3" "center"] ["float" "radius"] ["Vector3" "intersection"]], :type "boolean", :text "Intersects a {@link Ray} and a sphere, returning the intersection point in intersection.", :name ":intersect-ray-sphere"} {:args [["Ray" "ray"] ["Vector3" "t1"] ["Vector3" "t2"] ["Vector3" "t3"] ["Vector3" "intersection"]], :type "boolean", :text "Intersect a {@link Ray} and a triangle, returning the intersection point in intersection.", :name ":intersect-ray-triangle"} {:args [["Ray" "ray"] ["float[]" "triangles"] ["Vector3" "intersection"]], :type "boolean", :text "Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection", :name ":intersect-ray-triangles"} {:args [["Ray" "ray"] ["float[]" "vertices"] ["short[]" "indices"] ["int" "vertex-size"] ["Vector3" "intersection"]], :type "boolean", :text "Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection", :name ":intersect-ray-triangles"} {:args [["Ray" "ray"] ["java.util.List" "triangles"] ["Vector3" "intersection"]], :type "boolean", :text "Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection", :name ":intersect-ray-triangles"} {:args [["Rectangle" "rectangle1"] ["Rectangle" "rectangle2"] ["Rectangle" "intersection"]], :type "boolean", :text "Determines whether the given rectangles intersect and, if they do, sets the supplied {@code intersection} rectangle to the\n area of overlap.", :name ":intersect-rectangles"} {:args [["Vector2" "start"] ["Vector2" "end"] ["Vector2" "center"] ["float" "square-radius"]], :type "boolean", :text "Returns whether the given line segment intersects the given circle.", :name ":intersect-segment-circle"} {:args [["Vector2" "start"] ["Vector2" "end"] ["Vector2" "point"] ["float" "radius"] ["Vector2" "displacement"]], :type "float", :text "Checks whether the line segment and the circle intersect and returns by how much and in what direction the line has to move\n away from the circle to not intersect.", :name ":intersect-segment-circle-displace"} {:args [["Vector3" "start"] ["Vector3" "end"] ["Plane" "plane"] ["Vector3" "intersection"]], :type "boolean", :name ":intersect-segment-plane"} {:args [["Vector2" "p1"] ["Vector2" "p2"] ["Polygon" "polygon"]], :type "boolean", :text "Check whether the given line segment and {@link Polygon} intersect.", :name ":intersect-segment-polygon"} {:args [["Vector2" "p1"] ["Vector2" "p2"] ["Vector2" "p3"] ["Vector2" "p4"] ["Vector2" "intersection"]], :type "boolean", :text "Intersects the two line segments and returns the intersection point in intersection.", :name ":intersect-segments"} {:args [["float" "x1"] ["float" "y1"] ["float" "x2"] ["float" "y2"] ["float" "x3"] ["float" "y3"] ["float" "x4"] ["float" "y4"] ["Vector2" "intersection"]], :type "boolean", :name ":intersect-segments"} {:args [["com.badlogic.gdx.utils.Array" "polygon"] ["Vector2" "point"]], :type "boolean", :text "Checks whether the given point is in the polygon.", :name ":is-point-in-polygon"} {:args [["float[]" "polygon"] ["int" "offset"] ["int" "count"] ["float" "x"] ["float" "y"]], :type "boolean", :text "Returns true if the specified point is in the polygon.", :name ":is-point-in-polygon"} {:args [["Vector3" "point"] ["Vector3" "t1"] ["Vector3" "t2"] ["Vector3" "t3"]], :type "boolean", :text "Returns whether the given point is inside the triangle. This assumes that the point is on the plane of the triangle. No\n check is performed that this is the case.", :name ":is-point-in-triangle"} {:args [["Vector2" "p"] ["Vector2" "a"] ["Vector2" "b"] ["Vector2" "c"]], :type "boolean", :text "Returns true if the given point is inside the triangle.", :name ":is-point-in-triangle"} {:args [["float" "px"] ["float" "py"] ["float" "ax"] ["float" "ay"] ["float" "bx"] ["float" "by"] ["float" "cx"] ["float" "cy"]], :type "boolean", :text "Returns true if the given point is inside the triangle.", :name ":is-point-in-triangle"} {:args [["java.lang.String[]" "args"]], :name ":main"} {:args [["Vector2" "start"] ["Vector2" "end"] ["Vector2" "point"] ["Vector2" "nearest"]], :type "Vector2", :text "Returns a point on the segment nearest to the specified point.", :name ":nearest-segment-point"} {:args [["float" "start-x"] ["float" "start-y"] ["float" "end-x"] ["float" "end-y"] ["float" "point-x"] ["float" "point-y"] ["Vector2" "nearest"]], :type "Vector2", :text "Returns a point on the segment nearest to the specified point.", :name ":nearest-segment-point"} {:args [["Polygon" "p1"] ["Polygon" "p2"]], :type "boolean", :text "Check whether specified convex polygons overlap.", :name ":overlap-convex-polygons"} {:args [["Polygon" "p1"] ["Polygon" "p2"] ["Intersector.MinimumTranslationVector" "mtv"]], :type "boolean", :text "Check whether specified convex polygons overlap. If they do, optionally obtain a Minimum Translation Vector indicating the\n minimum magnitude vector required to push the polygons out of the collision.", :name ":overlap-convex-polygons"} {:args [["float[]" "verts1"] ["float[]" "verts2"] ["Intersector.MinimumTranslationVector" "mtv"]], :type "boolean", :name ":overlap-convex-polygons"} {:args [["float[]" "verts1"] ["int" "offset1"] ["int" "count1"] ["float[]" "verts2"] ["int" "offset2"] ["int" "count2"] ["Intersector.MinimumTranslationVector" "mtv"]], :type "boolean", :text "Check whether polygons defined by the given vertex arrays overlap. If they do, optionally obtain a Minimum Translation\n Vector indicating the minimum magnitude vector required to push the polygons out of the collision.", :name ":overlap-convex-polygons"} {:args [["Circle" "c1"] ["Circle" "c2"]], :type "boolean", :name ":overlaps"} {:args [["Rectangle" "r1"] ["Rectangle" "r2"]], :type "boolean", :name ":overlaps"} {:args [["Circle" "c"] ["Rectangle" "r"]], :type "boolean", :name ":overlaps"} {:args [["Vector2" "line-point1"] ["Vector2" "line-point2"] ["Vector2" "point"]], :type "int", :text "Determines on which side of the given line the point is. Returns -1 if the point is on the left side of the line, 0 if the\n point is on the line and 1 if the point is on the right side of the line. Left and right are relative to the lines direction\n which is linePoint1 to linePoint2.", :name ":point-line-side"} {:args [["float" "line-point1x"] ["float" "line-point1y"] ["float" "line-point2x"] ["float" "line-point2y"] ["float" "point-x"] ["float" "point-y"]], :type "int", :name ":point-line-side"} {:args [["float[]" "triangle"] ["Plane" "plane"] ["Intersector.SplitTriangle" "split"]], :text "Splits the triangle by the plane. The result is stored in the SplitTriangle instance. Depending on where the triangle is\n relative to the plane, the result can be:\n \n <ul>\n <li>Triangle is fully in front/behind: {@link SplitTriangle#front} or {@link SplitTriangle#back} will contain the original\n triangle, {@link SplitTriangle#total} will be one.</li>\n <li>Triangle has two vertices in front, one behind: {@link SplitTriangle#front} contains 2 triangles,\n {@link SplitTriangle#back} contains 1 triangles, {@link SplitTriangle#total} will be 3.</li>\n <li>Triangle has one vertex in front, two behind: {@link SplitTriangle#front} contains 1 triangle,\n {@link SplitTriangle#back} contains 2 triangles, {@link SplitTriangle#total} will be 3.</li>\n </ul>\n \n The input triangle should have the form: x, y, z, x2, y2, z2, x3, y3, y3. One can add additional attributes per vertex which\n will be interpolated if split, such as texture coordinates or normals. Note that these additional attributes won't be\n normalized, as might be necessary in case of normals.", :name ":split-triangle"}]}]], :name "intersector!", :type :code, :raw "(defmacro intersector!\n  [k & options]\n  `(~(u/gdx-field :math :Intersector (u/key->camel k)) ~@options))", :docstring "<p>Calls a single static method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Intersector.html'>Intersector</a>.</p><pre>\n&#40;intersector! :is-point-in-triangle 0 1 0 0 1 2 3 0&#41;\n</pre>"} {:raw* nil, :arglists [(math! k & options)], :java [["math!" {:text "Utility and fast math functions.\n <p>\n Thanks to Riven on JavaGaming.org for the basis of sin/cos/atan2/floor/ceil.", :items [{:args [["float" "y"] ["float" "x"]], :type "float", :text "Returns atan2 in radians from a lookup table.", :name ":atan2"} {:args [["float" "x"]], :type "int", :text "Returns the smallest integer greater than or equal to the specified float. This method will only properly ceil floats from\n -(2^14) to (Float.MAX_VALUE - 2^14).", :name ":ceil"} {:args [["float" "x"]], :type "int", :text "Returns the smallest integer greater than or equal to the specified float. This method will only properly ceil floats that\n are positive.", :name ":ceil-positive"} {:args [["int" "value"] ["int" "min"] ["int" "max"]], :type "int", :name ":clamp"} {:args [["short" "value"] ["short" "min"] ["short" "max"]], :type "short", :name ":clamp"} {:args [["float" "value"] ["float" "min"] ["float" "max"]], :type "float", :name ":clamp"} {:args [["float" "radians"]], :type "float", :text "Returns the cosine in radians from a lookup table.", :name ":cos"} {:args [["float" "degrees"]], :type "float", :text "Returns the cosine in radians from a lookup table.", :name ":cos-deg"} {:args [["float" "x"]], :type "int", :text "Returns the largest integer less than or equal to the specified float. This method will only properly floor floats from\n -(2^14) to (Float.MAX_VALUE - 2^14).", :name ":floor"} {:args [["float" "x"]], :type "int", :text "Returns the largest integer less than or equal to the specified float. This method will only properly floor floats that are\n positive. Note this method simply casts the float to int.", :name ":floor-positive"} {:args [["float" "a"] ["float" "b"]], :type "boolean", :text "Returns true if a is nearly equal to b. The function uses the default floating error tolerance.", :name ":is-equal"} {:args [["float" "a"] ["float" "b"] ["float" "tolerance"]], :type "boolean", :text "Returns true if a is nearly equal to b.", :name ":is-equal"} {:args [["int" "value"]], :type "boolean", :name ":is-power-of-two"} {:args [["float" "value"]], :type "boolean", :text "Returns true if the value is zero (using the default tolerance as upper bound)", :name ":is-zero"} {:args [["float" "value"] ["float" "tolerance"]], :type "boolean", :text "Returns true if the value is zero.", :name ":is-zero"} {:args [["float" "from-value"] ["float" "to-value"] ["float" "progress"]], :type "float", :text "Linearly interpolates between fromValue to toValue on progress position.", :name ":lerp"} {:args [["int" "value"]], :type "int", :text "Returns the next power of two. Returns the specified value if the value is already a power of two.", :name ":next-power-of-two"} {:args [["int" "range"]], :type "int", :text "Returns a random number between 0 (inclusive) and the specified value (inclusive).", :name ":random"} {:args [["int" "start"] ["int" "end"]], :type "int", :text "Returns a random number between start (inclusive) and end (inclusive).", :name ":random"} {:args [], :type "float", :text "Returns random number between 0.0 (inclusive) and 1.0 (exclusive).", :name ":random"} {:args [["float" "range"]], :type "float", :text "Returns a random number between 0 (inclusive) and the specified value (exclusive).", :name ":random"} {:args [["float" "start"] ["float" "end"]], :type "float", :text "Returns a random number between start (inclusive) and end (exclusive).", :name ":random"} {:args [], :type "boolean", :text "Returns a random boolean value.", :name ":random-boolean"} {:args [["float" "chance"]], :type "boolean", :text "Returns true if a random value between 0 and 1 is less than the specified value.", :name ":random-boolean"} {:args [["float" "x"]], :type "int", :text "Returns the closest integer to the specified float. This method will only properly round floats from -(2^14) to\n (Float.MAX_VALUE - 2^14).", :name ":round"} {:args [["float" "x"]], :type "int", :text "Returns the closest integer to the specified float. This method will only properly round floats that are positive.", :name ":round-positive"} {:args [["float" "radians"]], :type "float", :text "Returns the sine in radians from a lookup table.", :name ":sin"} {:args [["float" "degrees"]], :type "float", :text "Returns the sine in radians from a lookup table.", :name ":sin-deg"}]}]], :name "math!", :type :code, :raw "(defmacro math!\n  [k & options]\n  `(~(u/gdx-field :math :MathUtils (u/key->camel k)) ~@options))", :docstring "<p>Calls a single static method on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/MathUtils.html'>MathUtils</a>.</p><pre>\n&#40;math! :ceil 0.1&#41;\n</pre>"} {:raw* nil, :arglists [(plane-side k)], :java [["plane-side" {:text "Enum specifying on which side a point lies respective to the plane and it's normal. {@link PlaneSide#Front} is the side to\n which the normal points.", :items [{:name ":back"} {:name ":front"} {:name ":on-plane"}]}]], :name "plane-side", :type :code, :raw "(defmacro plane-side\n  [k]\n  `~(u/gdx-field :math \"Plane$PlaneSide\" (u/key->pascal k)))", :docstring "<p>Returns a static field in <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Plane.PlaneSide.html'>Plane.PlaneSide</a>.</p><pre>\n&#40;plane-side :back&#41;\n</pre>"} {:raw* "(defn bezier*\n  ([]\n    (Bezier.))\n  ([points]\n    (Bezier. (into-array points) 0 (count points))))", :arglists [(bezier points & options)], :java [["bezier" {:text "Implementation of the Bezier curve.", :items [{:args [["int" "samples"]], :type "float", :name ":approx-length"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":locate"} {:args [["com.badlogic.gdx.math.Vector[]" "points"]], :type "Bezier", :name ":set"} {:args [["com.badlogic.gdx.math.Vector[]" "points"] ["int" "offset"] ["int" "length"]], :type "Bezier", :name ":set"} {:args [["com.badlogic.gdx.utils.Array" "points"] ["int" "offset"] ["int" "length"]], :type "Bezier", :name ":set"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":value-at"}]}]], :name "bezier", :type :code, :raw "(defmacro bezier\n  [points & options]\n  `(u/calls! ^Bezier (bezier* ~points) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Bezier.html'>Bezier</a>.</p>"} {:raw* nil, :arglists [(bezier! object k & options)], :java [["bezier!" {:text "Implementation of the Bezier curve.", :items [{:args [["int" "samples"]], :type "float", :name ":approx-length"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":locate"} {:args [["com.badlogic.gdx.math.Vector[]" "points"]], :type "Bezier", :name ":set"} {:args [["com.badlogic.gdx.math.Vector[]" "points"] ["int" "offset"] ["int" "length"]], :type "Bezier", :name ":set"} {:args [["com.badlogic.gdx.utils.Array" "points"] ["int" "offset"] ["int" "length"]], :type "Bezier", :name ":set"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":value-at"}]}]], :name "bezier!", :type :code, :raw "(defmacro bezier!\n  [object k & options]\n  `(u/call! ^Bezier ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>bezier</code>.</p>"} {:raw* "(defn bresenham-2*\n  []\n  (Bresenham2.))", :arglists [(bresenham-2 & options)], :java [["bresenham-2" {:text "Returns a list of points at integer coordinates for a line on a 2D grid, using the Bresenham algorithm.\n <p>\n \n Instances of this class own the returned array of points and the points themselves to avoid garbage collection as much as\n possible. Calling any of the methods will result in the reuse of the previously returned array and vectors, expect", :items [{:args [["GridPoint2" "start"] ["GridPoint2" "end"]], :type "Array", :text "Returns a list of {@link GridPoint2} instances along the given line, at integer coordinates.", :name ":line"} {:args [["int" "start-x"] ["int" "start-y"] ["int" "end-x"] ["int" "end-y"]], :type "Array", :text "Returns a list of {@link GridPoint2} instances along the given line, at integer coordinates.", :name ":line"} {:args [["int" "start-x"] ["int" "start-y"] ["int" "end-x"] ["int" "end-y"] ["com.badlogic.gdx.utils.Pool" "pool"] ["com.badlogic.gdx.utils.Array" "output"]], :type "Array", :text "Returns a list of {@link GridPoint2} instances along the given line, at integer coordinates.", :name ":line"}]}]], :name "bresenham-2", :type :code, :raw "(defmacro bresenham-2\n  [& options]\n  `(u/calls! ^Bresenham2 (bresenham-2*) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Bresenham2.html'>Bresenham2</a>.</p>"} {:raw* nil, :arglists [(bresenham-2! object k & options)], :java [["bresenham-2!" {:text "Returns a list of points at integer coordinates for a line on a 2D grid, using the Bresenham algorithm.\n <p>\n \n Instances of this class own the returned array of points and the points themselves to avoid garbage collection as much as\n possible. Calling any of the methods will result in the reuse of the previously returned array and vectors, expect", :items [{:args [["GridPoint2" "start"] ["GridPoint2" "end"]], :type "Array", :text "Returns a list of {@link GridPoint2} instances along the given line, at integer coordinates.", :name ":line"} {:args [["int" "start-x"] ["int" "start-y"] ["int" "end-x"] ["int" "end-y"]], :type "Array", :text "Returns a list of {@link GridPoint2} instances along the given line, at integer coordinates.", :name ":line"} {:args [["int" "start-x"] ["int" "start-y"] ["int" "end-x"] ["int" "end-y"] ["com.badlogic.gdx.utils.Pool" "pool"] ["com.badlogic.gdx.utils.Array" "output"]], :type "Array", :text "Returns a list of {@link GridPoint2} instances along the given line, at integer coordinates.", :name ":line"}]}]], :name "bresenham-2!", :type :code, :raw "(defmacro bresenham-2!\n  [object k & options]\n  `(u/call! ^Bresenham2 ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>bresenham-2</code>.</p>"} {:raw* "(defn b-spline*\n  ([]\n    (BSpline.))\n  ([points degree cont?]\n    (BSpline. (into-array points) degree cont?)))", :arglists [(b-spline points degree cont? & options)], :java [["b-spline" {:text "", :items [{:args [["int" "samples"]], :type "float", :name ":approx-length"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "start"] ["int" "count"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "near"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["int" "span"] ["float" "u"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":locate"} {:args [["com.badlogic.gdx.math.Vector" "in"]], :type "int", :name ":nearest"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "start"] ["int" "count"]], :type "int", :name ":nearest"} {:args [["com.badlogic.gdx.math.Vector[]" "control-points"] ["int" "degree"] ["boolean" "continuous"]], :type "BSpline", :name ":set"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":value-at"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["int" "span"] ["float" "u"]], :type "Vector", :name ":value-at"}]}]], :name "b-spline", :type :code, :raw "(defmacro b-spline\n  [points degree cont? & options]\n  `(u/calls! ^BSpline (b-spline* ~points ~degree ~cont?) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/BSpline.html'>BSpline</a>.</p>"} {:raw* nil, :arglists [(b-spline! object k & options)], :java [["b-spline!" {:text "", :items [{:args [["int" "samples"]], :type "float", :name ":approx-length"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "start"] ["int" "count"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "near"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["int" "span"] ["float" "u"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":locate"} {:args [["com.badlogic.gdx.math.Vector" "in"]], :type "int", :name ":nearest"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "start"] ["int" "count"]], :type "int", :name ":nearest"} {:args [["com.badlogic.gdx.math.Vector[]" "control-points"] ["int" "degree"] ["boolean" "continuous"]], :type "BSpline", :name ":set"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":value-at"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["int" "span"] ["float" "u"]], :type "Vector", :name ":value-at"}]}]], :name "b-spline!", :type :code, :raw "(defmacro b-spline!\n  [object k & options]\n  `(u/call! ^BSpline ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>b-spline</code>.</p>"} {:raw* "(defn catmull-rom-spline*\n  ([]\n    (CatmullRomSpline.))\n  ([points cont?]\n    (CatmullRomSpline. (into-array points) cont?)))", :arglists [(catmull-rom-spline points cont? & options)], :java [["catmull-rom-spline" {:text "", :items [{:args [["int" "samples"]], :type "float", :name ":approx-length"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "start"] ["int" "count"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "near"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["int" "span"] ["float" "u"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":locate"} {:args [["com.badlogic.gdx.math.Vector" "in"]], :type "int", :name ":nearest"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "start"] ["int" "count"]], :type "int", :name ":nearest"} {:args [["com.badlogic.gdx.math.Vector[]" "control-points"] ["boolean" "continuous"]], :type "CatmullRomSpline", :name ":set"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":value-at"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["int" "span"] ["float" "u"]], :type "Vector", :name ":value-at"}]}]], :name "catmull-rom-spline", :type :code, :raw "(defmacro catmull-rom-spline\n  [points cont? & options]\n  `(u/calls! ^CatmullRomSpline (catmull-rom-spline* ~points ~cont?) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/CatmullRomSpline.html'>CatmullRomSpline</a>.</p>"} {:raw* nil, :arglists [(catmull-rom-spline! object k & options)], :java [["catmull-rom-spline!" {:text "", :items [{:args [["int" "samples"]], :type "float", :name ":approx-length"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "start"] ["int" "count"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "near"]], :type "float", :name ":approximate"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["int" "span"] ["float" "u"]], :type "Vector", :name ":derivative-at"} {:args [["com.badlogic.gdx.math.Vector" "v"]], :type "float", :name ":locate"} {:args [["com.badlogic.gdx.math.Vector" "in"]], :type "int", :name ":nearest"} {:args [["com.badlogic.gdx.math.Vector" "in"] ["int" "start"] ["int" "count"]], :type "int", :name ":nearest"} {:args [["com.badlogic.gdx.math.Vector[]" "control-points"] ["boolean" "continuous"]], :type "CatmullRomSpline", :name ":set"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["float" "t"]], :type "Vector", :name ":value-at"} {:args [["com.badlogic.gdx.math.Vector" "out"] ["int" "span"] ["float" "u"]], :type "Vector", :name ":value-at"}]}]], :name "catmull-rom-spline!", :type :code, :raw "(defmacro catmull-rom-spline!\n  [object k & options]\n  `(u/call! ^CatmullRomSpline ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>catmull-rom-spline</code>.</p>"} {:raw* "(defn circle*\n  ([]\n    (Circle.))\n  ([x y radius]\n    (Circle. x y radius)))", :arglists [(circle x y radius & options)], :java [["circle" {:text "A convenient 2D circle class.", :items [{:args [["float" "x"] ["float" "y"]], :type "boolean", :text "Checks whether or not this circle contains a given point.", :name ":contains"} {:args [["Vector2" "point"]], :type "boolean", :text "Checks whether or not this circle contains a given point.", :name ":contains"} {:args [["Circle" "c"]], :type "boolean", :name ":contains"} {:args [["Circle" "c"]], :type "boolean", :name ":overlaps"} {:args [["float" "x"] ["float" "y"] ["float" "radius"]], :text "Sets a new location and radius for this circle.", :name ":set"} {:args [["Vector2" "position"] ["float" "radius"]], :text "Sets a new location and radius for this circle.", :name ":set"} {:args [["Circle" "circle"]], :text "Sets a new location and radius for this circle, based upon another circle.", :name ":set"} {:args [["Vector2" "position"]], :text "Sets the x and y-coordinates of circle center from vector", :name ":set-position"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y-coordinates of circle center", :name ":set-position"} {:args [["float" "radius"]], :text "Sets the radius of circle", :name ":set-radius"} {:args [["float" "x"]], :text "Sets the x-coordinate of circle center", :name ":set-x"} {:args [["float" "y"]], :text "Sets the y-coordinate of circle center", :name ":set-y"} {:args [], :type "String", :name ":to-string"}]}]], :name "circle", :type :code, :raw "(defmacro circle\n  [x y radius & options]\n  `(u/calls! ^Circle (circle* ~x ~y ~radius) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Circle.html'>Circle</a>.</p>"} {:raw* nil, :arglists [(circle! object k & options)], :java [["circle!" {:text "A convenient 2D circle class.", :items [{:args [["float" "x"] ["float" "y"]], :type "boolean", :text "Checks whether or not this circle contains a given point.", :name ":contains"} {:args [["Vector2" "point"]], :type "boolean", :text "Checks whether or not this circle contains a given point.", :name ":contains"} {:args [["Circle" "c"]], :type "boolean", :name ":contains"} {:args [["Circle" "c"]], :type "boolean", :name ":overlaps"} {:args [["float" "x"] ["float" "y"] ["float" "radius"]], :text "Sets a new location and radius for this circle.", :name ":set"} {:args [["Vector2" "position"] ["float" "radius"]], :text "Sets a new location and radius for this circle.", :name ":set"} {:args [["Circle" "circle"]], :text "Sets a new location and radius for this circle, based upon another circle.", :name ":set"} {:args [["Vector2" "position"]], :text "Sets the x and y-coordinates of circle center from vector", :name ":set-position"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y-coordinates of circle center", :name ":set-position"} {:args [["float" "radius"]], :text "Sets the radius of circle", :name ":set-radius"} {:args [["float" "x"]], :text "Sets the x-coordinate of circle center", :name ":set-x"} {:args [["float" "y"]], :text "Sets the y-coordinate of circle center", :name ":set-y"} {:args [], :type "String", :name ":to-string"}]}]], :name "circle!", :type :code, :raw "(defmacro circle!\n  [object k & options]\n  `(u/call! ^Circle ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>circle</code>.</p>"} {:raw* "(defn convex-hull*\n  []\n  (ConvexHull.))", :arglists [(convex-hull & options)], :java [["convex-hull" {:text "Computes the convex hull of a set of points using the monotone chain convex hull algorithm (aka Andrew's algorithm).", :items [{:args [["FloatArray" "points"] ["boolean" "sorted"] ["boolean" "y-down"]], :type "IntArray", :name ":compute-indices"} {:args [["float[]" "polygon"] ["boolean" "sorted"] ["boolean" "y-down"]], :type "IntArray", :name ":compute-indices"} {:args [["float[]" "points"] ["int" "offset"] ["int" "count"] ["boolean" "sorted"] ["boolean" "y-down"]], :type "IntArray", :text "Computes a hull the same as {@link #computePolygon(float[], int, int, boolean)} but returns indices of the specified points.", :name ":compute-indices"} {:args [["FloatArray" "points"] ["boolean" "sorted"]], :type "FloatArray", :name ":compute-polygon"} {:args [["float[]" "polygon"] ["boolean" "sorted"]], :type "FloatArray", :name ":compute-polygon"} {:args [["float[]" "points"] ["int" "offset"] ["int" "count"] ["boolean" "sorted"]], :type "FloatArray", :text "Returns the convex hull polygon for the given point cloud.", :name ":compute-polygon"}]}]], :name "convex-hull", :type :code, :raw "(defmacro convex-hull\n  [& options]\n  `(u/calls! ^ConvexHull (convex-hull*) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/ConvexHull.html'>ConvexHull</a>.</p>"} {:raw* nil, :arglists [(convex-hull! object k & options)], :java [["convex-hull!" {:text "Computes the convex hull of a set of points using the monotone chain convex hull algorithm (aka Andrew's algorithm).", :items [{:args [["FloatArray" "points"] ["boolean" "sorted"] ["boolean" "y-down"]], :type "IntArray", :name ":compute-indices"} {:args [["float[]" "polygon"] ["boolean" "sorted"] ["boolean" "y-down"]], :type "IntArray", :name ":compute-indices"} {:args [["float[]" "points"] ["int" "offset"] ["int" "count"] ["boolean" "sorted"] ["boolean" "y-down"]], :type "IntArray", :text "Computes a hull the same as {@link #computePolygon(float[], int, int, boolean)} but returns indices of the specified points.", :name ":compute-indices"} {:args [["FloatArray" "points"] ["boolean" "sorted"]], :type "FloatArray", :name ":compute-polygon"} {:args [["float[]" "polygon"] ["boolean" "sorted"]], :type "FloatArray", :name ":compute-polygon"} {:args [["float[]" "points"] ["int" "offset"] ["int" "count"] ["boolean" "sorted"]], :type "FloatArray", :text "Returns the convex hull polygon for the given point cloud.", :name ":compute-polygon"}]}]], :name "convex-hull!", :type :code, :raw "(defmacro convex-hull!\n  [object k & options]\n  `(u/call! ^ConvexHull ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>convex-hull</code>.</p>"} {:raw* "(defn delaunay-triangulator*\n  []\n  (DelaunayTriangulator.))", :arglists [(delaunay-triangulator & options)], :java [["delaunay-triangulator" {:text "Delaunay triangulation. Adapted from Paul Bourke's triangulate: http://paulbourke.net/papers/triangulate/", :items [{:args [["FloatArray" "points"] ["boolean" "sorted"]], :type "ShortArray", :name ":compute-triangles"} {:args [["float[]" "polygon"] ["boolean" "sorted"]], :type "ShortArray", :name ":compute-triangles"} {:args [["float[]" "points"] ["int" "offset"] ["int" "count"] ["boolean" "sorted"]], :type "ShortArray", :text "Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.", :name ":compute-triangles"} {:args [["ShortArray" "triangles"] ["float[]" "points"] ["float[]" "hull"] ["int" "offset"] ["int" "count"]], :text "Removes all triangles with a centroid outside the specified hull, which may be concave. Note some triangulations may have\n triangles whose centroid is inside the hull but a portion is outside.", :name ":trim"}]}]], :name "delaunay-triangulator", :type :code, :raw "(defmacro delaunay-triangulator\n  [& options]\n  `(u/calls! ^DelaunayTriangulator (delaunay-triangulator*) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/DelaunayTriangulator.html'>DelaunayTriangulator</a>.</p>"} {:raw* nil, :arglists [(delaunay-triangulator! object k & options)], :java [["delaunay-triangulator!" {:text "Delaunay triangulation. Adapted from Paul Bourke's triangulate: http://paulbourke.net/papers/triangulate/", :items [{:args [["FloatArray" "points"] ["boolean" "sorted"]], :type "ShortArray", :name ":compute-triangles"} {:args [["float[]" "polygon"] ["boolean" "sorted"]], :type "ShortArray", :name ":compute-triangles"} {:args [["float[]" "points"] ["int" "offset"] ["int" "count"] ["boolean" "sorted"]], :type "ShortArray", :text "Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.", :name ":compute-triangles"} {:args [["ShortArray" "triangles"] ["float[]" "points"] ["float[]" "hull"] ["int" "offset"] ["int" "count"]], :text "Removes all triangles with a centroid outside the specified hull, which may be concave. Note some triangulations may have\n triangles whose centroid is inside the hull but a portion is outside.", :name ":trim"}]}]], :name "delaunay-triangulator!", :type :code, :raw "(defmacro delaunay-triangulator!\n  [object k & options]\n  `(u/call! ^DelaunayTriangulator ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>delaunay-triangulator</code>.</p>"} {:raw* "(defn ear-clipping-triangulator*\n  []\n  (EarClippingTriangulator.))", :arglists [(ear-clipping-triangulator & options)], :java [["ear-clipping-triangulator" {:text "A simple implementation of the ear cutting algorithm to triangulate simple polygons without holes. For more information:\n <ul>\n <li><a href=\"http://cgm.cs.mcgill.ca/~godfried/teaching/cg-projects/97/Ian/algorithm2.html\">http://cgm.cs.mcgill.ca/~godfried/\n teaching/cg-projects/97/Ian/algorithm2.html</a></li>\n <li><a\n href=\"http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\">http://www.geometrictools.com/Documentation\n /TriangulationByEarClipping.pdf</a></li>\n </ul>\n If the input polygon is not simple (self-intersects), there will be output but it is of unspecified quality (garbage in,\n garbage out).", :items [{:args [["FloatArray" "vertices"]], :type "ShortArray", :name ":compute-triangles"} {:args [["float[]" "vertices"]], :type "ShortArray", :name ":compute-triangles"} {:args [["float[]" "vertices"] ["int" "offset"] ["int" "count"]], :type "ShortArray", :text "Triangulates the given (convex or concave) simple polygon to a list of triangle vertices.", :name ":compute-triangles"}]}]], :name "ear-clipping-triangulator", :type :code, :raw "(defmacro ear-clipping-triangulator\n  [& options]\n  `(u/calls! ^EarClippingTriangulator (ear-clipping-triangulator*) ~@options))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/EarClippingTriangulator.html'>EarClippingTriangulator</a>.</p>"} {:raw* nil, :arglists [(ear-clipping-triangulator! object k & options)], :java [["ear-clipping-triangulator!" {:text "A simple implementation of the ear cutting algorithm to triangulate simple polygons without holes. For more information:\n <ul>\n <li><a href=\"http://cgm.cs.mcgill.ca/~godfried/teaching/cg-projects/97/Ian/algorithm2.html\">http://cgm.cs.mcgill.ca/~godfried/\n teaching/cg-projects/97/Ian/algorithm2.html</a></li>\n <li><a\n href=\"http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\">http://www.geometrictools.com/Documentation\n /TriangulationByEarClipping.pdf</a></li>\n </ul>\n If the input polygon is not simple (self-intersects), there will be output but it is of unspecified quality (garbage in,\n garbage out).", :items [{:args [["FloatArray" "vertices"]], :type "ShortArray", :name ":compute-triangles"} {:args [["float[]" "vertices"]], :type "ShortArray", :name ":compute-triangles"} {:args [["float[]" "vertices"] ["int" "offset"] ["int" "count"]], :type "ShortArray", :text "Triangulates the given (convex or concave) simple polygon to a list of triangle vertices.", :name ":compute-triangles"}]}]], :name "ear-clipping-triangulator!", :type :code, :raw "(defmacro ear-clipping-triangulator!\n  [object k & options]\n  `(u/call! ^EarClippingTriangulator ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>ear-clipping-triangulator</code>.</p>"} {:raw* "(defn ellipse*\n  ([]\n    (Ellipse.))\n  ([x y width height]\n    (Ellipse. x y width height)))", :arglists [(ellipse x y width height & options)], :java [["ellipse" {:text "A convenient 2D ellipse class, based on the circle class", :items [{:args [["float" "x"] ["float" "y"]], :type "boolean", :text "Checks whether or not this ellipse contains the given point.", :name ":contains"} {:args [["Vector2" "point"]], :type "boolean", :text "Checks whether or not this ellipse contains the given point.", :name ":contains"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Sets a new position and size for this ellipse.", :name ":set"} {:args [["Ellipse" "ellipse"]], :text "Sets a new position and size for this ellipse based upon another ellipse.", :name ":set"} {:args [["Vector2" "position"]], :type "Ellipse", :text "Sets the x and y-coordinates of ellipse center from a {@link Vector2}.", :name ":set-position"} {:args [["float" "x"] ["float" "y"]], :type "Ellipse", :text "Sets the x and y-coordinates of ellipse center", :name ":set-position"} {:args [["float" "width"] ["float" "height"]], :type "Ellipse", :text "Sets the width and height of this ellipse", :name ":set-size"}]}]], :name "ellipse", :type :code, :raw "(defmacro ellipse\n  [x y width height & options]\n  `(u/calls! ^Ellipse (ellipse* ~x ~y ~width ~height) ~@options))", :docstring "<p>Returns an <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Ellipse.html'>Ellipse</a>.</p>"} {:raw* nil, :arglists [(ellipse! object k & options)], :java [["ellipse!" {:text "A convenient 2D ellipse class, based on the circle class", :items [{:args [["float" "x"] ["float" "y"]], :type "boolean", :text "Checks whether or not this ellipse contains the given point.", :name ":contains"} {:args [["Vector2" "point"]], :type "boolean", :text "Checks whether or not this ellipse contains the given point.", :name ":contains"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Sets a new position and size for this ellipse.", :name ":set"} {:args [["Ellipse" "ellipse"]], :text "Sets a new position and size for this ellipse based upon another ellipse.", :name ":set"} {:args [["Vector2" "position"]], :type "Ellipse", :text "Sets the x and y-coordinates of ellipse center from a {@link Vector2}.", :name ":set-position"} {:args [["float" "x"] ["float" "y"]], :type "Ellipse", :text "Sets the x and y-coordinates of ellipse center", :name ":set-position"} {:args [["float" "width"] ["float" "height"]], :type "Ellipse", :text "Sets the width and height of this ellipse", :name ":set-size"}]}]], :name "ellipse!", :type :code, :raw "(defmacro ellipse!\n  [object k & options]\n  `(u/call! ^Ellipse ~object ~k ~@options))", :docstring "<p>Calls a single method on an <code>ellipse</code>.</p>"} {:raw* "(defn float-counter*\n  [window-size]\n  (FloatCounter. window-size))", :arglists [(float-counter window-size & options)], :java [["float-counter" {:text "Track properties of a stream of float values. The properties (total value, minimum, etc) are updated as values are\n {@link #put(float)} into the stream.", :items [{:args [["float" "value"]], :text "Add a value and update all fields.", :name ":put"} {:args [], :text "Reset all values to their default value.", :name ":reset"}]}]], :name "float-counter", :type :code, :raw "(defmacro float-counter\n  [window-size & options]\n  `(u/calls! ^FloatCounter (float-counter* ~window-size) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/FloatCounter.html'>FloatCounter</a>.</p>"} {:raw* nil, :arglists [(float-counter! object k & options)], :java [["float-counter!" {:text "Track properties of a stream of float values. The properties (total value, minimum, etc) are updated as values are\n {@link #put(float)} into the stream.", :items [{:args [["float" "value"]], :text "Add a value and update all fields.", :name ":put"} {:args [], :text "Reset all values to their default value.", :name ":reset"}]}]], :name "float-counter!", :type :code, :raw "(defmacro float-counter!\n  [object k & options]\n  `(u/call! ^FloatCounter ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>float-counter</code>.</p>"} {:raw* "(defn frustum*\n  []\n  (Frustum.))", :arglists [(frustum & options)], :java [["frustum" {:text "A truncated rectangular pyramid. Used to define the viewable region and its projection onto the screen.", :items [{:args [["BoundingBox" "bounds"]], :type "boolean", :text "Returns whether the given {@link BoundingBox} is in the frustum.", :name ":bounds-in-frustum"} {:args [["Vector3" "center"] ["Vector3" "dimensions"]], :type "boolean", :text "Returns whether the given bounding box is in the frustum.", :name ":bounds-in-frustum"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "half-width"] ["float" "half-height"] ["float" "half-depth"]], :type "boolean", :text "Returns whether the given bounding box is in the frustum.", :name ":bounds-in-frustum"} {:args [["Vector3" "point"]], :type "boolean", :text "Returns whether the point is in the frustum.", :name ":point-in-frustum"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "boolean", :text "Returns whether the point is in the frustum.", :name ":point-in-frustum"} {:args [["Vector3" "center"] ["float" "radius"]], :type "boolean", :text "Returns whether the given sphere is in the frustum.", :name ":sphere-in-frustum"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radius"]], :type "boolean", :text "Returns whether the given sphere is in the frustum.", :name ":sphere-in-frustum"} {:args [["Vector3" "center"] ["float" "radius"]], :type "boolean", :text "Returns whether the given sphere is in the frustum not checking whether it is behind the near and far clipping plane.", :name ":sphere-in-frustum-without-near-far"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radius"]], :type "boolean", :text "Returns whether the given sphere is in the frustum not checking whether it is behind the near and far clipping plane.", :name ":sphere-in-frustum-without-near-far"} {:args [["Matrix4" "inverse-projection-view"]], :text "Updates the clipping plane's based on the given inverse combined projection and view matrix, e.g. from an\n {@link OrthographicCamera} or {@link PerspectiveCamera}.", :name ":update"}]}]], :name "frustum", :type :code, :raw "(defmacro frustum\n  [& options]\n  `(u/calls! ^Frustum (frustum*) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Frustum.html'>Frustum</a>.</p>"} {:raw* nil, :arglists [(frustum! object k & options)], :java [["frustum!" {:text "A truncated rectangular pyramid. Used to define the viewable region and its projection onto the screen.", :items [{:args [["BoundingBox" "bounds"]], :type "boolean", :text "Returns whether the given {@link BoundingBox} is in the frustum.", :name ":bounds-in-frustum"} {:args [["Vector3" "center"] ["Vector3" "dimensions"]], :type "boolean", :text "Returns whether the given bounding box is in the frustum.", :name ":bounds-in-frustum"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "half-width"] ["float" "half-height"] ["float" "half-depth"]], :type "boolean", :text "Returns whether the given bounding box is in the frustum.", :name ":bounds-in-frustum"} {:args [["Vector3" "point"]], :type "boolean", :text "Returns whether the point is in the frustum.", :name ":point-in-frustum"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "boolean", :text "Returns whether the point is in the frustum.", :name ":point-in-frustum"} {:args [["Vector3" "center"] ["float" "radius"]], :type "boolean", :text "Returns whether the given sphere is in the frustum.", :name ":sphere-in-frustum"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radius"]], :type "boolean", :text "Returns whether the given sphere is in the frustum.", :name ":sphere-in-frustum"} {:args [["Vector3" "center"] ["float" "radius"]], :type "boolean", :text "Returns whether the given sphere is in the frustum not checking whether it is behind the near and far clipping plane.", :name ":sphere-in-frustum-without-near-far"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radius"]], :type "boolean", :text "Returns whether the given sphere is in the frustum not checking whether it is behind the near and far clipping plane.", :name ":sphere-in-frustum-without-near-far"} {:args [["Matrix4" "inverse-projection-view"]], :text "Updates the clipping plane's based on the given inverse combined projection and view matrix, e.g. from an\n {@link OrthographicCamera} or {@link PerspectiveCamera}.", :name ":update"}]}]], :name "frustum!", :type :code, :raw "(defmacro frustum!\n  [object k & options]\n  `(u/call! ^Frustum ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>frustum</code>.</p>"} {:raw* "(defn grid-point-2*\n  [x y]\n  (GridPoint2. x y))", :arglists [(grid-point-2 x y & options)], :java [["grid-point-2" {:text "A point in a 2D grid, with integer x and y coordinates", :items [{:args [["GridPoint2" "point"]], :type "GridPoint2", :text "Sets the coordinates of this 2D grid point to that of another.", :name ":set"} {:args [["int" "x"] ["int" "y"]], :type "GridPoint2", :text "Sets the coordinates of this 2D grid point.", :name ":set"}]}]], :name "grid-point-2", :type :code, :raw "(defmacro grid-point-2\n  [x y & options]\n  `(u/calls! ^GridPoint2 (grid-point-2* ~x ~y) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/GridPoint2.html'>GridPoint2</a>.</p>"} {:raw* nil, :arglists [(grid-point-2! object k & options)], :java [["grid-point-2!" {:text "A point in a 2D grid, with integer x and y coordinates", :items [{:args [["GridPoint2" "point"]], :type "GridPoint2", :text "Sets the coordinates of this 2D grid point to that of another.", :name ":set"} {:args [["int" "x"] ["int" "y"]], :type "GridPoint2", :text "Sets the coordinates of this 2D grid point.", :name ":set"}]}]], :name "grid-point-2!", :type :code, :raw "(defmacro grid-point-2!\n  [object k & options]\n  `(u/call! ^GridPoint2 ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>grid-point-2</code>.</p>"} {:raw* "(defn grid-point-3*\n  [x y z]\n  (GridPoint3. x y z))", :arglists [(grid-point-3 x y z & options)], :java [["grid-point-3" {:text "A point in a 3D grid, with integer x and y coordinates", :items [{:args [["GridPoint3" "point"]], :type "GridPoint3", :text "Sets the coordinates of this 3D grid point to that of another.", :name ":set"} {:args [["int" "x"] ["int" "y"] ["int" "z"]], :type "GridPoint3", :text "Sets the coordinates of this GridPoint3D.", :name ":set"}]}]], :name "grid-point-3", :type :code, :raw "(defmacro grid-point-3\n  [x y z & options]\n  `(u/calls! ^GridPoint3 (grid-point-3* ~x ~y ~z) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/GridPoint3.html'>GridPoint3</a>.</p>"} {:raw* nil, :arglists [(grid-point-3! object k & options)], :java [["grid-point-3!" {:text "A point in a 3D grid, with integer x and y coordinates", :items [{:args [["GridPoint3" "point"]], :type "GridPoint3", :text "Sets the coordinates of this 3D grid point to that of another.", :name ":set"} {:args [["int" "x"] ["int" "y"] ["int" "z"]], :type "GridPoint3", :text "Sets the coordinates of this GridPoint3D.", :name ":set"}]}]], :name "grid-point-3!", :type :code, :raw "(defmacro grid-point-3!\n  [object k & options]\n  `(u/call! ^GridPoint3 ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>grid-point-3</code>.</p>"} {:raw* "(defn matrix-3*\n  ([]\n    (Matrix3.))\n  ([values]\n    (Matrix3. values)))", :arglists [(matrix-3 values & options)], :java [["matrix-3" {:text "A 3x3 <a href=\"http://en.wikipedia.org/wiki/Row-major_order#Column-major_order\">column major</a> matrix; useful for 2D\n transforms.", :items [{:args [], :type "float", :name ":det"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-rotation-rad"} {:args [["Vector2" "scale"]], :type "Vector2", :name ":get-scale"} {:args [["Vector2" "position"]], :type "Vector2", :name ":get-translation"} {:args [], :type "float", :text "Get the values in this matrix.", :name ":get-values"} {:args [], :type "Matrix3", :text "Sets this matrix to the identity matrix", :name ":idt"} {:args [], :type "Matrix3", :text "Inverts this matrix given that the determinant is != 0.", :name ":inv"} {:args [["Matrix3" "m"]], :type "Matrix3", :text "Postmultiplies this matrix with the provided matrix and stores the result in this matrix. For example:\n \n <pre>\n A.mul(B) results in A := AB\n </pre>", :name ":mul"} {:args [["Matrix3" "m"]], :type "Matrix3", :text "Premultiplies this matrix with the provided matrix and stores the result in this matrix. For example:\n \n <pre>\n A.mulLeft(B) results in A := BA\n </pre>", :name ":mul-left"} {:args [["float" "degrees"]], :type "Matrix3", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate"} {:args [["float" "radians"]], :type "Matrix3", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate-rad"} {:args [["float" "scale-x"] ["float" "scale-y"]], :type "Matrix3", :text "Postmultiplies this matrix with a scale matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":scale"} {:args [["Vector2" "scale"]], :type "Matrix3", :text "Postmultiplies this matrix with a scale matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":scale"} {:args [["float" "scale"]], :type "Matrix3", :text "Scale the matrix in the both the x and y components by the scalar value.", :name ":scl"} {:args [["Vector2" "scale"]], :type "Matrix3", :text "Scale this matrix using the x and y components of the vector but leave the rest of the matrix alone.", :name ":scl"} {:args [["Vector3" "scale"]], :type "Matrix3", :text "Scale this matrix using the x and y components of the vector but leave the rest of the matrix alone.", :name ":scl"} {:args [["Matrix3" "mat"]], :type "Matrix3", :text "Copies the values from the provided matrix to this matrix.", :name ":set"} {:args [["Matrix4" "mat"]], :type "Matrix3", :text "Sets this 3x3 matrix to the top left 3x3 corner of the provided 4x4 matrix.", :name ":set"} {:args [["float[]" "values"]], :type "Matrix3", :text "Sets the matrix to the given matrix as a float array. The float array must have at least 9 elements; the first 9 will be\n copied.", :name ":set"} {:args [["float" "degrees"]], :type "Matrix3", :text "Sets this matrix to a rotation matrix that will rotate any vector in counter-clockwise direction around the z-axis.", :name ":set-to-rotation"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Matrix3", :name ":set-to-rotation"} {:args [["Vector3" "axis"] ["float" "cos"] ["float" "sin"]], :type "Matrix3", :name ":set-to-rotation"} {:args [["float" "radians"]], :type "Matrix3", :text "Sets this matrix to a rotation matrix that will rotate any vector in counter-clockwise direction around the z-axis.", :name ":set-to-rotation-rad"} {:args [["float" "scale-x"] ["float" "scale-y"]], :type "Matrix3", :text "Sets this matrix to a scaling matrix.", :name ":set-to-scaling"} {:args [["float" "x"] ["float" "y"]], :type "Matrix3", :text "Sets this matrix to a translation matrix.", :name ":set-to-translation"} {:args [["Vector2" "translation"]], :type "Matrix3", :text "Sets this matrix to a translation matrix.", :name ":set-to-translation"} {:args [], :type "String", :name ":to-string"} {:args [["float" "x"] ["float" "y"]], :type "Matrix3", :text "Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":translate"} {:args [["Vector2" "translation"]], :type "Matrix3", :text "Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":translate"} {:args [], :type "Matrix3", :text "Transposes the current matrix.", :name ":transpose"} {:args [["Vector2" "vector"]], :type "Matrix3", :text "Adds a translational component to the matrix in the 3rd column. The other columns are untouched.", :name ":trn"} {:args [["float" "x"] ["float" "y"]], :type "Matrix3", :text "Adds a translational component to the matrix in the 3rd column. The other columns are untouched.", :name ":trn"} {:args [["Vector3" "vector"]], :type "Matrix3", :text "Adds a translational component to the matrix in the 3rd column. The other columns are untouched.", :name ":trn"}]}]], :name "matrix-3", :type :code, :raw "(defmacro matrix-3\n  [values & options]\n  `(u/calls! ^Matrix3 (matrix-3* ~values) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Matrix3.html'>Matrix3</a>.</p>"} {:raw* nil, :arglists [(matrix-3! object k & options)], :java [["matrix-3!" {:text "A 3x3 <a href=\"http://en.wikipedia.org/wiki/Row-major_order#Column-major_order\">column major</a> matrix; useful for 2D\n transforms.", :items [{:args [], :type "float", :name ":det"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-rotation-rad"} {:args [["Vector2" "scale"]], :type "Vector2", :name ":get-scale"} {:args [["Vector2" "position"]], :type "Vector2", :name ":get-translation"} {:args [], :type "float", :text "Get the values in this matrix.", :name ":get-values"} {:args [], :type "Matrix3", :text "Sets this matrix to the identity matrix", :name ":idt"} {:args [], :type "Matrix3", :text "Inverts this matrix given that the determinant is != 0.", :name ":inv"} {:args [["Matrix3" "m"]], :type "Matrix3", :text "Postmultiplies this matrix with the provided matrix and stores the result in this matrix. For example:\n \n <pre>\n A.mul(B) results in A := AB\n </pre>", :name ":mul"} {:args [["Matrix3" "m"]], :type "Matrix3", :text "Premultiplies this matrix with the provided matrix and stores the result in this matrix. For example:\n \n <pre>\n A.mulLeft(B) results in A := BA\n </pre>", :name ":mul-left"} {:args [["float" "degrees"]], :type "Matrix3", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate"} {:args [["float" "radians"]], :type "Matrix3", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate-rad"} {:args [["float" "scale-x"] ["float" "scale-y"]], :type "Matrix3", :text "Postmultiplies this matrix with a scale matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":scale"} {:args [["Vector2" "scale"]], :type "Matrix3", :text "Postmultiplies this matrix with a scale matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":scale"} {:args [["float" "scale"]], :type "Matrix3", :text "Scale the matrix in the both the x and y components by the scalar value.", :name ":scl"} {:args [["Vector2" "scale"]], :type "Matrix3", :text "Scale this matrix using the x and y components of the vector but leave the rest of the matrix alone.", :name ":scl"} {:args [["Vector3" "scale"]], :type "Matrix3", :text "Scale this matrix using the x and y components of the vector but leave the rest of the matrix alone.", :name ":scl"} {:args [["Matrix3" "mat"]], :type "Matrix3", :text "Copies the values from the provided matrix to this matrix.", :name ":set"} {:args [["Matrix4" "mat"]], :type "Matrix3", :text "Sets this 3x3 matrix to the top left 3x3 corner of the provided 4x4 matrix.", :name ":set"} {:args [["float[]" "values"]], :type "Matrix3", :text "Sets the matrix to the given matrix as a float array. The float array must have at least 9 elements; the first 9 will be\n copied.", :name ":set"} {:args [["float" "degrees"]], :type "Matrix3", :text "Sets this matrix to a rotation matrix that will rotate any vector in counter-clockwise direction around the z-axis.", :name ":set-to-rotation"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Matrix3", :name ":set-to-rotation"} {:args [["Vector3" "axis"] ["float" "cos"] ["float" "sin"]], :type "Matrix3", :name ":set-to-rotation"} {:args [["float" "radians"]], :type "Matrix3", :text "Sets this matrix to a rotation matrix that will rotate any vector in counter-clockwise direction around the z-axis.", :name ":set-to-rotation-rad"} {:args [["float" "scale-x"] ["float" "scale-y"]], :type "Matrix3", :text "Sets this matrix to a scaling matrix.", :name ":set-to-scaling"} {:args [["float" "x"] ["float" "y"]], :type "Matrix3", :text "Sets this matrix to a translation matrix.", :name ":set-to-translation"} {:args [["Vector2" "translation"]], :type "Matrix3", :text "Sets this matrix to a translation matrix.", :name ":set-to-translation"} {:args [], :type "String", :name ":to-string"} {:args [["float" "x"] ["float" "y"]], :type "Matrix3", :text "Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":translate"} {:args [["Vector2" "translation"]], :type "Matrix3", :text "Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":translate"} {:args [], :type "Matrix3", :text "Transposes the current matrix.", :name ":transpose"} {:args [["Vector2" "vector"]], :type "Matrix3", :text "Adds a translational component to the matrix in the 3rd column. The other columns are untouched.", :name ":trn"} {:args [["float" "x"] ["float" "y"]], :type "Matrix3", :text "Adds a translational component to the matrix in the 3rd column. The other columns are untouched.", :name ":trn"} {:args [["Vector3" "vector"]], :type "Matrix3", :text "Adds a translational component to the matrix in the 3rd column. The other columns are untouched.", :name ":trn"}]}]], :name "matrix-3!", :type :code, :raw "(defmacro matrix-3!\n  [object k & options]\n  `(u/call! ^Matrix3 ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>matrix-3</code>.</p>"} {:raw* "(defn matrix-4*\n  ([]\n    (Matrix4.))\n  ([^floats values]\n    (Matrix4. values)))", :arglists [(matrix-4 values & options)], :java [["matrix-4" {:text "Encapsulates a <a href=\"http://en.wikipedia.org/wiki/Row-major_order#Column-major_order\">column major</a> 4 by 4 matrix. Like\n the {@link Vector3} class it allows the chaining of methods by returning a reference to itself. For example:\n \n <pre>\n Matrix4 mat = new Matrix4().trn(position).mul(camera.combined);\n </pre>", :items [{:args [], :type "Matrix4", :name ":cpy"} {:args [], :type "float", :name ":det"} {:args [], :type "float", :name ":det3x3"} {:args [["float[]" "dst"]], :text "Copies the 4x3 upper-left sub-matrix into float array. The destination array is supposed to be a column major matrix.", :name ":extract4x3matrix"} {:args [["Quaternion" "rotation"] ["boolean" "normalize-axes"]], :type "Quaternion", :text "Gets the rotation of this matrix.", :name ":get-rotation"} {:args [["Quaternion" "rotation"]], :type "Quaternion", :text "Gets the rotation of this matrix.", :name ":get-rotation"} {:args [["Vector3" "scale"]], :type "Vector3", :name ":get-scale"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-xsquared"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :name ":get-scale-ysquared"} {:args [], :type "float", :name ":get-scale-z"} {:args [], :type "float", :name ":get-scale-zsquared"} {:args [["Vector3" "position"]], :type "Vector3", :name ":get-translation"} {:args [], :type "float", :name ":get-values"} {:args [], :type "Matrix4", :text "Sets the matrix to an identity matrix.", :name ":idt"} {:args [], :type "Matrix4", :text "Inverts the matrix. Stores the result in this matrix.", :name ":inv"} {:args [["Matrix4" "matrix"] ["float" "alpha"]], :type "Matrix4", :text "Linearly interpolates between this matrix and the given matrix mixing by alpha", :name ":lerp"} {:args [["Matrix4" "matrix"]], :type "Matrix4", :text "Postmultiplies this matrix with the given matrix, storing the result in this matrix. For example:\n \n <pre>\n A.mul(B) results in A := AB.\n </pre>", :name ":mul"} {:args [["Matrix4" "matrix"]], :type "Matrix4", :text "Premultiplies this matrix with the given matrix, storing the result in this matrix. For example:\n \n <pre>\n A.mulLeft(B) results in A := BA.\n </pre>", :name ":mul-left"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "degrees"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale", :name ":rotate"} {:args [["Quaternion" "rotation"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate"} {:args [["Vector3" "v1"] ["Vector3" "v2"]], :type "Matrix4", :text "Postmultiplies this matrix by the rotation between two vectors.", :name ":rotate"} {:args [["Vector3" "axis"] ["float" "radians"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate-rad"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "radians"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale", :name ":rotate-rad"} {:args [["float" "scale-x"] ["float" "scale-y"] ["float" "scale-z"]], :type "Matrix4", :text "Postmultiplies this matrix with a scale matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":scale"} {:args [["Vector3" "scale"]], :type "Matrix4", :name ":scl"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :name ":scl"} {:args [["float" "scale"]], :type "Matrix4", :name ":scl"} {:args [["Matrix4" "matrix"]], :type "Matrix4", :text "Sets the matrix to the given matrix.", :name ":set"} {:args [["float[]" "values"]], :type "Matrix4", :text "Sets the matrix to the given matrix as a float array. The float array must have at least 16 elements; the first 16 will be\n copied.", :name ":set"} {:args [["Quaternion" "quaternion"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix representing the quaternion.", :name ":set"} {:args [["float" "quaternion-x"] ["float" "quaternion-y"] ["float" "quaternion-z"] ["float" "quaternion-w"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix representing the quaternion.", :name ":set"} {:args [["Vector3" "position"] ["Quaternion" "orientation"]], :type "Matrix4", :text "Set this matrix to the specified translation and rotation.", :name ":set"} {:args [["float" "translation-x"] ["float" "translation-y"] ["float" "translation-z"] ["float" "quaternion-x"] ["float" "quaternion-y"] ["float" "quaternion-z"] ["float" "quaternion-w"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix representing the translation and quaternion.", :name ":set"} {:args [["Vector3" "position"] ["Quaternion" "orientation"] ["Vector3" "scale"]], :type "Matrix4", :text "Set this matrix to the specified translation, rotation and scale.", :name ":set"} {:args [["float" "translation-x"] ["float" "translation-y"] ["float" "translation-z"] ["float" "quaternion-x"] ["float" "quaternion-y"] ["float" "quaternion-z"] ["float" "quaternion-w"] ["float" "scale-x"] ["float" "scale-y"] ["float" "scale-z"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix representing the translation and quaternion.", :name ":set"} {:args [["Vector3" "x-axis"] ["Vector3" "y-axis"] ["Vector3" "z-axis"] ["Vector3" "pos"]], :type "Matrix4", :text "Sets the four columns of the matrix which correspond to the x-, y- and z-axis of the vector space this matrix creates as\n well as the 4th column representing the translation of any point that is multiplied by this matrix.", :name ":set"} {:args [["Matrix3" "mat"]], :type "Matrix4", :text "Sets this matrix to the given 3x3 matrix. The third column of this matrix is set to (0,0,1,0).", :name ":set"} {:args [["float" "yaw"] ["float" "pitch"] ["float" "roll"]], :type "Matrix4", :text "Sets this matrix to a rotation matrix from the given euler angles.", :name ":set-from-euler-angles"} {:args [["Vector3" "direction"] ["Vector3" "up"]], :type "Matrix4", :text "Sets the matrix to a look at matrix with a direction and an up vector. Multiply with a translation matrix to get a camera\n model view matrix.", :name ":set-to-look-at"} {:args [["Vector3" "position"] ["Vector3" "target"] ["Vector3" "up"]], :type "Matrix4", :text "Sets this matrix to a look at matrix with the given position, target and up vector.", :name ":set-to-look-at"} {:args [["float" "left"] ["float" "right"] ["float" "bottom"] ["float" "top"] ["float" "near"] ["float" "far"]], :type "Matrix4", :text "Sets the matrix to an orthographic projection like glOrtho (http://www.opengl.org/sdk/docs/man/xhtml/glOrtho.xml) following\n the OpenGL equivalent", :name ":set-to-ortho"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "Matrix4", :text "Sets this matrix to an orthographic projection matrix with the origin at (x,y) extending by width and height. The near plane\n is set to 0, the far plane is set to 1.", :name ":set-to-ortho2d"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["float" "near"] ["float" "far"]], :type "Matrix4", :text "Sets this matrix to an orthographic projection matrix with the origin at (x,y) extending by width and height, having a near\n and far plane.", :name ":set-to-ortho2d"} {:args [["float" "near"] ["float" "far"] ["float" "fov"] ["float" "aspect-ratio"]], :type "Matrix4", :text "Sets the matrix to a projection matrix with a near- and far plane, a field of view in degrees and an aspect ratio.", :name ":set-to-projection"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix around the given axis.", :name ":set-to-rotation"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "degrees"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix around the given axis.", :name ":set-to-rotation"} {:args [["Vector3" "v1"] ["Vector3" "v2"]], :type "Matrix4", :text "Set the matrix to a rotation matrix between two vectors.", :name ":set-to-rotation"} {:args [["float" "x1"] ["float" "y1"] ["float" "z1"] ["float" "x2"] ["float" "y2"] ["float" "z2"]], :type "Matrix4", :text "Set the matrix to a rotation matrix between two vectors.", :name ":set-to-rotation"} {:args [["Vector3" "axis"] ["float" "radians"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix around the given axis.", :name ":set-to-rotation-rad"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "radians"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix around the given axis.", :name ":set-to-rotation-rad"} {:args [["Vector3" "vector"]], :type "Matrix4", :text "Sets this matrix to a scaling matrix", :name ":set-to-scaling"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Sets this matrix to a scaling matrix", :name ":set-to-scaling"} {:args [["Vector3" "vector"]], :type "Matrix4", :text "Sets this matrix to a translation matrix, overwriting it first by an identity matrix and then setting the 4th column to the\n translation vector.", :name ":set-to-translation"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Sets this matrix to a translation matrix, overwriting it first by an identity matrix and then setting the 4th column to the\n translation vector.", :name ":set-to-translation"} {:args [["Vector3" "translation"] ["Vector3" "scaling"]], :type "Matrix4", :text "Sets this matrix to a translation and scaling matrix by first overwriting it with an identity and then setting the\n translation vector in the 4th column and the scaling vector in the diagonal.", :name ":set-to-translation-and-scaling"} {:args [["float" "translation-x"] ["float" "translation-y"] ["float" "translation-z"] ["float" "scaling-x"] ["float" "scaling-y"] ["float" "scaling-z"]], :type "Matrix4", :text "Sets this matrix to a translation and scaling matrix by first overwriting it with an identity and then setting the\n translation vector in the 4th column and the scaling vector in the diagonal.", :name ":set-to-translation-and-scaling"} {:args [["Vector3" "position"] ["Vector3" "forward"] ["Vector3" "up"]], :type "Matrix4", :name ":set-to-world"} {:args [["Vector3" "vector"]], :type "Matrix4", :text "Sets the 4th column to the translation vector.", :name ":set-translation"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Sets the 4th column to the translation vector.", :name ":set-translation"} {:args [], :type "Matrix4", :text "removes the translational part and transposes the matrix.", :name ":to-normal-matrix"} {:args [], :type "String", :name ":to-string"} {:args [], :type "Matrix4", :text "Transposes the matrix.", :name ":tra"} {:args [["Vector3" "translation"]], :type "Matrix4", :text "Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES'\n glTranslate/glRotate/glScale", :name ":translate"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":translate"} {:args [["Vector3" "vector"]], :type "Matrix4", :text "Adds a translational component to the matrix in the 4th column. The other columns are untouched.", :name ":trn"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Adds a translational component to the matrix in the 4th column. The other columns are untouched.", :name ":trn"}]}]], :name "matrix-4", :type :code, :raw "(defmacro matrix-4\n  [values & options]\n  `(u/calls! ^Matrix4 (matrix-4* ~values) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Matrix4.html'>Matrix4</a>.</p>"} {:raw* nil, :arglists [(matrix-4! object k & options)], :java [["matrix-4!" {:text "Encapsulates a <a href=\"http://en.wikipedia.org/wiki/Row-major_order#Column-major_order\">column major</a> 4 by 4 matrix. Like\n the {@link Vector3} class it allows the chaining of methods by returning a reference to itself. For example:\n \n <pre>\n Matrix4 mat = new Matrix4().trn(position).mul(camera.combined);\n </pre>", :items [{:args [], :type "Matrix4", :name ":cpy"} {:args [], :type "float", :name ":det"} {:args [], :type "float", :name ":det3x3"} {:args [["float[]" "dst"]], :text "Copies the 4x3 upper-left sub-matrix into float array. The destination array is supposed to be a column major matrix.", :name ":extract4x3matrix"} {:args [["Quaternion" "rotation"] ["boolean" "normalize-axes"]], :type "Quaternion", :text "Gets the rotation of this matrix.", :name ":get-rotation"} {:args [["Quaternion" "rotation"]], :type "Quaternion", :text "Gets the rotation of this matrix.", :name ":get-rotation"} {:args [["Vector3" "scale"]], :type "Vector3", :name ":get-scale"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-xsquared"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :name ":get-scale-ysquared"} {:args [], :type "float", :name ":get-scale-z"} {:args [], :type "float", :name ":get-scale-zsquared"} {:args [["Vector3" "position"]], :type "Vector3", :name ":get-translation"} {:args [], :type "float", :name ":get-values"} {:args [], :type "Matrix4", :text "Sets the matrix to an identity matrix.", :name ":idt"} {:args [], :type "Matrix4", :text "Inverts the matrix. Stores the result in this matrix.", :name ":inv"} {:args [["Matrix4" "matrix"] ["float" "alpha"]], :type "Matrix4", :text "Linearly interpolates between this matrix and the given matrix mixing by alpha", :name ":lerp"} {:args [["Matrix4" "matrix"]], :type "Matrix4", :text "Postmultiplies this matrix with the given matrix, storing the result in this matrix. For example:\n \n <pre>\n A.mul(B) results in A := AB.\n </pre>", :name ":mul"} {:args [["Matrix4" "matrix"]], :type "Matrix4", :text "Premultiplies this matrix with the given matrix, storing the result in this matrix. For example:\n \n <pre>\n A.mulLeft(B) results in A := BA.\n </pre>", :name ":mul-left"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "degrees"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale", :name ":rotate"} {:args [["Quaternion" "rotation"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate"} {:args [["Vector3" "v1"] ["Vector3" "v2"]], :type "Matrix4", :text "Postmultiplies this matrix by the rotation between two vectors.", :name ":rotate"} {:args [["Vector3" "axis"] ["float" "radians"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":rotate-rad"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "radians"]], :type "Matrix4", :text "Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale", :name ":rotate-rad"} {:args [["float" "scale-x"] ["float" "scale-y"] ["float" "scale-z"]], :type "Matrix4", :text "Postmultiplies this matrix with a scale matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":scale"} {:args [["Vector3" "scale"]], :type "Matrix4", :name ":scl"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :name ":scl"} {:args [["float" "scale"]], :type "Matrix4", :name ":scl"} {:args [["Matrix4" "matrix"]], :type "Matrix4", :text "Sets the matrix to the given matrix.", :name ":set"} {:args [["float[]" "values"]], :type "Matrix4", :text "Sets the matrix to the given matrix as a float array. The float array must have at least 16 elements; the first 16 will be\n copied.", :name ":set"} {:args [["Quaternion" "quaternion"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix representing the quaternion.", :name ":set"} {:args [["float" "quaternion-x"] ["float" "quaternion-y"] ["float" "quaternion-z"] ["float" "quaternion-w"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix representing the quaternion.", :name ":set"} {:args [["Vector3" "position"] ["Quaternion" "orientation"]], :type "Matrix4", :text "Set this matrix to the specified translation and rotation.", :name ":set"} {:args [["float" "translation-x"] ["float" "translation-y"] ["float" "translation-z"] ["float" "quaternion-x"] ["float" "quaternion-y"] ["float" "quaternion-z"] ["float" "quaternion-w"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix representing the translation and quaternion.", :name ":set"} {:args [["Vector3" "position"] ["Quaternion" "orientation"] ["Vector3" "scale"]], :type "Matrix4", :text "Set this matrix to the specified translation, rotation and scale.", :name ":set"} {:args [["float" "translation-x"] ["float" "translation-y"] ["float" "translation-z"] ["float" "quaternion-x"] ["float" "quaternion-y"] ["float" "quaternion-z"] ["float" "quaternion-w"] ["float" "scale-x"] ["float" "scale-y"] ["float" "scale-z"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix representing the translation and quaternion.", :name ":set"} {:args [["Vector3" "x-axis"] ["Vector3" "y-axis"] ["Vector3" "z-axis"] ["Vector3" "pos"]], :type "Matrix4", :text "Sets the four columns of the matrix which correspond to the x-, y- and z-axis of the vector space this matrix creates as\n well as the 4th column representing the translation of any point that is multiplied by this matrix.", :name ":set"} {:args [["Matrix3" "mat"]], :type "Matrix4", :text "Sets this matrix to the given 3x3 matrix. The third column of this matrix is set to (0,0,1,0).", :name ":set"} {:args [["float" "yaw"] ["float" "pitch"] ["float" "roll"]], :type "Matrix4", :text "Sets this matrix to a rotation matrix from the given euler angles.", :name ":set-from-euler-angles"} {:args [["Vector3" "direction"] ["Vector3" "up"]], :type "Matrix4", :text "Sets the matrix to a look at matrix with a direction and an up vector. Multiply with a translation matrix to get a camera\n model view matrix.", :name ":set-to-look-at"} {:args [["Vector3" "position"] ["Vector3" "target"] ["Vector3" "up"]], :type "Matrix4", :text "Sets this matrix to a look at matrix with the given position, target and up vector.", :name ":set-to-look-at"} {:args [["float" "left"] ["float" "right"] ["float" "bottom"] ["float" "top"] ["float" "near"] ["float" "far"]], :type "Matrix4", :text "Sets the matrix to an orthographic projection like glOrtho (http://www.opengl.org/sdk/docs/man/xhtml/glOrtho.xml) following\n the OpenGL equivalent", :name ":set-to-ortho"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "Matrix4", :text "Sets this matrix to an orthographic projection matrix with the origin at (x,y) extending by width and height. The near plane\n is set to 0, the far plane is set to 1.", :name ":set-to-ortho2d"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"] ["float" "near"] ["float" "far"]], :type "Matrix4", :text "Sets this matrix to an orthographic projection matrix with the origin at (x,y) extending by width and height, having a near\n and far plane.", :name ":set-to-ortho2d"} {:args [["float" "near"] ["float" "far"] ["float" "fov"] ["float" "aspect-ratio"]], :type "Matrix4", :text "Sets the matrix to a projection matrix with a near- and far plane, a field of view in degrees and an aspect ratio.", :name ":set-to-projection"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix around the given axis.", :name ":set-to-rotation"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "degrees"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix around the given axis.", :name ":set-to-rotation"} {:args [["Vector3" "v1"] ["Vector3" "v2"]], :type "Matrix4", :text "Set the matrix to a rotation matrix between two vectors.", :name ":set-to-rotation"} {:args [["float" "x1"] ["float" "y1"] ["float" "z1"] ["float" "x2"] ["float" "y2"] ["float" "z2"]], :type "Matrix4", :text "Set the matrix to a rotation matrix between two vectors.", :name ":set-to-rotation"} {:args [["Vector3" "axis"] ["float" "radians"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix around the given axis.", :name ":set-to-rotation-rad"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["float" "radians"]], :type "Matrix4", :text "Sets the matrix to a rotation matrix around the given axis.", :name ":set-to-rotation-rad"} {:args [["Vector3" "vector"]], :type "Matrix4", :text "Sets this matrix to a scaling matrix", :name ":set-to-scaling"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Sets this matrix to a scaling matrix", :name ":set-to-scaling"} {:args [["Vector3" "vector"]], :type "Matrix4", :text "Sets this matrix to a translation matrix, overwriting it first by an identity matrix and then setting the 4th column to the\n translation vector.", :name ":set-to-translation"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Sets this matrix to a translation matrix, overwriting it first by an identity matrix and then setting the 4th column to the\n translation vector.", :name ":set-to-translation"} {:args [["Vector3" "translation"] ["Vector3" "scaling"]], :type "Matrix4", :text "Sets this matrix to a translation and scaling matrix by first overwriting it with an identity and then setting the\n translation vector in the 4th column and the scaling vector in the diagonal.", :name ":set-to-translation-and-scaling"} {:args [["float" "translation-x"] ["float" "translation-y"] ["float" "translation-z"] ["float" "scaling-x"] ["float" "scaling-y"] ["float" "scaling-z"]], :type "Matrix4", :text "Sets this matrix to a translation and scaling matrix by first overwriting it with an identity and then setting the\n translation vector in the 4th column and the scaling vector in the diagonal.", :name ":set-to-translation-and-scaling"} {:args [["Vector3" "position"] ["Vector3" "forward"] ["Vector3" "up"]], :type "Matrix4", :name ":set-to-world"} {:args [["Vector3" "vector"]], :type "Matrix4", :text "Sets the 4th column to the translation vector.", :name ":set-translation"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Sets the 4th column to the translation vector.", :name ":set-translation"} {:args [], :type "Matrix4", :text "removes the translational part and transposes the matrix.", :name ":to-normal-matrix"} {:args [], :type "String", :name ":to-string"} {:args [], :type "Matrix4", :text "Transposes the matrix.", :name ":tra"} {:args [["Vector3" "translation"]], :type "Matrix4", :text "Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES'\n glTranslate/glRotate/glScale", :name ":translate"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES' 1.x\n glTranslate/glRotate/glScale.", :name ":translate"} {:args [["Vector3" "vector"]], :type "Matrix4", :text "Adds a translational component to the matrix in the 4th column. The other columns are untouched.", :name ":trn"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Matrix4", :text "Adds a translational component to the matrix in the 4th column. The other columns are untouched.", :name ":trn"}]}]], :name "matrix-4!", :type :code, :raw "(defmacro matrix-4!\n  [object k & options]\n  `(u/call! ^Matrix4 ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>matrix-4</code>.</p>"} {:raw* "(defn plane*\n  ([arg1 arg2]\n    (Plane. arg1 arg2))\n  ([^Vector3 p1 ^Vector3 p2 ^Vector3 p3]\n    (Plane. p1 p2 p3)))", :arglists [(plane args & options)], :java [["plane" {:text "A plane defined via a unit length normal and the distance from the origin, as you learned in your math class.", :items [{:args [["Vector3" "point"]], :type "float", :text "Calculates the shortest signed distance between the plane and the given point.", :name ":distance"} {:args [], :type "float", :name ":get-d"} {:args [], :type "Vector3", :name ":get-normal"} {:args [["Vector3" "direction"]], :type "boolean", :text "Returns whether the plane is facing the direction vector. Think of the direction vector as the direction a camera looks in.\n This method will return true if the front side of the plane determined by its normal faces the camera.", :name ":is-front-facing"} {:args [["Vector3" "point1"] ["Vector3" "point2"] ["Vector3" "point3"]], :text "Sets the plane normal and distance to the origin based on the three given points which are considered to be on the plane.\n The normal is calculated via a cross product between (point1-point2)x(point2-point3)", :name ":set"} {:args [["float" "nx"] ["float" "ny"] ["float" "nz"] ["float" "d"]], :text "Sets the plane normal and distance", :name ":set"} {:args [["Vector3" "point"] ["Vector3" "normal"]], :text "Sets the plane to the given point and normal.", :name ":set"} {:args [["float" "point-x"] ["float" "point-y"] ["float" "point-z"] ["float" "nor-x"] ["float" "nor-y"] ["float" "nor-z"]], :name ":set"} {:args [["Plane" "plane"]], :text "Sets this plane from the given plane", :name ":set"} {:args [["Vector3" "point"]], :type "Plane.PlaneSide", :text "Returns on which side the given point lies relative to the plane and its normal. PlaneSide.Front refers to the side the\n plane normal points to.", :name ":test-point"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Plane.PlaneSide", :text "Returns on which side the given point lies relative to the plane and its normal. PlaneSide.Front refers to the side the\n plane normal points to.", :name ":test-point"} {:args [], :type "String", :name ":to-string"}]}]], :name "plane", :type :code, :raw "(defmacro plane\n  [args & options]\n  `(u/calls! ^Plane (apply plane* ~args) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Plane.html'>Plane</a>.</p>"} {:raw* nil, :arglists [(plane! object k & options)], :java [["plane!" {:text "A plane defined via a unit length normal and the distance from the origin, as you learned in your math class.", :items [{:args [["Vector3" "point"]], :type "float", :text "Calculates the shortest signed distance between the plane and the given point.", :name ":distance"} {:args [], :type "float", :name ":get-d"} {:args [], :type "Vector3", :name ":get-normal"} {:args [["Vector3" "direction"]], :type "boolean", :text "Returns whether the plane is facing the direction vector. Think of the direction vector as the direction a camera looks in.\n This method will return true if the front side of the plane determined by its normal faces the camera.", :name ":is-front-facing"} {:args [["Vector3" "point1"] ["Vector3" "point2"] ["Vector3" "point3"]], :text "Sets the plane normal and distance to the origin based on the three given points which are considered to be on the plane.\n The normal is calculated via a cross product between (point1-point2)x(point2-point3)", :name ":set"} {:args [["float" "nx"] ["float" "ny"] ["float" "nz"] ["float" "d"]], :text "Sets the plane normal and distance", :name ":set"} {:args [["Vector3" "point"] ["Vector3" "normal"]], :text "Sets the plane to the given point and normal.", :name ":set"} {:args [["float" "point-x"] ["float" "point-y"] ["float" "point-z"] ["float" "nor-x"] ["float" "nor-y"] ["float" "nor-z"]], :name ":set"} {:args [["Plane" "plane"]], :text "Sets this plane from the given plane", :name ":set"} {:args [["Vector3" "point"]], :type "Plane.PlaneSide", :text "Returns on which side the given point lies relative to the plane and its normal. PlaneSide.Front refers to the side the\n plane normal points to.", :name ":test-point"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Plane.PlaneSide", :text "Returns on which side the given point lies relative to the plane and its normal. PlaneSide.Front refers to the side the\n plane normal points to.", :name ":test-point"} {:args [], :type "String", :name ":to-string"}]}]], :name "plane!", :type :code, :raw "(defmacro plane!\n  [object k & options]\n  `(u/call! ^Plane ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>plane</code>.</p>"} {:raw* "(defn polygon*\n  ([]\n    (Polygon.))\n  ([vertices]\n    (Polygon. vertices)))", :arglists [(polygon vertices & options)], :java [["polygon" {:text "Encapsulates a 2D polygon defined by it's vertices relative to an origin point (default of 0, 0).", :items [{:args [], :type "float", :text "Returns the area contained within the polygon.", :name ":area"} {:args [["float" "x"] ["float" "y"]], :type "boolean", :text "Returns whether an x, y pair is contained within the polygon.", :name ":contains"} {:args [], :text "Sets the polygon's world vertices to be recalculated when calling {@link #getTransformedVertices() getTransformedVertices}.", :name ":dirty"} {:args [], :type "Rectangle", :text "Returns an axis-aligned bounding box of this polygon.\n \n Note the returned Rectangle is cached in this polygon, and will be reused if this Polygon is changed.", :name ":get-bounding-rectangle"} {:args [], :type "float", :text "Returns the x-coordinate of the polygon's origin point.", :name ":get-origin-x"} {:args [], :type "float", :text "Returns the y-coordinate of the polygon's origin point.", :name ":get-origin-y"} {:args [], :type "float", :text "Returns the total rotation applied to the polygon.", :name ":get-rotation"} {:args [], :type "float", :text "Returns the total horizontal scaling applied to the polygon.", :name ":get-scale-x"} {:args [], :type "float", :text "Returns the total vertical scaling applied to the polygon.", :name ":get-scale-y"} {:args [], :type "float", :text "Calculates and returns the vertices of the polygon after scaling, rotation, and positional translations have been applied,\n as they are position within the world.", :name ":get-transformed-vertices"} {:args [], :type "float", :text "Returns the polygon's local vertices without scaling or rotation and without being offset by the polygon position.", :name ":get-vertices"} {:args [], :type "float", :text "Returns the x-coordinate of the polygon's position within the world.", :name ":get-x"} {:args [], :type "float", :text "Returns the y-coordinate of the polygon's position within the world.", :name ":get-y"} {:args [["float" "degrees"]], :text "Applies additional rotation to the polygon by the supplied degrees.", :name ":rotate"} {:args [["float" "amount"]], :text "Applies additional scaling to the polygon by the supplied amount.", :name ":scale"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the origin point to which all of the polygon's local vertices are relative to.", :name ":set-origin"} {:args [["float" "x"] ["float" "y"]], :text "Sets the polygon's position within the world.", :name ":set-position"} {:args [["float" "degrees"]], :text "Sets the polygon to be rotated by the supplied degrees.", :name ":set-rotation"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the amount of scaling to be applied to the polygon.", :name ":set-scale"} {:args [["float[]" "vertices"]], :text "Sets the polygon's local vertices relative to the origin point, without any scaling, rotating or translations being applied.", :name ":set-vertices"} {:args [["float" "x"] ["float" "y"]], :text "Translates the polygon's position by the specified horizontal and vertical amounts.", :name ":translate"}]}]], :name "polygon", :type :code, :raw "(defmacro polygon\n  [vertices & options]\n  `(u/calls! ^Polygon (polygon* ~vertices) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Polygon.html'>Polygon</a>.</p>"} {:raw* nil, :arglists [(polygon! object k & options)], :java [["polygon!" {:text "Encapsulates a 2D polygon defined by it's vertices relative to an origin point (default of 0, 0).", :items [{:args [], :type "float", :text "Returns the area contained within the polygon.", :name ":area"} {:args [["float" "x"] ["float" "y"]], :type "boolean", :text "Returns whether an x, y pair is contained within the polygon.", :name ":contains"} {:args [], :text "Sets the polygon's world vertices to be recalculated when calling {@link #getTransformedVertices() getTransformedVertices}.", :name ":dirty"} {:args [], :type "Rectangle", :text "Returns an axis-aligned bounding box of this polygon.\n \n Note the returned Rectangle is cached in this polygon, and will be reused if this Polygon is changed.", :name ":get-bounding-rectangle"} {:args [], :type "float", :text "Returns the x-coordinate of the polygon's origin point.", :name ":get-origin-x"} {:args [], :type "float", :text "Returns the y-coordinate of the polygon's origin point.", :name ":get-origin-y"} {:args [], :type "float", :text "Returns the total rotation applied to the polygon.", :name ":get-rotation"} {:args [], :type "float", :text "Returns the total horizontal scaling applied to the polygon.", :name ":get-scale-x"} {:args [], :type "float", :text "Returns the total vertical scaling applied to the polygon.", :name ":get-scale-y"} {:args [], :type "float", :text "Calculates and returns the vertices of the polygon after scaling, rotation, and positional translations have been applied,\n as they are position within the world.", :name ":get-transformed-vertices"} {:args [], :type "float", :text "Returns the polygon's local vertices without scaling or rotation and without being offset by the polygon position.", :name ":get-vertices"} {:args [], :type "float", :text "Returns the x-coordinate of the polygon's position within the world.", :name ":get-x"} {:args [], :type "float", :text "Returns the y-coordinate of the polygon's position within the world.", :name ":get-y"} {:args [["float" "degrees"]], :text "Applies additional rotation to the polygon by the supplied degrees.", :name ":rotate"} {:args [["float" "amount"]], :text "Applies additional scaling to the polygon by the supplied amount.", :name ":scale"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the origin point to which all of the polygon's local vertices are relative to.", :name ":set-origin"} {:args [["float" "x"] ["float" "y"]], :text "Sets the polygon's position within the world.", :name ":set-position"} {:args [["float" "degrees"]], :text "Sets the polygon to be rotated by the supplied degrees.", :name ":set-rotation"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the amount of scaling to be applied to the polygon.", :name ":set-scale"} {:args [["float[]" "vertices"]], :text "Sets the polygon's local vertices relative to the origin point, without any scaling, rotating or translations being applied.", :name ":set-vertices"} {:args [["float" "x"] ["float" "y"]], :text "Translates the polygon's position by the specified horizontal and vertical amounts.", :name ":translate"}]}]], :name "polygon!", :type :code, :raw "(defmacro polygon!\n  [object k & options]\n  `(u/call! ^Polygon ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>polygon</code>.</p>"} {:raw* "(defn polyline*\n  ([]\n    (Polyline.))\n  ([vertices]\n    (Polyline. vertices)))", :arglists [(polyline vertices & options)], :java [["polyline" {:text "", :items [{:args [], :name ":calculate-length"} {:args [], :name ":calculate-scaled-length"} {:args [], :name ":dirty"} {:args [], :type "float", :text "Returns the euclidean length of the polyline without scaling", :name ":get-length"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :text "Returns the euclidean length of the polyline", :name ":get-scaled-length"} {:args [], :type "float", :text "Returns vertices scaled, rotated, and offset by the polygon position.", :name ":get-transformed-vertices"} {:args [], :type "float", :text "Returns vertices without scaling or rotation and without being offset by the polyline position.", :name ":get-vertices"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [["float" "degrees"]], :name ":rotate"} {:args [["float" "amount"]], :name ":scale"} {:args [["float" "origin-x"] ["float" "origin-y"]], :name ":set-origin"} {:args [["float" "x"] ["float" "y"]], :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-x"] ["float" "scale-y"]], :name ":set-scale"} {:args [["float" "x"] ["float" "y"]], :name ":translate"}]}]], :name "polyline", :type :code, :raw "(defmacro polyline\n  [vertices & options]\n  `(u/calls! ^Polyline (polyline* ~vertices) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Polyline.html'>Polyline</a>.</p>"} {:raw* nil, :arglists [(polyline! object k & options)], :java [["polyline!" {:text "", :items [{:args [], :name ":calculate-length"} {:args [], :name ":calculate-scaled-length"} {:args [], :name ":dirty"} {:args [], :type "float", :text "Returns the euclidean length of the polyline without scaling", :name ":get-length"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :text "Returns the euclidean length of the polyline", :name ":get-scaled-length"} {:args [], :type "float", :text "Returns vertices scaled, rotated, and offset by the polygon position.", :name ":get-transformed-vertices"} {:args [], :type "float", :text "Returns vertices without scaling or rotation and without being offset by the polyline position.", :name ":get-vertices"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [["float" "degrees"]], :name ":rotate"} {:args [["float" "amount"]], :name ":scale"} {:args [["float" "origin-x"] ["float" "origin-y"]], :name ":set-origin"} {:args [["float" "x"] ["float" "y"]], :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-x"] ["float" "scale-y"]], :name ":set-scale"} {:args [["float" "x"] ["float" "y"]], :name ":translate"}]}]], :name "polyline!", :type :code, :raw "(defmacro polyline!\n  [object k & options]\n  `(u/call! ^Polyline ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>polyline</code>.</p>"} {:raw* "(defn quaternion*\n  ([]\n    (Quaternion.))\n  ([w x y z]\n    (Quaternion. w x y z)))", :arglists [(quaternion w x y z & options)], :java [["quaternion" {:text "A simple quaternion class.", :items [{:args [], :type "Quaternion", :text "Conjugate the quaternion.", :name ":conjugate"} {:args [], :type "Quaternion", :name ":cpy"} {:args [["Quaternion" "other"]], :type "float", :text "Get the dot product between this and the other quaternion (commutative).", :name ":dot"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :type "float", :text "Get the dot product between this and the other quaternion (commutative).", :name ":dot"} {:args [["Object" "obj"]], :type "boolean", :name ":equals"} {:args [], :type "float", :text "Get the angle in degrees of the rotation this quaternion represents. Use {@link #getAxisAngle(Vector3)} to get both the axis\n and the angle of this rotation. Use {@link #getAngleAround(Vector3)} to get the angle around a specific axis.", :name ":get-angle"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :type "float", :text "Get the angle in degrees of the rotation around the specified axis. The axis must be normalized.", :name ":get-angle-around"} {:args [["Vector3" "axis"]], :type "float", :text "Get the angle in degrees of the rotation around the specified axis. The axis must be normalized.", :name ":get-angle-around"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :type "float", :text "Get the angle in radians of the rotation around the specified axis. The axis must be normalized.", :name ":get-angle-around-rad"} {:args [["Vector3" "axis"]], :type "float", :text "Get the angle in radians of the rotation around the specified axis. The axis must be normalized.", :name ":get-angle-around-rad"} {:args [], :type "float", :text "Get the angle in radians of the rotation this quaternion represents. Does not normalize the quaternion. Use\n {@link #getAxisAngleRad(Vector3)} to get both the axis and the angle of this rotation. Use\n {@link #getAngleAroundRad(Vector3)} to get the angle around a specific axis.", :name ":get-angle-rad"} {:args [["Vector3" "axis"]], :type "float", :text "Get the axis angle representation of the rotation in degrees. The supplied vector will receive the axis (x, y and z values)\n of the rotation and the value returned is the angle in degrees around that axis. Note that this method will alter the\n supplied vector, the existing value of the vector is ignored. </p> This will normalize this quaternion if needed. The\n received axis is a unit vector. However, if this is an identity quaternion (no rotation), then the length of the axis may be\n zero.", :name ":get-axis-angle"} {:args [["Vector3" "axis"]], :type "float", :text "Get the axis-angle representation of the rotation in radians. The supplied vector will receive the axis (x, y and z values)\n of the rotation and the value returned is the angle in radians around that axis. Note that this method will alter the\n supplied vector, the existing value of the vector is ignored. </p> This will normalize this quaternion if needed. The\n received axis is a unit vector. However, if this is an identity quaternion (no rotation), then the length of the axis may be\n zero.", :name ":get-axis-angle-rad"} {:args [], :type "int", :text "Get the pole of the gimbal lock, if any.", :name ":get-gimbal-pole"} {:args [], :type "float", :text "Get the pitch euler angle in degrees, which is the rotation around the x axis. Requires that this quaternion is normalized.", :name ":get-pitch"} {:args [], :type "float", :text "Get the pitch euler angle in radians, which is the rotation around the x axis. Requires that this quaternion is normalized.", :name ":get-pitch-rad"} {:args [], :type "float", :text "Get the roll euler angle in degrees, which is the rotation around the z axis. Requires that this quaternion is normalized.", :name ":get-roll"} {:args [], :type "float", :text "Get the roll euler angle in radians, which is the rotation around the z axis. Requires that this quaternion is normalized.", :name ":get-roll-rad"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["Quaternion" "swing"] ["Quaternion" "twist"]], :text "Get the swing rotation and twist rotation for the specified axis. The twist rotation represents the rotation around the\n specified axis. The swing rotation represents the rotation of the specified axis itself, which is the rotation around an\n axis perpendicular to the specified axis.\n </p>\n The swing and twist rotation can be used to reconstruct the original quaternion: this = swing * twist", :name ":get-swing-twist"} {:args [["Vector3" "axis"] ["Quaternion" "swing"] ["Quaternion" "twist"]], :text "Get the swing rotation and twist rotation for the specified axis. The twist rotation represents the rotation around the\n specified axis. The swing rotation represents the rotation of the specified axis itself, which is the rotation around an\n axis perpendicular to the specified axis.\n </p>\n The swing and twist rotation can be used to reconstruct the original quaternion: this = swing * twist", :name ":get-swing-twist"} {:args [], :type "float", :text "Get the yaw euler angle in degrees, which is the rotation around the y axis. Requires that this quaternion is normalized.", :name ":get-yaw"} {:args [], :type "float", :text "Get the yaw euler angle in radians, which is the rotation around the y axis. Requires that this quaternion is normalized.", :name ":get-yaw-rad"} {:args [], :type "int", :name ":hash-code"} {:args [], :type "Quaternion", :text "Sets the quaternion to an identity Quaternion", :name ":idt"} {:args [], :type "boolean", :name ":is-identity"} {:args [["float" "tolerance"]], :type "boolean", :name ":is-identity"} {:args [], :type "float", :name ":len"} {:args [], :type "float", :name ":len2"} {:args [["Quaternion" "other"]], :type "Quaternion", :text "Multiplies this quaternion with another one in the form of this = this * other", :name ":mul"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :type "Quaternion", :text "Multiplies this quaternion with another one in the form of this = this * other", :name ":mul"} {:args [["float" "scalar"]], :type "Quaternion", :text "Multiplies the components of this quaternion with the given scalar.", :name ":mul"} {:args [["Quaternion" "other"]], :type "Quaternion", :text "Multiplies this quaternion with another one in the form of this = other * this", :name ":mul-left"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :type "Quaternion", :text "Multiplies this quaternion with another one in the form of this = other * this", :name ":mul-left"} {:args [], :type "Quaternion", :text "Normalizes this quaternion to unit length", :name ":nor"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :type "Quaternion", :text "Sets the components of the quaternion", :name ":set"} {:args [["Quaternion" "quaternion"]], :type "Quaternion", :text "Sets the quaternion components from the given quaternion.", :name ":set"} {:args [["Vector3" "axis"] ["float" "angle"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set"} {:args [["float" "yaw"] ["float" "pitch"] ["float" "roll"]], :type "Quaternion", :text "Sets the quaternion to the given euler angles in degrees.", :name ":set-euler-angles"} {:args [["float" "yaw"] ["float" "pitch"] ["float" "roll"]], :type "Quaternion", :text "Sets the quaternion to the given euler angles in radians.", :name ":set-euler-angles-rad"} {:args [["float" "xx"] ["float" "xy"] ["float" "xz"] ["float" "yx"] ["float" "yy"] ["float" "yz"] ["float" "zx"] ["float" "zy"] ["float" "zz"]], :type "Quaternion", :text "<p>\n Sets the Quaternion from the given x-, y- and z-axis which have to be orthonormal.\n </p>\n \n <p>\n Taken from Bones framework for JPCT, see http://www.aptalkarga.com/bones/ which in turn took it from Graphics Gem code at\n ftp://ftp.cis.upenn.edu/pub/graphics/shoemake/quatut.ps.Z.\n </p>", :name ":set-from-axes"} {:args [["boolean" "normalize-axes"] ["float" "xx"] ["float" "xy"] ["float" "xz"] ["float" "yx"] ["float" "yy"] ["float" "yz"] ["float" "zx"] ["float" "zy"] ["float" "zz"]], :type "Quaternion", :text "<p>\n Sets the Quaternion from the given x-, y- and z-axis.\n </p>\n \n <p>\n Taken from Bones framework for JPCT, see http://www.aptalkarga.com/bones/ which in turn took it from Graphics Gem code at\n ftp://ftp.cis.upenn.edu/pub/graphics/shoemake/quatut.ps.Z.\n </p>", :name ":set-from-axes"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set-from-axis"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "degrees"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set-from-axis"} {:args [["Vector3" "axis"] ["float" "radians"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set-from-axis-rad"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radians"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set-from-axis-rad"} {:args [["Vector3" "v1"] ["Vector3" "v2"]], :type "Quaternion", :text "Set this quaternion to the rotation between two vectors.", :name ":set-from-cross"} {:args [["float" "x1"] ["float" "y1"] ["float" "z1"] ["float" "x2"] ["float" "y2"] ["float" "z2"]], :type "Quaternion", :text "Set this quaternion to the rotation between two vectors.", :name ":set-from-cross"} {:args [["boolean" "normalize-axes"] ["Matrix4" "matrix"]], :type "Quaternion", :text "Sets the Quaternion from the given matrix, optionally removing any scaling.", :name ":set-from-matrix"} {:args [["Matrix4" "matrix"]], :type "Quaternion", :text "Sets the Quaternion from the given rotation matrix, which must not contain scaling.", :name ":set-from-matrix"} {:args [["boolean" "normalize-axes"] ["Matrix3" "matrix"]], :type "Quaternion", :text "Sets the Quaternion from the given matrix, optionally removing any scaling.", :name ":set-from-matrix"} {:args [["Matrix3" "matrix"]], :type "Quaternion", :text "Sets the Quaternion from the given rotation matrix, which must not contain scaling.", :name ":set-from-matrix"} {:args [["Quaternion" "end"] ["float" "alpha"]], :type "Quaternion", :text "Spherical linear interpolation between this quaternion and the other quaternion, based on the alpha value in the range\n [0,1]. Taken from. Taken from Bones framework for JPCT, see http://www.aptalkarga.com/bones/", :name ":slerp"} {:args [["float[]" "matrix"]], :text "Fills a 4x4 matrix with the rotation matrix represented by this quaternion.", :name ":to-matrix"} {:args [], :type "String", :name ":to-string"} {:args [["Vector3" "v"]], :type "Vector3", :text "Transforms the given vector using this quaternion", :name ":transform"}]}]], :name "quaternion", :type :code, :raw "(defmacro quaternion\n  [w x y z & options]\n  `(u/calls! ^Quaternion (quaternion* ~w ~x ~y ~z) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Quaternion.html'>Quaternion</a>.</p>"} {:raw* nil, :arglists [(quaternion! object k & options)], :java [["quaternion!" {:text "A simple quaternion class.", :items [{:args [], :type "Quaternion", :text "Conjugate the quaternion.", :name ":conjugate"} {:args [], :type "Quaternion", :name ":cpy"} {:args [["Quaternion" "other"]], :type "float", :text "Get the dot product between this and the other quaternion (commutative).", :name ":dot"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :type "float", :text "Get the dot product between this and the other quaternion (commutative).", :name ":dot"} {:args [["Object" "obj"]], :type "boolean", :name ":equals"} {:args [], :type "float", :text "Get the angle in degrees of the rotation this quaternion represents. Use {@link #getAxisAngle(Vector3)} to get both the axis\n and the angle of this rotation. Use {@link #getAngleAround(Vector3)} to get the angle around a specific axis.", :name ":get-angle"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :type "float", :text "Get the angle in degrees of the rotation around the specified axis. The axis must be normalized.", :name ":get-angle-around"} {:args [["Vector3" "axis"]], :type "float", :text "Get the angle in degrees of the rotation around the specified axis. The axis must be normalized.", :name ":get-angle-around"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :type "float", :text "Get the angle in radians of the rotation around the specified axis. The axis must be normalized.", :name ":get-angle-around-rad"} {:args [["Vector3" "axis"]], :type "float", :text "Get the angle in radians of the rotation around the specified axis. The axis must be normalized.", :name ":get-angle-around-rad"} {:args [], :type "float", :text "Get the angle in radians of the rotation this quaternion represents. Does not normalize the quaternion. Use\n {@link #getAxisAngleRad(Vector3)} to get both the axis and the angle of this rotation. Use\n {@link #getAngleAroundRad(Vector3)} to get the angle around a specific axis.", :name ":get-angle-rad"} {:args [["Vector3" "axis"]], :type "float", :text "Get the axis angle representation of the rotation in degrees. The supplied vector will receive the axis (x, y and z values)\n of the rotation and the value returned is the angle in degrees around that axis. Note that this method will alter the\n supplied vector, the existing value of the vector is ignored. </p> This will normalize this quaternion if needed. The\n received axis is a unit vector. However, if this is an identity quaternion (no rotation), then the length of the axis may be\n zero.", :name ":get-axis-angle"} {:args [["Vector3" "axis"]], :type "float", :text "Get the axis-angle representation of the rotation in radians. The supplied vector will receive the axis (x, y and z values)\n of the rotation and the value returned is the angle in radians around that axis. Note that this method will alter the\n supplied vector, the existing value of the vector is ignored. </p> This will normalize this quaternion if needed. The\n received axis is a unit vector. However, if this is an identity quaternion (no rotation), then the length of the axis may be\n zero.", :name ":get-axis-angle-rad"} {:args [], :type "int", :text "Get the pole of the gimbal lock, if any.", :name ":get-gimbal-pole"} {:args [], :type "float", :text "Get the pitch euler angle in degrees, which is the rotation around the x axis. Requires that this quaternion is normalized.", :name ":get-pitch"} {:args [], :type "float", :text "Get the pitch euler angle in radians, which is the rotation around the x axis. Requires that this quaternion is normalized.", :name ":get-pitch-rad"} {:args [], :type "float", :text "Get the roll euler angle in degrees, which is the rotation around the z axis. Requires that this quaternion is normalized.", :name ":get-roll"} {:args [], :type "float", :text "Get the roll euler angle in radians, which is the rotation around the z axis. Requires that this quaternion is normalized.", :name ":get-roll-rad"} {:args [["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"] ["Quaternion" "swing"] ["Quaternion" "twist"]], :text "Get the swing rotation and twist rotation for the specified axis. The twist rotation represents the rotation around the\n specified axis. The swing rotation represents the rotation of the specified axis itself, which is the rotation around an\n axis perpendicular to the specified axis.\n </p>\n The swing and twist rotation can be used to reconstruct the original quaternion: this = swing * twist", :name ":get-swing-twist"} {:args [["Vector3" "axis"] ["Quaternion" "swing"] ["Quaternion" "twist"]], :text "Get the swing rotation and twist rotation for the specified axis. The twist rotation represents the rotation around the\n specified axis. The swing rotation represents the rotation of the specified axis itself, which is the rotation around an\n axis perpendicular to the specified axis.\n </p>\n The swing and twist rotation can be used to reconstruct the original quaternion: this = swing * twist", :name ":get-swing-twist"} {:args [], :type "float", :text "Get the yaw euler angle in degrees, which is the rotation around the y axis. Requires that this quaternion is normalized.", :name ":get-yaw"} {:args [], :type "float", :text "Get the yaw euler angle in radians, which is the rotation around the y axis. Requires that this quaternion is normalized.", :name ":get-yaw-rad"} {:args [], :type "int", :name ":hash-code"} {:args [], :type "Quaternion", :text "Sets the quaternion to an identity Quaternion", :name ":idt"} {:args [], :type "boolean", :name ":is-identity"} {:args [["float" "tolerance"]], :type "boolean", :name ":is-identity"} {:args [], :type "float", :name ":len"} {:args [], :type "float", :name ":len2"} {:args [["Quaternion" "other"]], :type "Quaternion", :text "Multiplies this quaternion with another one in the form of this = this * other", :name ":mul"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :type "Quaternion", :text "Multiplies this quaternion with another one in the form of this = this * other", :name ":mul"} {:args [["float" "scalar"]], :type "Quaternion", :text "Multiplies the components of this quaternion with the given scalar.", :name ":mul"} {:args [["Quaternion" "other"]], :type "Quaternion", :text "Multiplies this quaternion with another one in the form of this = other * this", :name ":mul-left"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :type "Quaternion", :text "Multiplies this quaternion with another one in the form of this = other * this", :name ":mul-left"} {:args [], :type "Quaternion", :text "Normalizes this quaternion to unit length", :name ":nor"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "w"]], :type "Quaternion", :text "Sets the components of the quaternion", :name ":set"} {:args [["Quaternion" "quaternion"]], :type "Quaternion", :text "Sets the quaternion components from the given quaternion.", :name ":set"} {:args [["Vector3" "axis"] ["float" "angle"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set"} {:args [["float" "yaw"] ["float" "pitch"] ["float" "roll"]], :type "Quaternion", :text "Sets the quaternion to the given euler angles in degrees.", :name ":set-euler-angles"} {:args [["float" "yaw"] ["float" "pitch"] ["float" "roll"]], :type "Quaternion", :text "Sets the quaternion to the given euler angles in radians.", :name ":set-euler-angles-rad"} {:args [["float" "xx"] ["float" "xy"] ["float" "xz"] ["float" "yx"] ["float" "yy"] ["float" "yz"] ["float" "zx"] ["float" "zy"] ["float" "zz"]], :type "Quaternion", :text "<p>\n Sets the Quaternion from the given x-, y- and z-axis which have to be orthonormal.\n </p>\n \n <p>\n Taken from Bones framework for JPCT, see http://www.aptalkarga.com/bones/ which in turn took it from Graphics Gem code at\n ftp://ftp.cis.upenn.edu/pub/graphics/shoemake/quatut.ps.Z.\n </p>", :name ":set-from-axes"} {:args [["boolean" "normalize-axes"] ["float" "xx"] ["float" "xy"] ["float" "xz"] ["float" "yx"] ["float" "yy"] ["float" "yz"] ["float" "zx"] ["float" "zy"] ["float" "zz"]], :type "Quaternion", :text "<p>\n Sets the Quaternion from the given x-, y- and z-axis.\n </p>\n \n <p>\n Taken from Bones framework for JPCT, see http://www.aptalkarga.com/bones/ which in turn took it from Graphics Gem code at\n ftp://ftp.cis.upenn.edu/pub/graphics/shoemake/quatut.ps.Z.\n </p>", :name ":set-from-axes"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set-from-axis"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "degrees"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set-from-axis"} {:args [["Vector3" "axis"] ["float" "radians"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set-from-axis-rad"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "radians"]], :type "Quaternion", :text "Sets the quaternion components from the given axis and angle around that axis.", :name ":set-from-axis-rad"} {:args [["Vector3" "v1"] ["Vector3" "v2"]], :type "Quaternion", :text "Set this quaternion to the rotation between two vectors.", :name ":set-from-cross"} {:args [["float" "x1"] ["float" "y1"] ["float" "z1"] ["float" "x2"] ["float" "y2"] ["float" "z2"]], :type "Quaternion", :text "Set this quaternion to the rotation between two vectors.", :name ":set-from-cross"} {:args [["boolean" "normalize-axes"] ["Matrix4" "matrix"]], :type "Quaternion", :text "Sets the Quaternion from the given matrix, optionally removing any scaling.", :name ":set-from-matrix"} {:args [["Matrix4" "matrix"]], :type "Quaternion", :text "Sets the Quaternion from the given rotation matrix, which must not contain scaling.", :name ":set-from-matrix"} {:args [["boolean" "normalize-axes"] ["Matrix3" "matrix"]], :type "Quaternion", :text "Sets the Quaternion from the given matrix, optionally removing any scaling.", :name ":set-from-matrix"} {:args [["Matrix3" "matrix"]], :type "Quaternion", :text "Sets the Quaternion from the given rotation matrix, which must not contain scaling.", :name ":set-from-matrix"} {:args [["Quaternion" "end"] ["float" "alpha"]], :type "Quaternion", :text "Spherical linear interpolation between this quaternion and the other quaternion, based on the alpha value in the range\n [0,1]. Taken from. Taken from Bones framework for JPCT, see http://www.aptalkarga.com/bones/", :name ":slerp"} {:args [["float[]" "matrix"]], :text "Fills a 4x4 matrix with the rotation matrix represented by this quaternion.", :name ":to-matrix"} {:args [], :type "String", :name ":to-string"} {:args [["Vector3" "v"]], :type "Vector3", :text "Transforms the given vector using this quaternion", :name ":transform"}]}]], :name "quaternion!", :type :code, :raw "(defmacro quaternion!\n  [object k & options]\n  `(u/call! ^Quaternion ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>quaternion</code>.</p>"} {:raw* "(defn rectangle*\n  ([]\n    (Rectangle.))\n  ([x y width height]\n    (Rectangle. x y width height)))", :arglists [(rectangle x y width height & options)], :java [["rectangle" {:text "Encapsulates a 2D rectangle defined by it's bottom corner point and its extends in x (width) and y (height).", :items [{:args [["float" "x"] ["float" "y"]], :type "boolean", :name ":contains"} {:args [["Vector2" "point"]], :type "boolean", :name ":contains"} {:args [["Rectangle" "rectangle"]], :type "boolean", :name ":contains"} {:args [["Rectangle" "rect"]], :type "Rectangle", :text "Fits this rectangle into another rectangle while maintaining aspect ratio. This scales and centers the rectangle to the\n other rectangle (e.g. Scaling a texture within a arbitrary cell without squeezing)", :name ":fit-inside"} {:args [["Rectangle" "rect"]], :type "Rectangle", :text "Fits this rectangle around another rectangle while maintaining aspect ratio This scales and centers the rectangle to the\n other rectangle (e.g. Having a camera translate and scale to show a given area)", :name ":fit-outside"} {:args [], :type "float", :text "Calculates the aspect ratio ( width / height ) of this rectangle", :name ":get-aspect-ratio"} {:args [["Vector2" "vector"]], :type "Vector2", :text "Calculates the center of the rectangle. Results are located in the given Vector2", :name ":get-center"} {:args [], :type "float", :name ":get-height"} {:args [["Vector2" "position"]], :type "Vector2", :text "return the Vector2 with coordinates of this rectangle", :name ":get-position"} {:args [["Vector2" "size"]], :type "Vector2", :name ":get-size"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [["Rectangle" "rect"]], :type "Rectangle", :text "Merges this rectangle with the other rectangle.", :name ":merge"} {:args [["Rectangle" "r"]], :type "boolean", :name ":overlaps"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "Rectangle", :name ":set"} {:args [["Rectangle" "rect"]], :type "Rectangle", :text "Sets the values of the given rectangle to this rectangle.", :name ":set"} {:args [["float" "x"] ["float" "y"]], :type "Rectangle", :text "Moves this rectangle so that its center point is located at a given position", :name ":set-center"} {:args [["Vector2" "position"]], :type "Rectangle", :text "Moves this rectangle so that its center point is located at a given position", :name ":set-center"} {:args [["float" "height"]], :type "Rectangle", :text "Sets the height of this rectangle", :name ":set-height"} {:args [["Vector2" "position"]], :type "Rectangle", :text "Sets the x and y-coordinates of the bottom left corner from vector", :name ":set-position"} {:args [["float" "x"] ["float" "y"]], :type "Rectangle", :text "Sets the x and y-coordinates of the bottom left corner", :name ":set-position"} {:args [["float" "width"] ["float" "height"]], :type "Rectangle", :text "Sets the width and height of this rectangle", :name ":set-size"} {:args [["float" "size-xy"]], :type "Rectangle", :text "Sets the squared size of this rectangle", :name ":set-size"} {:args [["float" "width"]], :type "Rectangle", :text "Sets the width of this rectangle", :name ":set-width"} {:args [["float" "x"]], :type "Rectangle", :text "Sets the x-coordinate of the bottom left corner", :name ":set-x"} {:args [["float" "y"]], :type "Rectangle", :text "Sets the y-coordinate of the bottom left corner", :name ":set-y"} {:args [], :type "String", :name ":to-string"}]}]], :name "rectangle", :type :code, :raw "(defmacro rectangle\n  [x y width height & options]\n  `(u/calls! ^Rectangle (rectangle* ~x ~y ~width ~height) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Rectangle.html'>Rectangle</a>.</p>"} {:raw* nil, :arglists [(rectangle! object k & options)], :java [["rectangle!" {:text "Encapsulates a 2D rectangle defined by it's bottom corner point and its extends in x (width) and y (height).", :items [{:args [["float" "x"] ["float" "y"]], :type "boolean", :name ":contains"} {:args [["Vector2" "point"]], :type "boolean", :name ":contains"} {:args [["Rectangle" "rectangle"]], :type "boolean", :name ":contains"} {:args [["Rectangle" "rect"]], :type "Rectangle", :text "Fits this rectangle into another rectangle while maintaining aspect ratio. This scales and centers the rectangle to the\n other rectangle (e.g. Scaling a texture within a arbitrary cell without squeezing)", :name ":fit-inside"} {:args [["Rectangle" "rect"]], :type "Rectangle", :text "Fits this rectangle around another rectangle while maintaining aspect ratio This scales and centers the rectangle to the\n other rectangle (e.g. Having a camera translate and scale to show a given area)", :name ":fit-outside"} {:args [], :type "float", :text "Calculates the aspect ratio ( width / height ) of this rectangle", :name ":get-aspect-ratio"} {:args [["Vector2" "vector"]], :type "Vector2", :text "Calculates the center of the rectangle. Results are located in the given Vector2", :name ":get-center"} {:args [], :type "float", :name ":get-height"} {:args [["Vector2" "position"]], :type "Vector2", :text "return the Vector2 with coordinates of this rectangle", :name ":get-position"} {:args [["Vector2" "size"]], :type "Vector2", :name ":get-size"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [["Rectangle" "rect"]], :type "Rectangle", :text "Merges this rectangle with the other rectangle.", :name ":merge"} {:args [["Rectangle" "r"]], :type "boolean", :name ":overlaps"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "Rectangle", :name ":set"} {:args [["Rectangle" "rect"]], :type "Rectangle", :text "Sets the values of the given rectangle to this rectangle.", :name ":set"} {:args [["float" "x"] ["float" "y"]], :type "Rectangle", :text "Moves this rectangle so that its center point is located at a given position", :name ":set-center"} {:args [["Vector2" "position"]], :type "Rectangle", :text "Moves this rectangle so that its center point is located at a given position", :name ":set-center"} {:args [["float" "height"]], :type "Rectangle", :text "Sets the height of this rectangle", :name ":set-height"} {:args [["Vector2" "position"]], :type "Rectangle", :text "Sets the x and y-coordinates of the bottom left corner from vector", :name ":set-position"} {:args [["float" "x"] ["float" "y"]], :type "Rectangle", :text "Sets the x and y-coordinates of the bottom left corner", :name ":set-position"} {:args [["float" "width"] ["float" "height"]], :type "Rectangle", :text "Sets the width and height of this rectangle", :name ":set-size"} {:args [["float" "size-xy"]], :type "Rectangle", :text "Sets the squared size of this rectangle", :name ":set-size"} {:args [["float" "width"]], :type "Rectangle", :text "Sets the width of this rectangle", :name ":set-width"} {:args [["float" "x"]], :type "Rectangle", :text "Sets the x-coordinate of the bottom left corner", :name ":set-x"} {:args [["float" "y"]], :type "Rectangle", :text "Sets the y-coordinate of the bottom left corner", :name ":set-y"} {:args [], :type "String", :name ":to-string"}]}]], :name "rectangle!", :type :code, :raw "(defmacro rectangle!\n  [object k & options]\n  `(u/call! ^Rectangle ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>rectangle</code>.</p>"} {:raw* "(defn vector-2*\n  ([]\n    (Vector2.))\n  ([x y]\n    (Vector2. x y)))", :arglists [(vector-2 x y & options)], :java [["vector-2" {:text "Encapsulates a 2D vector. Allows chaining methods by returning a reference to itself", :items [{:args [["Vector2" "v"]], :type "Vector2", :name ":add"} {:args [["float" "x"] ["float" "y"]], :type "Vector2", :text "Adds the given components to this vector", :name ":add"} {:args [], :type "float", :name ":angle"} {:args [["float" "min"] ["float" "max"]], :type "Vector2", :name ":clamp"} {:args [], :type "Vector2", :name ":cpy"} {:args [["Vector2" "v"]], :type "float", :text "Calculates the 2D cross product between this and the given vector.", :name ":crs"} {:args [["float" "x"] ["float" "y"]], :type "float", :text "Calculates the 2D cross product between this and the given vector.", :name ":crs"} {:args [["Vector2" "v"]], :type "float", :name ":dot"} {:args [["float" "ox"] ["float" "oy"]], :type "float", :name ":dot"} {:args [["Vector2" "v"]], :type "float", :name ":dst"} {:args [["float" "x"] ["float" "y"]], :type "float", :name ":dst"} {:args [["Vector2" "v"]], :type "float", :name ":dst2"} {:args [["float" "x"] ["float" "y"]], :type "float", :name ":dst2"} {:args [["Vector2" "other"] ["float" "epsilon"]], :type "boolean", :name ":epsilon-equals"} {:args [["float" "x"] ["float" "y"] ["float" "epsilon"]], :type "boolean", :text "Compares this vector with the other vector, using the supplied epsilon for fuzzy equality testing.", :name ":epsilon-equals"} {:args [["Object" "obj"]], :type "boolean", :name ":equals"} {:args [], :type "float", :name ":get-angle-rad"} {:args [["Vector2" "vector"]], :type "boolean", :name ":has-opposite-direction"} {:args [["Vector2" "vector"]], :type "boolean", :name ":has-same-direction"} {:args [], :type "int", :name ":hash-code"} {:args [["Vector2" "target"] ["float" "alpha"] ["Interpolation" "interpolator"]], :type "Vector2", :name ":interpolate"} {:args [["Vector2" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-collinear"} {:args [["Vector2" "other"]], :type "boolean", :name ":is-collinear"} {:args [["Vector2" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-collinear-opposite"} {:args [["Vector2" "other"]], :type "boolean", :name ":is-collinear-opposite"} {:args [["Vector2" "other"]], :type "boolean", :name ":is-on-line"} {:args [["Vector2" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-on-line"} {:args [["Vector2" "vector"]], :type "boolean", :name ":is-perpendicular"} {:args [["Vector2" "vector"] ["float" "epsilon"]], :type "boolean", :name ":is-perpendicular"} {:args [], :type "boolean", :name ":is-unit"} {:args [["float" "margin"]], :type "boolean", :name ":is-unit"} {:args [], :type "boolean", :name ":is-zero"} {:args [["float" "margin"]], :type "boolean", :name ":is-zero"} {:args [], :type "float", :name ":len"} {:args [], :type "float", :name ":len2"} {:args [["Vector2" "target"] ["float" "alpha"]], :type "Vector2", :name ":lerp"} {:args [["float" "limit"]], :type "Vector2", :name ":limit"} {:args [["Matrix3" "mat"]], :type "Vector2", :text "Left-multiplies this vector by the given matrix", :name ":mul"} {:args [["Vector2" "vec"] ["float" "scalar"]], :type "Vector2", :name ":mul-add"} {:args [["Vector2" "vec"] ["Vector2" "mul-vec"]], :type "Vector2", :name ":mul-add"} {:args [], :type "Vector2", :name ":nor"} {:args [["float" "degrees"]], :type "Vector2", :text "Rotates the Vector2 by the given angle, counter-clockwise assuming the y-axis points up.", :name ":rotate"} {:args [["float" "radians"]], :type "Vector2", :text "Rotates the Vector2 by the given angle, counter-clockwise assuming the y-axis points up.", :name ":rotate-rad"} {:args [["int" "dir"]], :type "Vector2", :text "Rotates the Vector2 by 90 degrees in the specified direction, where >= 0 is counter-clockwise and < 0 is clockwise.", :name ":rotate90"} {:args [["float" "scalar"]], :type "Vector2", :name ":scl"} {:args [["float" "x"] ["float" "y"]], :type "Vector2", :text "Multiplies this vector by a scalar", :name ":scl"} {:args [["Vector2" "v"]], :type "Vector2", :name ":scl"} {:args [["Vector2" "v"]], :type "Vector2", :name ":set"} {:args [["float" "x"] ["float" "y"]], :type "Vector2", :text "Sets the components of this vector", :name ":set"} {:args [["float" "degrees"]], :type "Vector2", :text "Sets the angle of the vector in degrees relative to the x-axis, towards the positive y-axis (typically counter-clockwise).", :name ":set-angle"} {:args [["float" "radians"]], :type "Vector2", :text "Sets the angle of the vector in radians relative to the x-axis, towards the positive y-axis (typically counter-clockwise).", :name ":set-angle-rad"} {:args [["Vector2" "v"]], :type "Vector2", :name ":sub"} {:args [["float" "x"] ["float" "y"]], :type "Vector2", :text "Substracts the other vector from this vector.", :name ":sub"} {:args [], :type "String", :name ":to-string"}]}]], :name "vector-2", :type :code, :raw "(defmacro vector-2\n  [x y & options]\n  `(u/calls! ^Vector2 (vector-2* ~x ~y) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Vector2.html'>Vector2</a>. The values can be retrieved with <code>x</code> and <code>y</code>, and modified with <code>x!</code> and <code>y!</code>.</p>"} {:raw* nil, :arglists [(vector-2! object k & options)], :java [["vector-2!" {:text "Encapsulates a 2D vector. Allows chaining methods by returning a reference to itself", :items [{:args [["Vector2" "v"]], :type "Vector2", :name ":add"} {:args [["float" "x"] ["float" "y"]], :type "Vector2", :text "Adds the given components to this vector", :name ":add"} {:args [], :type "float", :name ":angle"} {:args [["float" "min"] ["float" "max"]], :type "Vector2", :name ":clamp"} {:args [], :type "Vector2", :name ":cpy"} {:args [["Vector2" "v"]], :type "float", :text "Calculates the 2D cross product between this and the given vector.", :name ":crs"} {:args [["float" "x"] ["float" "y"]], :type "float", :text "Calculates the 2D cross product between this and the given vector.", :name ":crs"} {:args [["Vector2" "v"]], :type "float", :name ":dot"} {:args [["float" "ox"] ["float" "oy"]], :type "float", :name ":dot"} {:args [["Vector2" "v"]], :type "float", :name ":dst"} {:args [["float" "x"] ["float" "y"]], :type "float", :name ":dst"} {:args [["Vector2" "v"]], :type "float", :name ":dst2"} {:args [["float" "x"] ["float" "y"]], :type "float", :name ":dst2"} {:args [["Vector2" "other"] ["float" "epsilon"]], :type "boolean", :name ":epsilon-equals"} {:args [["float" "x"] ["float" "y"] ["float" "epsilon"]], :type "boolean", :text "Compares this vector with the other vector, using the supplied epsilon for fuzzy equality testing.", :name ":epsilon-equals"} {:args [["Object" "obj"]], :type "boolean", :name ":equals"} {:args [], :type "float", :name ":get-angle-rad"} {:args [["Vector2" "vector"]], :type "boolean", :name ":has-opposite-direction"} {:args [["Vector2" "vector"]], :type "boolean", :name ":has-same-direction"} {:args [], :type "int", :name ":hash-code"} {:args [["Vector2" "target"] ["float" "alpha"] ["Interpolation" "interpolator"]], :type "Vector2", :name ":interpolate"} {:args [["Vector2" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-collinear"} {:args [["Vector2" "other"]], :type "boolean", :name ":is-collinear"} {:args [["Vector2" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-collinear-opposite"} {:args [["Vector2" "other"]], :type "boolean", :name ":is-collinear-opposite"} {:args [["Vector2" "other"]], :type "boolean", :name ":is-on-line"} {:args [["Vector2" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-on-line"} {:args [["Vector2" "vector"]], :type "boolean", :name ":is-perpendicular"} {:args [["Vector2" "vector"] ["float" "epsilon"]], :type "boolean", :name ":is-perpendicular"} {:args [], :type "boolean", :name ":is-unit"} {:args [["float" "margin"]], :type "boolean", :name ":is-unit"} {:args [], :type "boolean", :name ":is-zero"} {:args [["float" "margin"]], :type "boolean", :name ":is-zero"} {:args [], :type "float", :name ":len"} {:args [], :type "float", :name ":len2"} {:args [["Vector2" "target"] ["float" "alpha"]], :type "Vector2", :name ":lerp"} {:args [["float" "limit"]], :type "Vector2", :name ":limit"} {:args [["Matrix3" "mat"]], :type "Vector2", :text "Left-multiplies this vector by the given matrix", :name ":mul"} {:args [["Vector2" "vec"] ["float" "scalar"]], :type "Vector2", :name ":mul-add"} {:args [["Vector2" "vec"] ["Vector2" "mul-vec"]], :type "Vector2", :name ":mul-add"} {:args [], :type "Vector2", :name ":nor"} {:args [["float" "degrees"]], :type "Vector2", :text "Rotates the Vector2 by the given angle, counter-clockwise assuming the y-axis points up.", :name ":rotate"} {:args [["float" "radians"]], :type "Vector2", :text "Rotates the Vector2 by the given angle, counter-clockwise assuming the y-axis points up.", :name ":rotate-rad"} {:args [["int" "dir"]], :type "Vector2", :text "Rotates the Vector2 by 90 degrees in the specified direction, where >= 0 is counter-clockwise and < 0 is clockwise.", :name ":rotate90"} {:args [["float" "scalar"]], :type "Vector2", :name ":scl"} {:args [["float" "x"] ["float" "y"]], :type "Vector2", :text "Multiplies this vector by a scalar", :name ":scl"} {:args [["Vector2" "v"]], :type "Vector2", :name ":scl"} {:args [["Vector2" "v"]], :type "Vector2", :name ":set"} {:args [["float" "x"] ["float" "y"]], :type "Vector2", :text "Sets the components of this vector", :name ":set"} {:args [["float" "degrees"]], :type "Vector2", :text "Sets the angle of the vector in degrees relative to the x-axis, towards the positive y-axis (typically counter-clockwise).", :name ":set-angle"} {:args [["float" "radians"]], :type "Vector2", :text "Sets the angle of the vector in radians relative to the x-axis, towards the positive y-axis (typically counter-clockwise).", :name ":set-angle-rad"} {:args [["Vector2" "v"]], :type "Vector2", :name ":sub"} {:args [["float" "x"] ["float" "y"]], :type "Vector2", :text "Substracts the other vector from this vector.", :name ":sub"} {:args [], :type "String", :name ":to-string"}]}]], :name "vector-2!", :type :code, :raw "(defmacro vector-2!\n  [object k & options]\n  `(u/call! ^Vector2 ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>vector-2</code>. If you're trying to modify the values, see <code>x!</code> and <code>y!</code>.</p>"} {:raw* "(defn vector-3*\n  ([]\n    (Vector3.))\n  ([x y z]\n    (Vector3. x y z)))", :arglists [(vector-3 x y z & options)], :java [["vector-3" {:text "Encapsulates a 3D vector. Allows chaining operations by returning a reference to itself in all modification methods.", :items [{:args [["Vector3" "vector"]], :type "Vector3", :name ":add"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Vector3", :text "Adds the given vector to this component", :name ":add"} {:args [["float" "values"]], :type "Vector3", :text "Adds the given value to all three components of the vector.", :name ":add"} {:args [["float" "min"] ["float" "max"]], :type "Vector3", :name ":clamp"} {:args [], :type "Vector3", :name ":cpy"} {:args [["Vector3" "vector"]], :type "Vector3", :text "Sets this vector to the cross product between it and the other vector.", :name ":crs"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Vector3", :text "Sets this vector to the cross product between it and the other vector.", :name ":crs"} {:args [["Vector3" "vector"]], :type "float", :name ":dot"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "float", :text "Returns the dot product between this and the given vector.", :name ":dot"} {:args [["Vector3" "vector"]], :type "float", :name ":dst"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "float", :name ":dst"} {:args [["Vector3" "point"]], :type "float", :name ":dst2"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "float", :text "Returns the squared distance between this point and the given point", :name ":dst2"} {:args [["Vector3" "other"] ["float" "epsilon"]], :type "boolean", :name ":epsilon-equals"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "epsilon"]], :type "boolean", :text "Compares this vector with the other vector, using the supplied epsilon for fuzzy equality testing.", :name ":epsilon-equals"} {:args [["Object" "obj"]], :type "boolean", :name ":equals"} {:args [["Vector3" "vector"]], :type "boolean", :name ":has-opposite-direction"} {:args [["Vector3" "vector"]], :type "boolean", :name ":has-same-direction"} {:args [], :type "int", :name ":hash-code"} {:args [["Vector3" "vector"]], :type "boolean", :name ":idt"} {:args [["Vector3" "target"] ["float" "alpha"] ["Interpolation" "interpolator"]], :type "Vector3", :name ":interpolate"} {:args [["Vector3" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-collinear"} {:args [["Vector3" "other"]], :type "boolean", :name ":is-collinear"} {:args [["Vector3" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-collinear-opposite"} {:args [["Vector3" "other"]], :type "boolean", :name ":is-collinear-opposite"} {:args [["Vector3" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-on-line"} {:args [["Vector3" "other"]], :type "boolean", :name ":is-on-line"} {:args [["Vector3" "vector"]], :type "boolean", :name ":is-perpendicular"} {:args [["Vector3" "vector"] ["float" "epsilon"]], :type "boolean", :name ":is-perpendicular"} {:args [], :type "boolean", :name ":is-unit"} {:args [["float" "margin"]], :type "boolean", :name ":is-unit"} {:args [], :type "boolean", :name ":is-zero"} {:args [["float" "margin"]], :type "boolean", :name ":is-zero"} {:args [], :type "float", :name ":len"} {:args [], :type "float", :name ":len2"} {:args [["Vector3" "target"] ["float" "alpha"]], :type "Vector3", :name ":lerp"} {:args [["float" "limit"]], :type "Vector3", :name ":limit"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Left-multiplies the vector by the given matrix, assuming the fourth (w) component of the vector is 1.", :name ":mul"} {:args [["Matrix3" "matrix"]], :type "Vector3", :text "Left-multiplies the vector by the given matrix.", :name ":mul"} {:args [["Quaternion" "quat"]], :type "Vector3", :text "Multiplies the vector by the given {@link Quaternion}.", :name ":mul"} {:args [["Vector3" "vec"] ["float" "scalar"]], :type "Vector3", :name ":mul-add"} {:args [["Vector3" "vec"] ["Vector3" "mul-vec"]], :type "Vector3", :name ":mul-add"} {:args [["float[]" "matrix"]], :type "Vector3", :text "Left-multiplies the vector by the given 4x3 column major matrix. The matrix should be composed by a 3x3 matrix representing\n rotation and scale plus a 1x3 matrix representing the translation.", :name ":mul4x3"} {:args [], :type "Vector3", :name ":nor"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Multiplies this vector by the given matrix dividing by w, assuming the fourth (w) component of the vector is 1. This is\n mostly used to project/unproject vectors via a perspective projection matrix.", :name ":prj"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Multiplies this vector by the first three columns of the matrix, essentially only applying rotation and scaling.", :name ":rot"} {:args [["float" "degrees"] ["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :type "Vector3", :text "Rotates this vector by the given angle in degrees around the given axis.", :name ":rotate"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Vector3", :text "Rotates this vector by the given angle in degrees around the given axis.", :name ":rotate"} {:args [["float" "radians"] ["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :type "Vector3", :text "Rotates this vector by the given angle in radians around the given axis.", :name ":rotate-rad"} {:args [["Vector3" "axis"] ["float" "radians"]], :type "Vector3", :text "Rotates this vector by the given angle in radians around the given axis.", :name ":rotate-rad"} {:args [["float" "scalar"]], :type "Vector3", :name ":scl"} {:args [["Vector3" "other"]], :type "Vector3", :name ":scl"} {:args [["float" "vx"] ["float" "vy"] ["float" "vz"]], :type "Vector3", :text "Scales this vector by the given values", :name ":scl"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Vector3", :text "Sets the vector to the given components", :name ":set"} {:args [["Vector3" "vector"]], :type "Vector3", :name ":set"} {:args [["float[]" "values"]], :type "Vector3", :text "Sets the components from the array. The array must have at least 3 elements", :name ":set"} {:args [["Vector2" "vector"] ["float" "z"]], :type "Vector3", :text "Sets the components of the given vector and z-component", :name ":set"} {:args [["Vector3" "target"] ["float" "alpha"]], :type "Vector3", :text "Spherically interpolates between this vector and the target vector by alpha which is in the range [0,1]. The result is\n stored in this vector.", :name ":slerp"} {:args [["Vector3" "a-vec"]], :type "Vector3", :name ":sub"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Vector3", :text "Subtracts the other vector from this vector.", :name ":sub"} {:args [["float" "value"]], :type "Vector3", :text "Subtracts the given value from all components of this vector", :name ":sub"} {:args [], :type "String", :name ":to-string"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Multiplies the vector by the transpose of the given matrix, assuming the fourth (w) component of the vector is 1.", :name ":tra-mul"} {:args [["Matrix3" "matrix"]], :type "Vector3", :text "Multiplies the vector by the transpose of the given matrix.", :name ":tra-mul"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Multiplies this vector by the transpose of the first three columns of the matrix. Note: only works for translation and\n rotation, does not work for scaling. For those, use {@link #rot(Matrix4)} with {@link Matrix4#inv()}.", :name ":unrotate"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Translates this vector in the direction opposite to the translation of the matrix and the multiplies this vector by the\n transpose of the first three columns of the matrix. Note: only works for translation and rotation, does not work for\n scaling. For those, use {@link #mul(Matrix4)} with {@link Matrix4#inv()}.", :name ":untransform"}]}]], :name "vector-3", :type :code, :raw "(defmacro vector-3\n  [x y z & options]\n  `(u/calls! ^Vector3 (vector-3* ~x ~y ~z) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/Vector3.html'>Vector3</a>. The values can be retrieved with <code>x</code>, <code>y</code> and <code>z</code>, and modified with <code>x!</code>, <code>y!</code>, and <code>z!</code>.</p>"} {:raw* nil, :arglists [(vector-3! object k & options)], :java [["vector-3!" {:text "Encapsulates a 3D vector. Allows chaining operations by returning a reference to itself in all modification methods.", :items [{:args [["Vector3" "vector"]], :type "Vector3", :name ":add"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Vector3", :text "Adds the given vector to this component", :name ":add"} {:args [["float" "values"]], :type "Vector3", :text "Adds the given value to all three components of the vector.", :name ":add"} {:args [["float" "min"] ["float" "max"]], :type "Vector3", :name ":clamp"} {:args [], :type "Vector3", :name ":cpy"} {:args [["Vector3" "vector"]], :type "Vector3", :text "Sets this vector to the cross product between it and the other vector.", :name ":crs"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Vector3", :text "Sets this vector to the cross product between it and the other vector.", :name ":crs"} {:args [["Vector3" "vector"]], :type "float", :name ":dot"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "float", :text "Returns the dot product between this and the given vector.", :name ":dot"} {:args [["Vector3" "vector"]], :type "float", :name ":dst"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "float", :name ":dst"} {:args [["Vector3" "point"]], :type "float", :name ":dst2"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "float", :text "Returns the squared distance between this point and the given point", :name ":dst2"} {:args [["Vector3" "other"] ["float" "epsilon"]], :type "boolean", :name ":epsilon-equals"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "epsilon"]], :type "boolean", :text "Compares this vector with the other vector, using the supplied epsilon for fuzzy equality testing.", :name ":epsilon-equals"} {:args [["Object" "obj"]], :type "boolean", :name ":equals"} {:args [["Vector3" "vector"]], :type "boolean", :name ":has-opposite-direction"} {:args [["Vector3" "vector"]], :type "boolean", :name ":has-same-direction"} {:args [], :type "int", :name ":hash-code"} {:args [["Vector3" "vector"]], :type "boolean", :name ":idt"} {:args [["Vector3" "target"] ["float" "alpha"] ["Interpolation" "interpolator"]], :type "Vector3", :name ":interpolate"} {:args [["Vector3" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-collinear"} {:args [["Vector3" "other"]], :type "boolean", :name ":is-collinear"} {:args [["Vector3" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-collinear-opposite"} {:args [["Vector3" "other"]], :type "boolean", :name ":is-collinear-opposite"} {:args [["Vector3" "other"] ["float" "epsilon"]], :type "boolean", :name ":is-on-line"} {:args [["Vector3" "other"]], :type "boolean", :name ":is-on-line"} {:args [["Vector3" "vector"]], :type "boolean", :name ":is-perpendicular"} {:args [["Vector3" "vector"] ["float" "epsilon"]], :type "boolean", :name ":is-perpendicular"} {:args [], :type "boolean", :name ":is-unit"} {:args [["float" "margin"]], :type "boolean", :name ":is-unit"} {:args [], :type "boolean", :name ":is-zero"} {:args [["float" "margin"]], :type "boolean", :name ":is-zero"} {:args [], :type "float", :name ":len"} {:args [], :type "float", :name ":len2"} {:args [["Vector3" "target"] ["float" "alpha"]], :type "Vector3", :name ":lerp"} {:args [["float" "limit"]], :type "Vector3", :name ":limit"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Left-multiplies the vector by the given matrix, assuming the fourth (w) component of the vector is 1.", :name ":mul"} {:args [["Matrix3" "matrix"]], :type "Vector3", :text "Left-multiplies the vector by the given matrix.", :name ":mul"} {:args [["Quaternion" "quat"]], :type "Vector3", :text "Multiplies the vector by the given {@link Quaternion}.", :name ":mul"} {:args [["Vector3" "vec"] ["float" "scalar"]], :type "Vector3", :name ":mul-add"} {:args [["Vector3" "vec"] ["Vector3" "mul-vec"]], :type "Vector3", :name ":mul-add"} {:args [["float[]" "matrix"]], :type "Vector3", :text "Left-multiplies the vector by the given 4x3 column major matrix. The matrix should be composed by a 3x3 matrix representing\n rotation and scale plus a 1x3 matrix representing the translation.", :name ":mul4x3"} {:args [], :type "Vector3", :name ":nor"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Multiplies this vector by the given matrix dividing by w, assuming the fourth (w) component of the vector is 1. This is\n mostly used to project/unproject vectors via a perspective projection matrix.", :name ":prj"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Multiplies this vector by the first three columns of the matrix, essentially only applying rotation and scaling.", :name ":rot"} {:args [["float" "degrees"] ["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :type "Vector3", :text "Rotates this vector by the given angle in degrees around the given axis.", :name ":rotate"} {:args [["Vector3" "axis"] ["float" "degrees"]], :type "Vector3", :text "Rotates this vector by the given angle in degrees around the given axis.", :name ":rotate"} {:args [["float" "radians"] ["float" "axis-x"] ["float" "axis-y"] ["float" "axis-z"]], :type "Vector3", :text "Rotates this vector by the given angle in radians around the given axis.", :name ":rotate-rad"} {:args [["Vector3" "axis"] ["float" "radians"]], :type "Vector3", :text "Rotates this vector by the given angle in radians around the given axis.", :name ":rotate-rad"} {:args [["float" "scalar"]], :type "Vector3", :name ":scl"} {:args [["Vector3" "other"]], :type "Vector3", :name ":scl"} {:args [["float" "vx"] ["float" "vy"] ["float" "vz"]], :type "Vector3", :text "Scales this vector by the given values", :name ":scl"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Vector3", :text "Sets the vector to the given components", :name ":set"} {:args [["Vector3" "vector"]], :type "Vector3", :name ":set"} {:args [["float[]" "values"]], :type "Vector3", :text "Sets the components from the array. The array must have at least 3 elements", :name ":set"} {:args [["Vector2" "vector"] ["float" "z"]], :type "Vector3", :text "Sets the components of the given vector and z-component", :name ":set"} {:args [["Vector3" "target"] ["float" "alpha"]], :type "Vector3", :text "Spherically interpolates between this vector and the target vector by alpha which is in the range [0,1]. The result is\n stored in this vector.", :name ":slerp"} {:args [["Vector3" "a-vec"]], :type "Vector3", :name ":sub"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "Vector3", :text "Subtracts the other vector from this vector.", :name ":sub"} {:args [["float" "value"]], :type "Vector3", :text "Subtracts the given value from all components of this vector", :name ":sub"} {:args [], :type "String", :name ":to-string"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Multiplies the vector by the transpose of the given matrix, assuming the fourth (w) component of the vector is 1.", :name ":tra-mul"} {:args [["Matrix3" "matrix"]], :type "Vector3", :text "Multiplies the vector by the transpose of the given matrix.", :name ":tra-mul"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Multiplies this vector by the transpose of the first three columns of the matrix. Note: only works for translation and\n rotation, does not work for scaling. For those, use {@link #rot(Matrix4)} with {@link Matrix4#inv()}.", :name ":unrotate"} {:args [["Matrix4" "matrix"]], :type "Vector3", :text "Translates this vector in the direction opposite to the translation of the matrix and the multiplies this vector by the\n transpose of the first three columns of the matrix. Note: only works for translation and rotation, does not work for\n scaling. For those, use {@link #mul(Matrix4)} with {@link Matrix4#inv()}.", :name ":untransform"}]}]], :name "vector-3!", :type :code, :raw "(defmacro vector-3!\n  [object k & options]\n  `(u/call! ^Vector3 ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>vector-3</code>. If you're trying to modify the values, see <code>x!</code>, <code>y!</code>, and <code>z!</code>.</p>"} {:raw* "(defn windowed-mean*\n  [window-size]\n  (WindowedMean. window-size))", :arglists [(windowed-mean window-size & options)], :java [["windowed-mean" {:text "A simple class keeping track of the mean of a stream of values within a certain window. the WindowedMean will only return a\n value in case enough data has been sampled. After enough data has been sampled the oldest sample will be replaced by the newest\n in case a new sample is added.", :items [{:args [["float" "value"]], :text "adds a new sample to this mean. In case the window is full the oldest value will be replaced by this new value.", :name ":add-value"} {:args [], :text "clears this WindowedMean. The class will only return meaningful values after enough data has been added again.", :name ":clear"} {:args [], :type "float", :name ":get-latest"} {:args [], :type "float", :text "returns the mean of the samples added to this instance. Only returns meaningful results when at least window_size samples\n as specified in the constructor have been added.", :name ":get-mean"} {:args [], :type "float", :name ":get-oldest"} {:args [], :type "boolean", :name ":has-enough-data"} {:args [], :type "float", :name ":standard-deviation"}]}]], :name "windowed-mean", :type :code, :raw "(defmacro windowed-mean\n  [window-size & options]\n  `(u/calls! ^WindowedMean (windowed-mean* ~window-size) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/WindowedMean.html'>WindowedMean</a>.</p>"} {:raw* nil, :arglists [(windowed-mean! object k & options)], :java [["windowed-mean!" {:text "A simple class keeping track of the mean of a stream of values within a certain window. the WindowedMean will only return a\n value in case enough data has been sampled. After enough data has been sampled the oldest sample will be replaced by the newest\n in case a new sample is added.", :items [{:args [["float" "value"]], :text "adds a new sample to this mean. In case the window is full the oldest value will be replaced by this new value.", :name ":add-value"} {:args [], :text "clears this WindowedMean. The class will only return meaningful values after enough data has been added again.", :name ":clear"} {:args [], :type "float", :name ":get-latest"} {:args [], :type "float", :text "returns the mean of the samples added to this instance. Only returns meaningful results when at least window_size samples\n as specified in the constructor have been added.", :name ":get-mean"} {:args [], :type "float", :name ":get-oldest"} {:args [], :type "boolean", :name ":has-enough-data"} {:args [], :type "float", :name ":standard-deviation"}]}]], :name "windowed-mean!", :type :code, :raw "(defmacro windowed-mean!\n  [object k & options]\n  `(u/call! ^WindowedMean ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>windowed-mean</code>.</p>"} {:raw* "(defn bounding-box*\n  ([]\n    (BoundingBox.))\n  ([box]\n    (BoundingBox. box))\n  ([min max]\n    (BoundingBox. min max)))", :arglists [(bounding-box min max & options)], :java [["bounding-box" {:text "Encapsulates an axis aligned bounding box represented by a minimum and a maximum Vector. Additionally you can query for the\n bounding box's center, dimensions and corner points.", :items [{:args [], :type "BoundingBox", :text "Sets the minimum and maximum vector to zeros", :name ":clr"} {:args [["BoundingBox" "b"]], :type "boolean", :text "Returns whether the given bounding box is contained in this bounding box.", :name ":contains"} {:args [["Vector3" "v"]], :type "boolean", :text "Returns whether the given vector is contained in this bounding box.", :name ":contains"} {:args [["Vector3" "point"]], :type "BoundingBox", :text "Extends the bounding box to incorporate the given {@link Vector3}.", :name ":ext"} {:args [["BoundingBox" "a-bounds"]], :type "BoundingBox", :text "Extends this bounding box by the given bounding box.", :name ":ext"} {:args [["BoundingBox" "bounds"] ["Matrix4" "transform"]], :type "BoundingBox", :text "Extends this bounding box by the given transformed bounding box.", :name ":ext"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "BoundingBox", :text "Extends the bounding box by the given vector.", :name ":ext"} {:args [], :type "Vector3", :name ":get-center"} {:args [], :type "Vector3", :name ":get-corners"} {:args [], :type "Vector3", :name ":get-dimensions"} {:args [], :type "Vector3", :name ":get-max"} {:args [], :type "Vector3", :name ":get-min"} {:args [], :type "BoundingBox", :text "Sets the minimum and maximum vector to positive and negative infinity.", :name ":inf"} {:args [["BoundingBox" "b"]], :type "boolean", :text "Returns whether the given bounding box is intersecting this bounding box (at least one point in).", :name ":intersects"} {:args [], :type "boolean", :text "Returns whether this bounding box is valid. This means that min != max and min < max.", :name ":is-valid"} {:args [["Matrix4" "matrix"]], :type "BoundingBox", :text "Multiplies the bounding box by the given matrix. This is achieved by multiplying the 8 corner points and then calculating\n the minimum and maximum vectors from the transformed points.", :name ":mul"} {:args [["BoundingBox" "bounds"]], :type "BoundingBox", :text "Sets the given bounding box.", :name ":set"} {:args [["Vector3" "minimum"] ["Vector3" "maximum"]], :type "BoundingBox", :text "Sets the given minimum and maximum vector.", :name ":set"} {:args [["com.badlogic.gdx.math.Vector3[]" "points"]], :type "BoundingBox", :text "Sets the bounding box minimum and maximum vector from the given points.", :name ":set"} {:args [["java.util.List" "points"]], :type "BoundingBox", :text "Sets the bounding box minimum and maximum vector from the given points.", :name ":set"} {:args [], :type "String", :name ":to-string"}]}]], :name "bounding-box", :type :code, :raw "(defmacro bounding-box\n  [min max & options]\n  `(u/calls! ^BoundingBox (bounding-box* ~min ~max) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/collision/BoundingBox.html'>BoundingBox</a>.</p>"} {:raw* nil, :arglists [(bounding-box! object k & options)], :java [["bounding-box!" {:text "Encapsulates an axis aligned bounding box represented by a minimum and a maximum Vector. Additionally you can query for the\n bounding box's center, dimensions and corner points.", :items [{:args [], :type "BoundingBox", :text "Sets the minimum and maximum vector to zeros", :name ":clr"} {:args [["BoundingBox" "b"]], :type "boolean", :text "Returns whether the given bounding box is contained in this bounding box.", :name ":contains"} {:args [["Vector3" "v"]], :type "boolean", :text "Returns whether the given vector is contained in this bounding box.", :name ":contains"} {:args [["Vector3" "point"]], :type "BoundingBox", :text "Extends the bounding box to incorporate the given {@link Vector3}.", :name ":ext"} {:args [["BoundingBox" "a-bounds"]], :type "BoundingBox", :text "Extends this bounding box by the given bounding box.", :name ":ext"} {:args [["BoundingBox" "bounds"] ["Matrix4" "transform"]], :type "BoundingBox", :text "Extends this bounding box by the given transformed bounding box.", :name ":ext"} {:args [["float" "x"] ["float" "y"] ["float" "z"]], :type "BoundingBox", :text "Extends the bounding box by the given vector.", :name ":ext"} {:args [], :type "Vector3", :name ":get-center"} {:args [], :type "Vector3", :name ":get-corners"} {:args [], :type "Vector3", :name ":get-dimensions"} {:args [], :type "Vector3", :name ":get-max"} {:args [], :type "Vector3", :name ":get-min"} {:args [], :type "BoundingBox", :text "Sets the minimum and maximum vector to positive and negative infinity.", :name ":inf"} {:args [["BoundingBox" "b"]], :type "boolean", :text "Returns whether the given bounding box is intersecting this bounding box (at least one point in).", :name ":intersects"} {:args [], :type "boolean", :text "Returns whether this bounding box is valid. This means that min != max and min < max.", :name ":is-valid"} {:args [["Matrix4" "matrix"]], :type "BoundingBox", :text "Multiplies the bounding box by the given matrix. This is achieved by multiplying the 8 corner points and then calculating\n the minimum and maximum vectors from the transformed points.", :name ":mul"} {:args [["BoundingBox" "bounds"]], :type "BoundingBox", :text "Sets the given bounding box.", :name ":set"} {:args [["Vector3" "minimum"] ["Vector3" "maximum"]], :type "BoundingBox", :text "Sets the given minimum and maximum vector.", :name ":set"} {:args [["com.badlogic.gdx.math.Vector3[]" "points"]], :type "BoundingBox", :text "Sets the bounding box minimum and maximum vector from the given points.", :name ":set"} {:args [["java.util.List" "points"]], :type "BoundingBox", :text "Sets the bounding box minimum and maximum vector from the given points.", :name ":set"} {:args [], :type "String", :name ":to-string"}]}]], :name "bounding-box!", :type :code, :raw "(defmacro bounding-box!\n  [object k & options]\n  `(u/call! ^BoundingBox ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>bounding-box</code>.</p>"} {:raw* "(defn ray*\n  [origin direction]\n  (Ray. origin direction))", :arglists [(ray origin direction & options)], :java [["ray" {:text "Encapsulates a ray having a starting position and a unit length direction.", :items [{:args [], :type "Ray", :name ":cpy"} {:args [["float" "distance"]], :type "Vector3", :name ":get-end-point"} {:args [["Vector3" "out"] ["float" "distance"]], :type "Vector3", :text "Returns the endpoint given the distance. This is calculated as startpoint + distance * direction.", :name ":get-end-point"} {:args [["Matrix4" "matrix"]], :type "Ray", :text "Multiplies the ray by the given matrix. Use this to transform a ray into another coordinate system.", :name ":mul"} {:args [["Vector3" "origin"] ["Vector3" "direction"]], :type "Ray", :text "Sets the starting position and the direction of this ray.", :name ":set"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "dx"] ["float" "dy"] ["float" "dz"]], :type "Ray", :text "Sets this ray from the given starting position and direction.", :name ":set"} {:args [["Ray" "ray"]], :type "Ray", :text "Sets the starting position and direction from the given ray", :name ":set"} {:args [], :type "String", :text "{@inheritDoc}", :name ":to-string"}]}]], :name "ray", :type :code, :raw "(defmacro ray\n  [origin direction & options]\n  `(u/calls! ^Ray (ray* ~origin ~direction) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/collision/Ray.html'>Ray</a>.</p>"} {:raw* nil, :arglists [(ray! object k & options)], :java [["ray!" {:text "Encapsulates a ray having a starting position and a unit length direction.", :items [{:args [], :type "Ray", :name ":cpy"} {:args [["float" "distance"]], :type "Vector3", :name ":get-end-point"} {:args [["Vector3" "out"] ["float" "distance"]], :type "Vector3", :text "Returns the endpoint given the distance. This is calculated as startpoint + distance * direction.", :name ":get-end-point"} {:args [["Matrix4" "matrix"]], :type "Ray", :text "Multiplies the ray by the given matrix. Use this to transform a ray into another coordinate system.", :name ":mul"} {:args [["Vector3" "origin"] ["Vector3" "direction"]], :type "Ray", :text "Sets the starting position and the direction of this ray.", :name ":set"} {:args [["float" "x"] ["float" "y"] ["float" "z"] ["float" "dx"] ["float" "dy"] ["float" "dz"]], :type "Ray", :text "Sets this ray from the given starting position and direction.", :name ":set"} {:args [["Ray" "ray"]], :type "Ray", :text "Sets the starting position and direction from the given ray", :name ":set"} {:args [], :type "String", :text "{@inheritDoc}", :name ":to-string"}]}]], :name "ray!", :type :code, :raw "(defmacro ray!\n  [object k & options]\n  `(u/call! ^Ray ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>ray</code>.</p>"} {:raw* "(defn segment*\n  ([a-x a-y a-z b-x b-y b-z]\n    (Segment. a-x a-y a-z b-x b-y b-z))\n  ([a b]\n    (Segment. a b)))", :arglists [(segment a b & options)], :java [["segment" {:text "A Segment is a line in 3-space having a staring and an ending position.", :items []}]], :name "segment", :type :code, :raw "(defmacro segment\n  [a b & options]\n  `(u/calls! ^Segment (segment* ~a ~b) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/collision/Segment.html'>Segment</a>.</p>"} {:raw* nil, :arglists [(segment! object k & options)], :java [["segment!" {:text "A Segment is a line in 3-space having a staring and an ending position.", :items []}]], :name "segment!", :type :code, :raw "(defmacro segment!\n  [object k & options]\n  `(u/call! ^Segment ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>segment</code>.</p>"} {:raw* "(defn sphere*\n  [center radius]\n  (Sphere. center radius))", :arglists [(sphere center radius & options)], :java [["sphere" {:text "Encapsulates a 3D sphere with a center and a radius", :items [{:args [["Sphere" "sphere"]], :type "boolean", :name ":overlaps"}]}]], :name "sphere", :type :code, :raw "(defmacro sphere\n  [center radius & options]\n  `(u/calls! ^Sphere (sphere* ~center ~radius) ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/math/collision/Sphere.html'>Sphere</a>.</p>"} {:raw* nil, :arglists [(sphere! object k & options)], :java [["sphere!" {:text "Encapsulates a 3D sphere with a center and a radius", :items [{:args [["Sphere" "sphere"]], :type "boolean", :name ":overlaps"}]}]], :name "sphere!", :type :code, :raw "(defmacro sphere!\n  [object k & options]\n  `(u/call! ^Sphere ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>sphere</code>.</p>"})} {:ns "play-clj.ui", :groups ({:raw* nil, :arglists [(drawable k & options)], :java [["drawable" {:text "Drawable for a {@link Sprite}.", :items [{:args [], :name ":sprite"} {:args [["Drawable" "drawable"]], :text "Creates a new empty drawable with the same sizing information as the specified drawable.", :name ":sprite"} {:args [], :text "Creates an uninitialized SpriteDrawable. The sprite must be set before use.", :name ":sprite"} {:args [["Sprite" "sprite"]], :name ":sprite"} {:args [["SpriteDrawable" "drawable"]], :name ":sprite"}]}] ["drawable" {:text "Drawable for a {@link TextureRegion}.", :items [{:args [], :name ":texture-region"} {:args [["Drawable" "drawable"]], :text "Creates a new empty drawable with the same sizing information as the specified drawable.", :name ":texture-region"} {:args [], :text "Creates an uninitialized TextureRegionDrawable. The texture region must be set before use.", :name ":texture-region"} {:args [["TextureRegion" "region"]], :name ":texture-region"} {:args [["TextureRegionDrawable" "drawable"]], :name ":texture-region"}]}] ["drawable" {:text "Drawable for a {@link NinePatch}.\n <p>\n The drawable sizes are set when the ninepatch is set, but they are separate values. Eg, {@link Drawable#getLeftWidth()} could\n be set to more than {@link NinePatch#getLeftWidth()} in order to provide more space on the left than actually exists in the\n ninepatch.\n <p>\n The min size is set to the ninepatch total size by default. It could be set to the left+right and top+bottom, excluding the\n middle size, to allow the drawable to be sized down as small as possible.", :items [{:args [], :name ":nine-patch"} {:args [["Drawable" "drawable"]], :text "Creates a new empty drawable with the same sizing information as the specified drawable.", :name ":nine-patch"} {:args [], :text "Creates an uninitialized NinePatchDrawable. The ninepatch must be {@link #setPatch(NinePatch) set} before use.", :name ":nine-patch"} {:args [["NinePatch" "patch"]], :name ":nine-patch"} {:args [["NinePatchDrawable" "drawable"]], :name ":nine-patch"}]}]], :name "drawable", :type :code, :raw "(defmacro drawable\n  [k & options]\n  `(~(u/gdx :scenes :scene2d :utils\n            (str (u/key->pascal k) \"Drawable.\"))\n     ~@options))", :docstring "<p>Returns a subclass of <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/BaseDrawable.html'>BaseDrawable</a>.</p><pre>\n&#40;drawable :texture-region&#41;\n</pre>"} {:raw* nil, :arglists [(style k & options)], :java [["style" {:text "The style for a scroll pane, see {@link ScrollPane}.", :items [{:args [], :name ":scroll-pane"} {:args [["Drawable" "background"] ["Drawable" "h-scroll"] ["Drawable" "h-scroll-knob"] ["Drawable" "v-scroll"] ["Drawable" "v-scroll-knob"]], :name ":scroll-pane"} {:args [["ScrollPane.ScrollPaneStyle" "style"]], :name ":scroll-pane"}]}] ["style" {:text "The style for a window, see {@link Window}.", :items [{:args [], :name ":window"} {:args [["BitmapFont" "title-font"] ["Color" "title-font-color"] ["Drawable" "background"]], :name ":window"} {:args [["Window.WindowStyle" "style"]], :name ":window"}]}] ["style" {:text "The style for a progress bar, see {@link ProgressBar}.", :items [{:args [], :name ":progress-bar"} {:args [["Drawable" "background"] ["Drawable" "knob"]], :name ":progress-bar"} {:args [["ProgressBar.ProgressBarStyle" "style"]], :name ":progress-bar"}]}] ["style" {:text "The style for a text button, see {@link TextButton}.", :items [{:args [], :name ":text-button"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"]], :name ":text-button"} {:args [["Button.ButtonStyle" "style"]], :name ":text-button"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"] ["BitmapFont" "font"]], :name ":text-button"} {:args [["TextButton.TextButtonStyle" "style"]], :name ":text-button"}]}] ["style" {:text "The style for an image text button, see {@link ImageTextButton}.", :items [{:args [], :name ":image-text-button"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"]], :name ":image-text-button"} {:args [["Button.ButtonStyle" "style"]], :name ":image-text-button"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"] ["BitmapFont" "font"]], :name ":image-text-button"} {:args [["TextButton.TextButtonStyle" "style"]], :name ":image-text-button"} {:args [["ImageTextButton.ImageTextButtonStyle" "style"]], :name ":image-text-button"}]}] ["style" {:text "The style for a {@link Touchpad}.", :items [{:args [], :name ":touchpad"} {:args [["Drawable" "background"] ["Drawable" "knob"]], :name ":touchpad"} {:args [["Touchpad.TouchpadStyle" "style"]], :name ":touchpad"}]}] ["style" {:text "The style for a splitpane, see {@link SplitPane}.", :items [{:args [], :name ":split-pane"} {:args [["Drawable" "handle"]], :name ":split-pane"} {:args [["SplitPane.SplitPaneStyle" "style"]], :name ":split-pane"}]}] ["style" {:text "The style for a text field, see {@link TextField}.", :items [{:args [], :name ":text-field"} {:args [["BitmapFont" "font"] ["Color" "font-color"] ["Drawable" "cursor"] ["Drawable" "selection"] ["Drawable" "background"]], :name ":text-field"} {:args [["TextField.TextFieldStyle" "style"]], :name ":text-field"}]}] ["style" {:text "The style for a button, see {@link Button}.", :items [{:args [], :name ":button"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"]], :name ":button"} {:args [["Button.ButtonStyle" "style"]], :name ":button"}]}] ["style" {:text "The style for a select box, see {@link CheckBox}.", :items [{:args [], :name ":check-box"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"]], :name ":check-box"} {:args [["Button.ButtonStyle" "style"]], :name ":check-box"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"] ["BitmapFont" "font"]], :name ":check-box"} {:args [["TextButton.TextButtonStyle" "style"]], :name ":check-box"} {:args [["Drawable" "checkbox-off"] ["Drawable" "checkbox-on"] ["BitmapFont" "font"] ["Color" "font-color"]], :name ":check-box"} {:args [["CheckBox.CheckBoxStyle" "style"]], :name ":check-box"}]}] ["style" {:text "The style for a select box, see {@link SelectBox}.", :items [{:args [], :name ":select-box"} {:args [["BitmapFont" "font"] ["Color" "font-color"] ["Drawable" "background"] ["ScrollPane.ScrollPaneStyle" "scroll-style"] ["List.ListStyle" "list-style"]], :name ":select-box"} {:args [["SelectBox.SelectBoxStyle" "style"]], :name ":select-box"}]}] ["style" {:text "The style for a {@link Tree}.", :items [{:args [], :name ":tree"} {:args [["Drawable" "plus"] ["Drawable" "minus"] ["Drawable" "selection"]], :name ":tree"} {:args [["Tree.TreeStyle" "style"]], :name ":tree"}]}] ["style" {:text "The style for an image button, see {@link ImageButton}.", :items [{:args [], :name ":image-button"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"]], :name ":image-button"} {:args [["Button.ButtonStyle" "style"]], :name ":image-button"} {:args [["Drawable" "up"] ["Drawable" "down"] ["Drawable" "checked"] ["Drawable" "image-up"] ["Drawable" "image-down"] ["Drawable" "image-checked"]], :name ":image-button"} {:args [["ImageButton.ImageButtonStyle" "style"]], :name ":image-button"}]}]], :name "style", :type :code, :raw "(defmacro style\n  [k & options]\n  `(~(u/gdx-class :scenes :scene2d :ui\n                  (u/key->pascal k)\n                  (str (u/key->pascal k) \"Style.\"))\n     ~@options))", :docstring "<p>Returns a style object whose class is determined by the keyword <code>k</code>.</p><pre>\n&#40;style :check-box&#41;\n</pre>"} {:raw* nil, :arglists [(skin path & options)], :java [["skin" {:text "A skin stores resources for UI widgets to use (texture regions, ninepatches, fonts, colors, etc). Resources are named and can\n be looked up by name and type. Resources can be described in JSON. Skin provides useful conversions, such as allowing access to\n regions in the atlas as ninepatches, sprites, drawables, etc. The get* methods return an instance of the object in the skin.\n The new* methods return a copy of an instance in the skin.\n <p>\n See the <a href=\"https://code.google.com/p/libgdx/wiki/Skin\">documentation</a> for more.", :items [{:args [["String" "name"] ["Object" "resource"]], :name ":add"} {:args [["String" "name"] ["Object" "resource"] ["java.lang.Class" "type"]], :name ":add"} {:args [["TextureAtlas" "atlas"]], :text "Adds all named texture regions from the atlas. The atlas will not be automatically disposed when the skin is disposed.", :name ":add-regions"} {:args [], :text "Disposes the {@link TextureAtlas} and all {@link Disposable} resources in the skin.", :name ":dispose"} {:args [["Object" "resource"]], :type "String", :text "Returns the name of the specified style object, or null if it is not in the skin. This compares potentially every style\n object in the skin of the same type as the specified style, which may be a somewhat expensive operation.", :name ":find"} {:args [["java.lang.Class" "type"]], :type "Object", :name ":get"} {:args [["String" "name"] ["java.lang.Class" "type"]], :type "Object", :name ":get"} {:args [["java.lang.Class" "type"]], :type "ObjectMap", :text "Returns the name to resource mapping for the specified type, or null if no resources of that type exist.", :name ":get-all"} {:args [], :type "TextureAtlas", :text "Returns the {@link TextureAtlas} that resources in this skin reference, or null.", :name ":get-atlas"} {:args [["String" "name"]], :type "Color", :name ":get-color"} {:args [["String" "name"]], :type "Drawable", :text "Returns a registered drawable. If no drawable is found but a region, ninepatch, or sprite exists with the name, then the\n appropriate drawable is created and stored in the skin.", :name ":get-drawable"} {:args [["String" "name"]], :type "BitmapFont", :name ":get-font"} {:args [["String" "name"]], :type "NinePatch", :text "Returns a registered ninepatch. If no ninepatch is found but a region exists with the name, a ninepatch is created from the\n region and stored in the skin. If the region is an {@link AtlasRegion} then the {@link AtlasRegion#splits} are used,\n otherwise the ninepatch will have the region as the center patch.", :name ":get-patch"} {:args [["String" "name"]], :type "TextureRegion", :text "Returns a registered texture region. If no region is found but a texture exists with the name, a region is created from the\n texture and stored in the skin.", :name ":get-region"} {:args [["String" "name"]], :type "Sprite", :text "Returns a registered sprite. If no sprite is found but a region exists with the name, a sprite is created from the region\n and stored in the skin. If the region is an {@link AtlasRegion} then an {@link AtlasSprite} is used if the region has been\n whitespace stripped or packed rotated 90 degrees.", :name ":get-sprite"} {:args [["String" "name"]], :type "TiledDrawable", :text "Returns a registered tiled drawable. If no tiled drawable is found but a region exists with the name, a tiled drawable is\n created from the region and stored in the skin.", :name ":get-tiled-drawable"} {:args [["String" "name"] ["java.lang.Class" "type"]], :type "boolean", :name ":has"} {:args [["FileHandle" "skin-file"]], :text "Adds all resources in the specified skin JSON file.", :name ":load"} {:args [["String" "name"]], :type "Drawable", :text "Returns a copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["String" "name"] ["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "Drawable", :text "Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["String" "name"] ["Color" "tint"]], :type "Drawable", :text "Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["Drawable" "drawable"]], :type "Drawable", :text "Returns a copy of the specified drawable.", :name ":new-drawable"} {:args [["Drawable" "drawable"] ["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "Drawable", :text "Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["Drawable" "drawable"] ["Color" "tint"]], :type "Drawable", :text "Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["String" "name"] ["java.lang.Class" "type"]], :type "Object", :name ":optional"} {:args [["String" "name"] ["java.lang.Class" "type"]], :name ":remove"} {:args [["Actor" "actor"] ["boolean" "enabled"]], :text "Sets the style on the actor to disabled or enabled. This is done by appending \"-disabled\" to the style name when enabled is\n false, and removing \"-disabled\" from the style name when enabled is true. A method named \"getStyle\" is called the actor via\n reflection and the name of that style is found in the skin. If the actor doesn't have a \"getStyle\" method or the style was\n not found in the skin, no exception is thrown and the actor is left unchanged.", :name ":set-enabled"}]}]], :name "skin", :type :code, :raw "(defmacro skin\n  [path & options]\n  `(u/calls! ^Skin (Skin. (if (string? ~path)\n                            (.internal ^Files (Gdx/files) ~path)\n                            ~path))\n             ~@options))", :docstring "<p>Returns a <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Skin.html'>Skin</a> based on the file at <code>path</code>.</p><pre>\n&#40;skin &quot;uiskin.json&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(skin! object k & options)], :java [["skin!" {:text "A skin stores resources for UI widgets to use (texture regions, ninepatches, fonts, colors, etc). Resources are named and can\n be looked up by name and type. Resources can be described in JSON. Skin provides useful conversions, such as allowing access to\n regions in the atlas as ninepatches, sprites, drawables, etc. The get* methods return an instance of the object in the skin.\n The new* methods return a copy of an instance in the skin.\n <p>\n See the <a href=\"https://code.google.com/p/libgdx/wiki/Skin\">documentation</a> for more.", :items [{:args [["String" "name"] ["Object" "resource"]], :name ":add"} {:args [["String" "name"] ["Object" "resource"] ["java.lang.Class" "type"]], :name ":add"} {:args [["TextureAtlas" "atlas"]], :text "Adds all named texture regions from the atlas. The atlas will not be automatically disposed when the skin is disposed.", :name ":add-regions"} {:args [], :text "Disposes the {@link TextureAtlas} and all {@link Disposable} resources in the skin.", :name ":dispose"} {:args [["Object" "resource"]], :type "String", :text "Returns the name of the specified style object, or null if it is not in the skin. This compares potentially every style\n object in the skin of the same type as the specified style, which may be a somewhat expensive operation.", :name ":find"} {:args [["java.lang.Class" "type"]], :type "Object", :name ":get"} {:args [["String" "name"] ["java.lang.Class" "type"]], :type "Object", :name ":get"} {:args [["java.lang.Class" "type"]], :type "ObjectMap", :text "Returns the name to resource mapping for the specified type, or null if no resources of that type exist.", :name ":get-all"} {:args [], :type "TextureAtlas", :text "Returns the {@link TextureAtlas} that resources in this skin reference, or null.", :name ":get-atlas"} {:args [["String" "name"]], :type "Color", :name ":get-color"} {:args [["String" "name"]], :type "Drawable", :text "Returns a registered drawable. If no drawable is found but a region, ninepatch, or sprite exists with the name, then the\n appropriate drawable is created and stored in the skin.", :name ":get-drawable"} {:args [["String" "name"]], :type "BitmapFont", :name ":get-font"} {:args [["String" "name"]], :type "NinePatch", :text "Returns a registered ninepatch. If no ninepatch is found but a region exists with the name, a ninepatch is created from the\n region and stored in the skin. If the region is an {@link AtlasRegion} then the {@link AtlasRegion#splits} are used,\n otherwise the ninepatch will have the region as the center patch.", :name ":get-patch"} {:args [["String" "name"]], :type "TextureRegion", :text "Returns a registered texture region. If no region is found but a texture exists with the name, a region is created from the\n texture and stored in the skin.", :name ":get-region"} {:args [["String" "name"]], :type "Sprite", :text "Returns a registered sprite. If no sprite is found but a region exists with the name, a sprite is created from the region\n and stored in the skin. If the region is an {@link AtlasRegion} then an {@link AtlasSprite} is used if the region has been\n whitespace stripped or packed rotated 90 degrees.", :name ":get-sprite"} {:args [["String" "name"]], :type "TiledDrawable", :text "Returns a registered tiled drawable. If no tiled drawable is found but a region exists with the name, a tiled drawable is\n created from the region and stored in the skin.", :name ":get-tiled-drawable"} {:args [["String" "name"] ["java.lang.Class" "type"]], :type "boolean", :name ":has"} {:args [["FileHandle" "skin-file"]], :text "Adds all resources in the specified skin JSON file.", :name ":load"} {:args [["String" "name"]], :type "Drawable", :text "Returns a copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["String" "name"] ["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "Drawable", :text "Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["String" "name"] ["Color" "tint"]], :type "Drawable", :text "Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["Drawable" "drawable"]], :type "Drawable", :text "Returns a copy of the specified drawable.", :name ":new-drawable"} {:args [["Drawable" "drawable"] ["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :type "Drawable", :text "Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["Drawable" "drawable"] ["Color" "tint"]], :type "Drawable", :text "Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}.", :name ":new-drawable"} {:args [["String" "name"] ["java.lang.Class" "type"]], :type "Object", :name ":optional"} {:args [["String" "name"] ["java.lang.Class" "type"]], :name ":remove"} {:args [["Actor" "actor"] ["boolean" "enabled"]], :text "Sets the style on the actor to disabled or enabled. This is done by appending \"-disabled\" to the style name when enabled is\n false, and removing \"-disabled\" from the style name when enabled is true. A method named \"getStyle\" is called the actor via\n reflection and the name of that style is found in the skin. If the actor doesn't have a \"getStyle\" method or the style was\n not found in the skin, no exception is thrown and the actor is left unchanged.", :name ":set-enabled"}]}]], :name "skin!", :type :code, :raw "(defmacro skin!\n  [object k & options]\n  `(u/call! ^Skin ~object ~k ~@options))", :docstring "<p>Calls a single method on a <code>skin</code>.</p>"} {:raw* nil, :arglists [(align k)], :java [["align" {:text "Provides bit flag constants for alignment.", :items [{:name ":bottom"} {:name ":center"} {:name ":left"} {:name ":right"} {:name ":top"}]}]], :name "align", :type :code, :raw "(defmacro align\n  [k]\n  `~(u/gdx-field :scenes :scene2d :utils :Align (u/key->camel k)))", :docstring "<p>Returns a static field from <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/Align.html'>Align</a>.</p><pre>\n&#40;align :center&#41;\n</pre>"} {:raw* nil, :arglists [(cell! cell & args)], :java [], :name "cell!", :type :code, :raw "(defn cell!\n  [^Cell cell & args]\n  (let [method (first args)\n        [[a1 a2 a3 a4] rest-args] (split-with #(not (keyword? %)) (rest args))]\n    (when method\n      (case method\n        :width (.width cell ^double a1)\n        :height (.height cell ^double a1)\n        :size (.size cell ^double a1 ^double a2)\n        :min-width (.minWidth cell ^double a1)\n        :min-height (.minHeight cell ^double a1)\n        :min-size (.minSize cell ^double a1 ^double a2)\n        :max-width (.maxWidth cell ^double a1)\n        :max-height (.maxHeight cell ^double a1)\n        :max-size (.minSize cell ^double a1 ^double a2)\n        :space (.space cell ^double a1 ^double a2 ^double a3 ^double a4)\n        :space-top (.spaceTop cell ^double a1)\n        :space-left (.spaceLeft cell ^double a1)\n        :space-bottom (.spaceBottom cell ^double a1)\n        :space-right (.spaceRight cell ^double a1)\n        :pad (.pad cell ^double a1 ^double a2 ^double a3 ^double a4)\n        :pad-top (.padTop cell ^double a1)\n        :pad-left (.padLeft cell ^double a1)\n        :pad-bottom (.padBottom cell ^double a1)\n        :pad-right (.padRight cell ^double a1)\n        :fill (.fill cell ^boolean a1 ^boolean a2)\n        :fill-x (.fillX cell)\n        :fill-y (.fillY cell)\n        :align (.align cell (int a1))\n        :center (.center cell)\n        :top (.top cell)\n        :left (.left cell)\n        :bottom (.bottom cell)\n        :right (.right cell)\n        :expand (.expand cell ^boolean a1 ^boolean a2)\n        :expand-x (.expandX cell)\n        :expand-y (.expandY cell)\n        :ignore (.ignore cell ^boolean a1)\n        :colspan (.colspan cell (int a1))\n        :uniform (.uniform cell ^boolean a1 ^boolean a2)\n        :uniform-x (.uniformX cell)\n        :uniform-y (.uniformY cell)\n        :row (.row cell)\n        (u/throw-key-not-found method))\n      (apply cell! cell rest-args))\n    cell))", :docstring "<p>Calls a single method on a <a href='https://github.com/libgdx/libgdx/blob/master/gdx/src/com/esotericsoftware/tablelayout/Cell.java'>Cell</a>.</p>"} {:raw* nil, :arglists [(add! group & children)], :java [], :name "add!", :type :code, :raw "(defn add!\n  [group & children]\n  (doseq [child children]\n    (add-to-group! [group child]))\n  group)", :docstring "<p>Adds the entities in <code>children</code> to the <code>group</code> entity of type <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/WidgetGroup.html'>WidgetGroup</a>.</p>"} {:raw* nil, :arglists [(actor! entity k & options)], :java [["actor!" {:text "2D scene graph node. An actor has a position, rectangular size, origin, scale, rotation, Z index, and color. The position\n corresponds to the unrotated, unscaled bottom left corner of the actor. The position is relative to the actor's parent. The\n origin is relative to the position and is used for scale and rotation.\n <p>\n An actor has a list of in progress {@link Action actions} that are applied to the actor (often over time). These are generally\n used to change the presentation of the actor (moving it, resizing it, etc). See {@link #act(float)}, {@link Action} and its\n many subclasses.\n <p>\n An actor has two kinds of listeners associated with it: \"capture\" and regular. The listeners are notified of events the actor\n or its children receive. The regular listeners are designed to allow an actor to respond to events that have been delivered.\n The capture listeners are designed to allow a parent or container actor to handle events before child actors. See {@link #fire}\n for more details.\n <p>\n An {@link InputListener} can receive all the basic input events. More complex listeners (like {@link ClickListener} and\n {@link ActorGestureListener}) can listen for and combine primitive events and recognize complex interactions like multi-touch\n or pinch.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["float" "height"]], :name ":set-height"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"}]}]], :name "actor!", :type :code, :raw "(defmacro actor!\n  [entity k & options]\n  `(u/call! ^Actor (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on an actor.</p>"} {:raw* nil, :arglists [(actor? entity)], :java [], :name "actor?", :type :code, :raw "(defn actor?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Actor))", :docstring "<p>Returns true if <code>entity</code> is an actor.</p>"} {:raw* "(defn check-box*\n  [^String text arg]\n  (ActorEntity. (CheckBox. text arg)))", :arglists [(check-box text arg & options)], :java [["check-box" {:text "A checkbox is a button that contains an image indicating the checked or unchecked state and a label.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :name ":get-click-listener"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Image", :name ":get-image"} {:args [], :type "Cell", :name ":get-image-cell"} {:args [], :type "Label", :name ":get-label"} {:args [], :type "Cell", :name ":get-label-cell"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Button.ButtonStyle", :text "Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "TextButton.TextButtonStyle", :name ":get-style"} {:args [], :type "CheckBox.CheckBoxStyle", :text "Returns the checkbox's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "CharSequence", :name ":get-text"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [], :type "boolean", :name ":is-checked"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-over"} {:args [], :type "boolean", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "is-checked"]], :name ":set-checked"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "is-disabled"]], :text "When true, the button will not toggle {@link #isChecked()} when clicked and will not fire a {@link ChangeEvent}.", :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Button.ButtonStyle" "style"]], :name ":set-style"} {:args [["String" "text"]], :name ":set-text"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Toggles the checked state. This method changes the checked state, which fires a {@link ChangeEvent}, so can be used to\n simulate a button click.", :name ":toggle"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "check-box", :type :code, :raw "(defmacro check-box\n  [text arg & options]\n  `(let [entity# (check-box* ~text ~arg)]\n     (u/calls! ^CheckBox (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.html'>CheckBox</a>.</p><pre>\n&#40;check-box &quot;I'm a check box&quot; &#40;style :check-box off on font color&#41;&#41;\n&#40;check-box &quot;I'm a check box&quot; &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(check-box! entity k & options)], :java [["check-box!" {:text "A checkbox is a button that contains an image indicating the checked or unchecked state and a label.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :name ":get-click-listener"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Image", :name ":get-image"} {:args [], :type "Cell", :name ":get-image-cell"} {:args [], :type "Label", :name ":get-label"} {:args [], :type "Cell", :name ":get-label-cell"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Button.ButtonStyle", :text "Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "TextButton.TextButtonStyle", :name ":get-style"} {:args [], :type "CheckBox.CheckBoxStyle", :text "Returns the checkbox's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "CharSequence", :name ":get-text"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [], :type "boolean", :name ":is-checked"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-over"} {:args [], :type "boolean", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "is-checked"]], :name ":set-checked"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "is-disabled"]], :text "When true, the button will not toggle {@link #isChecked()} when clicked and will not fire a {@link ChangeEvent}.", :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Button.ButtonStyle" "style"]], :name ":set-style"} {:args [["String" "text"]], :name ":set-text"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Toggles the checked state. This method changes the checked state, which fires a {@link ChangeEvent}, so can be used to\n simulate a button click.", :name ":toggle"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "check-box!", :type :code, :raw "(defmacro check-box!\n  [entity k & options]\n  `(u/call! ^CheckBox (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>check-box</code>.</p>"} {:raw* nil, :arglists [(check-box? entity)], :java [], :name "check-box?", :type :code, :raw "(defn check-box?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) CheckBox))", :docstring "<p>Returns true if <code>entity</code> is a <code>check-box</code>.</p>"} {:raw* "(defn container*\n  [child]\n  (ActorEntity. (Container. (u/get-obj child :object))))", :arglists [(container child & options)], :java [], :name "container", :type :code, :raw "(defmacro container\n  [child & options]\n  `(let [entity# (container* ~child)]\n     (u/calls! ^Container (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Container.html'>Container</a>.</p><pre>\n&#40;container entity&#41;\n</pre>"} {:raw* nil, :arglists [(container! entity k & options)], :java [], :name "container!", :type :code, :raw "(defmacro container!\n  [entity k & options]\n  `(u/call! ^Container (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>container</code>.</p>"} {:raw* nil, :arglists [(container? entity)], :java [], :name "container?", :type :code, :raw "(defn container?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Container))", :docstring "<p>Returns true if <code>entity</code> is a <code>container</code>.</p>"} {:raw* "(defn dialog*\n  [text arg]\n  (ActorEntity. (Dialog. text arg)))", :arglists [(dialog text arg & options)], :java [["dialog" {:text "Displays a dialog, which is a modal window containing a content table with a button table underneath it. Methods are provided\n to add a label to the content table and buttons to the button table, but any widgets can be added. When a button is clicked,\n {@link #result(Object)} is called and the dialog is removed from the stage.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [["String" "text"]], :type "Dialog", :text "Adds a text button to the button table. Null will be passed to {@link #result(Object)} if this button is clicked. The dialog\n must have been constructed with a skin to use this method.", :name ":button"} {:args [["String" "text"] ["Object" "object"]], :type "Dialog", :text "Adds a text button to the button table. The dialog must have been constructed with a skin to use this method.", :name ":button"} {:args [["String" "text"] ["Object" "object"] ["TextButton.TextButtonStyle" "button-style"]], :type "Dialog", :text "Adds a text button to the button table.", :name ":button"} {:args [["Button" "button"]], :type "Dialog", :text "Adds the given button to the button table.", :name ":button"} {:args [["Button" "button"] ["Object" "object"]], :type "Dialog", :text "Adds the given button to the button table.", :name ":button"} {:args [], :name ":cancel"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Table", :name ":get-button-table"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "Table", :name ":get-content-table"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Window.WindowStyle", :text "Returns the window's style. Modifying the returned style may not have an effect until {@link #setStyle(WindowStyle)} is\n called.", :name ":get-style"} {:args [], :type "String", :name ":get-title"} {:args [], :type "float", :name ":get-title-width"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [], :text "Hides the dialog. Called automatically when a button is clicked. The default implementation fades out the dialog over\n {@link #fadeDuration} seconds and then removes it from the stage.", :name ":hide"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-dragging"} {:args [], :type "boolean", :name ":is-modal"} {:args [], :type "boolean", :name ":is-movable"} {:args [], :type "boolean", :name ":is-resizable"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [["int" "keycode"] ["Object" "object"]], :type "Dialog", :text "If this key is pressed, {@link #result(Object)} is called with the specified object.", :name ":key"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "keep-within-stage"]], :name ":set-keep-within-stage"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["boolean" "is-modal"]], :name ":set-modal"} {:args [["boolean" "is-movable"]], :name ":set-movable"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["Actor" "actor"] ["Object" "object"]], :name ":set-object"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["boolean" "is-resizable"]], :name ":set-resizable"} {:args [["int" "resize-border"]], :name ":set-resize-border"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Window.WindowStyle" "style"]], :name ":set-style"} {:args [["String" "title"]], :name ":set-title"} {:args [["int" "title-alignment"]], :name ":set-title-alignment"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["Stage" "stage"]], :type "Dialog", :text "{@link #pack() Packs} the dialog and adds it to the stage, centered.", :name ":show"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [["String" "text"]], :type "Dialog", :text "Adds a label to the content table. The dialog must have been constructed with a skin to use this method.", :name ":text"} {:args [["String" "text"] ["Label.LabelStyle" "label-style"]], :type "Dialog", :text "Adds a label to the content table.", :name ":text"} {:args [["Label" "label"]], :type "Dialog", :text "Adds the given Label to the content table", :name ":text"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "dialog", :type :code, :raw "(defmacro dialog\n  [text arg & options]\n  `(let [entity# (dialog* ~text ~arg)]\n     (u/calls! ^Dialog (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Dialog.html'>Dialog</a>.</p><pre>\n&#40;dialog &quot;I'm a dialog&quot; &#40;style :window font font-color background&#41;&#41;\n&#40;dialog &quot;I'm a dialog&quot; &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(dialog! entity k & options)], :java [["dialog!" {:text "Displays a dialog, which is a modal window containing a content table with a button table underneath it. Methods are provided\n to add a label to the content table and buttons to the button table, but any widgets can be added. When a button is clicked,\n {@link #result(Object)} is called and the dialog is removed from the stage.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [["String" "text"]], :type "Dialog", :text "Adds a text button to the button table. Null will be passed to {@link #result(Object)} if this button is clicked. The dialog\n must have been constructed with a skin to use this method.", :name ":button"} {:args [["String" "text"] ["Object" "object"]], :type "Dialog", :text "Adds a text button to the button table. The dialog must have been constructed with a skin to use this method.", :name ":button"} {:args [["String" "text"] ["Object" "object"] ["TextButton.TextButtonStyle" "button-style"]], :type "Dialog", :text "Adds a text button to the button table.", :name ":button"} {:args [["Button" "button"]], :type "Dialog", :text "Adds the given button to the button table.", :name ":button"} {:args [["Button" "button"] ["Object" "object"]], :type "Dialog", :text "Adds the given button to the button table.", :name ":button"} {:args [], :name ":cancel"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Table", :name ":get-button-table"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "Table", :name ":get-content-table"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Window.WindowStyle", :text "Returns the window's style. Modifying the returned style may not have an effect until {@link #setStyle(WindowStyle)} is\n called.", :name ":get-style"} {:args [], :type "String", :name ":get-title"} {:args [], :type "float", :name ":get-title-width"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [], :text "Hides the dialog. Called automatically when a button is clicked. The default implementation fades out the dialog over\n {@link #fadeDuration} seconds and then removes it from the stage.", :name ":hide"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-dragging"} {:args [], :type "boolean", :name ":is-modal"} {:args [], :type "boolean", :name ":is-movable"} {:args [], :type "boolean", :name ":is-resizable"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [["int" "keycode"] ["Object" "object"]], :type "Dialog", :text "If this key is pressed, {@link #result(Object)} is called with the specified object.", :name ":key"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "keep-within-stage"]], :name ":set-keep-within-stage"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["boolean" "is-modal"]], :name ":set-modal"} {:args [["boolean" "is-movable"]], :name ":set-movable"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["Actor" "actor"] ["Object" "object"]], :name ":set-object"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["boolean" "is-resizable"]], :name ":set-resizable"} {:args [["int" "resize-border"]], :name ":set-resize-border"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Window.WindowStyle" "style"]], :name ":set-style"} {:args [["String" "title"]], :name ":set-title"} {:args [["int" "title-alignment"]], :name ":set-title-alignment"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["Stage" "stage"]], :type "Dialog", :text "{@link #pack() Packs} the dialog and adds it to the stage, centered.", :name ":show"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [["String" "text"]], :type "Dialog", :text "Adds a label to the content table. The dialog must have been constructed with a skin to use this method.", :name ":text"} {:args [["String" "text"] ["Label.LabelStyle" "label-style"]], :type "Dialog", :text "Adds a label to the content table.", :name ":text"} {:args [["Label" "label"]], :type "Dialog", :text "Adds the given Label to the content table", :name ":text"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "dialog!", :type :code, :raw "(defmacro dialog!\n  [entity k & options]\n  `(u/call! ^Dialog (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>dialog</code>.</p>"} {:raw* nil, :arglists [(dialog? entity)], :java [], :name "dialog?", :type :code, :raw "(defn dialog?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Dialog))", :docstring "<p>Returns true if <code>entity</code> is a <code>dialog</code>.</p>"} {:raw* "(defn horizontal*\n  [children]\n  (create-group (HorizontalGroup.) children))", :arglists [(horizontal children & options)], :java [["horizontal" {:text "A group that lays out its children side by side in a single row. This can be easier than using {@link Table} when actors need\n to be inserted in the middle of the group.\n <p>\n The preferred width is the sum of the children's preferred widths, plus spacing if set. The preferred height is the largest\n preferred height of any child. The min size is the preferred size and the max size is 0 as <code>HorizontalGroup</code> can be\n stretched to cover any area.\n <p>\n This UI widget does not support <code>Layout</code>able actors that return 0 as their preferred width. A fine example is\n {@link Label} class with text wrapping turned on.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "HorizontalGroup", :text "Sets the alignment of widgets within the horizontal group. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom}, {@link Align#left}, {@link Align#right}, or any combination of those.", :name ":align"} {:args [], :type "HorizontalGroup", :text "Sets {@link Align#bottom} and clears {@link Align#top} for the alignment of widgets within the horizontal group.", :name ":bottom"} {:args [], :type "HorizontalGroup", :text "Sets the alignment of widgets within the horizontal group to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [], :type "HorizontalGroup", :name ":fill"} {:args [["float" "fill"]], :type "HorizontalGroup", :name ":fill"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-fill"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "boolean", :name ":get-reverse"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :name ":get-space"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["float" "pad"]], :type "HorizontalGroup", :text "Sets the padTop, padLeft, padBottom, and padRight to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "HorizontalGroup", :name ":pad"} {:args [["float" "pad-bottom"]], :type "HorizontalGroup", :name ":pad-bottom"} {:args [["float" "pad-left"]], :type "HorizontalGroup", :name ":pad-left"} {:args [["float" "pad-right"]], :type "HorizontalGroup", :name ":pad-right"} {:args [["float" "pad-top"]], :type "HorizontalGroup", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :type "HorizontalGroup", :text "The children will be ordered from right to left rather than the default left to right.", :name ":reverse"} {:args [["boolean" "reverse"]], :type "HorizontalGroup", :text "If true, the children will be ordered from right to left rather than the default left to right.", :name ":reverse"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "spacing"]], :type "HorizontalGroup", :text "Sets the space between children.", :name ":space"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :type "HorizontalGroup", :text "Sets {@link Align#top} and clears {@link Align#bottom} for the alignment of widgets within the horizontal group.", :name ":top"} {:args [], :name ":validate"}]}]], :name "horizontal", :type :code, :raw "(defmacro horizontal\n  [children & options]\n  `(let [entity# (horizontal* ~children)]\n     (u/calls! ^HorizontalGroup (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/HorizontalGroup.html'>HorizontalGroup</a>.</p><pre>\n&#40;horizontal &#91;entity-1 entity-2&#93;&#41;\n</pre>"} {:raw* nil, :arglists [(horizontal! entity k & options)], :java [["horizontal!" {:text "A group that lays out its children side by side in a single row. This can be easier than using {@link Table} when actors need\n to be inserted in the middle of the group.\n <p>\n The preferred width is the sum of the children's preferred widths, plus spacing if set. The preferred height is the largest\n preferred height of any child. The min size is the preferred size and the max size is 0 as <code>HorizontalGroup</code> can be\n stretched to cover any area.\n <p>\n This UI widget does not support <code>Layout</code>able actors that return 0 as their preferred width. A fine example is\n {@link Label} class with text wrapping turned on.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "HorizontalGroup", :text "Sets the alignment of widgets within the horizontal group. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom}, {@link Align#left}, {@link Align#right}, or any combination of those.", :name ":align"} {:args [], :type "HorizontalGroup", :text "Sets {@link Align#bottom} and clears {@link Align#top} for the alignment of widgets within the horizontal group.", :name ":bottom"} {:args [], :type "HorizontalGroup", :text "Sets the alignment of widgets within the horizontal group to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [], :type "HorizontalGroup", :name ":fill"} {:args [["float" "fill"]], :type "HorizontalGroup", :name ":fill"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-fill"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "boolean", :name ":get-reverse"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :name ":get-space"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["float" "pad"]], :type "HorizontalGroup", :text "Sets the padTop, padLeft, padBottom, and padRight to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "HorizontalGroup", :name ":pad"} {:args [["float" "pad-bottom"]], :type "HorizontalGroup", :name ":pad-bottom"} {:args [["float" "pad-left"]], :type "HorizontalGroup", :name ":pad-left"} {:args [["float" "pad-right"]], :type "HorizontalGroup", :name ":pad-right"} {:args [["float" "pad-top"]], :type "HorizontalGroup", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :type "HorizontalGroup", :text "The children will be ordered from right to left rather than the default left to right.", :name ":reverse"} {:args [["boolean" "reverse"]], :type "HorizontalGroup", :text "If true, the children will be ordered from right to left rather than the default left to right.", :name ":reverse"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "spacing"]], :type "HorizontalGroup", :text "Sets the space between children.", :name ":space"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :type "HorizontalGroup", :text "Sets {@link Align#top} and clears {@link Align#bottom} for the alignment of widgets within the horizontal group.", :name ":top"} {:args [], :name ":validate"}]}]], :name "horizontal!", :type :code, :raw "(defmacro horizontal!\n  [entity k & options]\n  `(u/call! ^HorizontalGroup (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>horizontal</code>.</p>"} {:raw* nil, :arglists [(horizontal? entity)], :java [], :name "horizontal?", :type :code, :raw "(defn horizontal?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) HorizontalGroup))", :docstring "<p>Returns true if <code>entity</code> is a <code>horizontal</code>.</p>"} {:raw* "(defn image*\n  [arg]\n  (ActorEntity.\n    (cond\n      (map? arg)\n      (Image. ^TextureRegion (:object arg))\n      (string? arg)\n      (Image. (Texture. ^String arg))\n      :else\n      (Image. arg))))", :arglists [(image arg & options)], :java [["image" {:text "Displays a {@link Drawable}, scaled various way within the widgets bounds. The preferred size is the min size of the drawable.\n Only when using a {@link TextureRegionDrawable} will the actor's scale, rotation, and origin be used when drawing.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "Drawable", :name ":get-drawable"} {:args [], :type "float", :name ":get-height"} {:args [], :type "float", :name ":get-image-height"} {:args [], :type "float", :name ":get-image-width"} {:args [], :type "float", :name ":get-image-x"} {:args [], :type "float", :name ":get-image-y"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["int" "align"]], :name ":set-align"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Skin" "skin"] ["String" "drawable-name"]], :name ":set-drawable"} {:args [["Drawable" "drawable"]], :name ":set-drawable"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["Scaling" "scaling"]], :name ":set-scaling"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "image", :type :code, :raw "(defmacro image\n  [arg & options]\n  `(let [entity# (image* ~arg)]\n     (u/calls! ^Image (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Image.html'>Image</a>.</p><pre>\n&#40;image &quot;image.png&quot;&#41;\n</pre>"} {:raw* nil, :arglists [(image! entity k & options)], :java [["image!" {:text "Displays a {@link Drawable}, scaled various way within the widgets bounds. The preferred size is the min size of the drawable.\n Only when using a {@link TextureRegionDrawable} will the actor's scale, rotation, and origin be used when drawing.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "Drawable", :name ":get-drawable"} {:args [], :type "float", :name ":get-height"} {:args [], :type "float", :name ":get-image-height"} {:args [], :type "float", :name ":get-image-width"} {:args [], :type "float", :name ":get-image-x"} {:args [], :type "float", :name ":get-image-y"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["int" "align"]], :name ":set-align"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Skin" "skin"] ["String" "drawable-name"]], :name ":set-drawable"} {:args [["Drawable" "drawable"]], :name ":set-drawable"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["Scaling" "scaling"]], :name ":set-scaling"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "image!", :type :code, :raw "(defmacro image!\n  [entity k & options]\n  `(u/call! ^Image (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>image</code>.</p>"} {:raw* nil, :arglists [(image? entity)], :java [], :name "image?", :type :code, :raw "(defn image?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Image))", :docstring "<p>Returns true if <code>entity</code> is an <code>image</code>.</p>"} {:raw* "(defn image-button*\n  [arg]\n  (ActorEntity. (ImageButton. arg)))", :arglists [(image-button arg & options)], :java [["image-button" {:text "A button with a child {@link Image} to display an image. This is useful when the button must be larger than the image and the\n image centered on the button. If the image is the size of the button, a {@link Button} without any children can be used, where\n the {@link Button.ButtonStyle#up}, {@link Button.ButtonStyle#down}, and {@link Button.ButtonStyle#checked} nine patches define\n the image.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :name ":get-click-listener"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Image", :name ":get-image"} {:args [], :type "Cell", :name ":get-image-cell"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Button.ButtonStyle", :text "Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "ImageButton.ImageButtonStyle", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [], :type "boolean", :name ":is-checked"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-over"} {:args [], :type "boolean", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "is-checked"]], :name ":set-checked"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "is-disabled"]], :text "When true, the button will not toggle {@link #isChecked()} when clicked and will not fire a {@link ChangeEvent}.", :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Button.ButtonStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Toggles the checked state. This method changes the checked state, which fires a {@link ChangeEvent}, so can be used to\n simulate a button click.", :name ":toggle"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "image-button", :type :code, :raw "(defmacro image-button\n  [arg & options]\n  `(let [entity# (image-button* ~arg)]\n     (u/calls! ^ImageButton (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/ImageButton.html'>ImageButton</a>.</p><pre>\n&#40;image-button &#40;style :image-button up dn check img-up img-dn img-check&#41;&#41;\n&#40;image-button &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(image-button! entity k & options)], :java [["image-button!" {:text "A button with a child {@link Image} to display an image. This is useful when the button must be larger than the image and the\n image centered on the button. If the image is the size of the button, a {@link Button} without any children can be used, where\n the {@link Button.ButtonStyle#up}, {@link Button.ButtonStyle#down}, and {@link Button.ButtonStyle#checked} nine patches define\n the image.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :name ":get-click-listener"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Image", :name ":get-image"} {:args [], :type "Cell", :name ":get-image-cell"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Button.ButtonStyle", :text "Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "ImageButton.ImageButtonStyle", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [], :type "boolean", :name ":is-checked"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-over"} {:args [], :type "boolean", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "is-checked"]], :name ":set-checked"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "is-disabled"]], :text "When true, the button will not toggle {@link #isChecked()} when clicked and will not fire a {@link ChangeEvent}.", :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Button.ButtonStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Toggles the checked state. This method changes the checked state, which fires a {@link ChangeEvent}, so can be used to\n simulate a button click.", :name ":toggle"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "image-button!", :type :code, :raw "(defmacro image-button!\n  [entity k & options]\n  `(u/call! ^ImageButton (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>image-button</code>.</p>"} {:raw* nil, :arglists [(image-button? entity)], :java [], :name "image-button?", :type :code, :raw "(defn image-button?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) ImageButton))", :docstring "<p>Returns true if <code>entity</code> is an <code>image-button</code>.</p>"} {:raw* "(defn image-text-button*\n  [^String text arg]\n  (ActorEntity. (ImageTextButton. text arg)))", :arglists [(image-text-button text arg & options)], :java [["image-text-button" {:text "A button with a child {@link Image} and {@link Label}.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :name ":get-click-listener"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Image", :name ":get-image"} {:args [], :type "Cell", :name ":get-image-cell"} {:args [], :type "Label", :name ":get-label"} {:args [], :type "Cell", :name ":get-label-cell"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Button.ButtonStyle", :text "Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "ImageTextButton.ImageTextButtonStyle", :name ":get-style"} {:args [], :type "CharSequence", :name ":get-text"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [], :type "boolean", :name ":is-checked"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-over"} {:args [], :type "boolean", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "is-checked"]], :name ":set-checked"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "is-disabled"]], :text "When true, the button will not toggle {@link #isChecked()} when clicked and will not fire a {@link ChangeEvent}.", :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Button.ButtonStyle" "style"]], :name ":set-style"} {:args [["String" "text"]], :name ":set-text"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Toggles the checked state. This method changes the checked state, which fires a {@link ChangeEvent}, so can be used to\n simulate a button click.", :name ":toggle"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "image-text-button", :type :code, :raw "(defmacro image-text-button\n  [text arg & options]\n  `(let [entity# (image-text-button* ~text ~arg)]\n     (u/calls! ^ImageTextButton (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.html'>ImageTextButton</a>.</p><pre>\n&#40;image-text-button &quot;I'm an image text button&quot;\n                   &#40;style :image-text-button up down checked font&#41;&#41;\n&#40;image-text-button &quot;I'm an image text button&quot; &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(image-text-button! entity k & options)], :java [["image-text-button!" {:text "A button with a child {@link Image} and {@link Label}.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :name ":get-click-listener"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Image", :name ":get-image"} {:args [], :type "Cell", :name ":get-image-cell"} {:args [], :type "Label", :name ":get-label"} {:args [], :type "Cell", :name ":get-label-cell"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Button.ButtonStyle", :text "Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "ImageTextButton.ImageTextButtonStyle", :name ":get-style"} {:args [], :type "CharSequence", :name ":get-text"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [], :type "boolean", :name ":is-checked"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-over"} {:args [], :type "boolean", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "is-checked"]], :name ":set-checked"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "is-disabled"]], :text "When true, the button will not toggle {@link #isChecked()} when clicked and will not fire a {@link ChangeEvent}.", :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Button.ButtonStyle" "style"]], :name ":set-style"} {:args [["String" "text"]], :name ":set-text"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Toggles the checked state. This method changes the checked state, which fires a {@link ChangeEvent}, so can be used to\n simulate a button click.", :name ":toggle"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "image-text-button!", :type :code, :raw "(defmacro image-text-button!\n  [entity k & options]\n  `(u/call! ^ImageTextButton (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>image-text-button</code>.</p>"} {:raw* nil, :arglists [(image-text-button? entity)], :java [], :name "image-text-button?", :type :code, :raw "(defn image-text-button?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) ImageTextButton))", :docstring "<p>Returns true if <code>entity</code> is a <code>image-text-button</code>.</p>"} {:raw* "(defn label*\n  [^String text arg]\n  (ActorEntity.\n    (if (isa? (type arg) Color)\n      (Label. text (style :label (g2d/bitmap-font) arg))\n      (Label. text arg))))", :arglists [(label text arg & options)], :java [["label" {:text "A text label, with optional word wrapping.\n <p>\n The preferred size of the label is determined by the actual text bounds, unless {@link #setWrap(boolean) word wrap} is enabled.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-font-scale-x"} {:args [], :type "float", :name ":get-font-scale-y"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Label.LabelStyle", :text "Returns the label's style. Modifying the returned style may not have an effect until {@link #setStyle(LabelStyle)} is\n called.", :name ":get-style"} {:args [], :type "CharSequence", :name ":get-text"} {:args [], :type "BitmapFont.TextBounds", :name ":get-text-bounds"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["int" "alignment"]], :name ":set-alignment"} {:args [["int" "label-align"] ["int" "line-align"]], :name ":set-alignment"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["boolean" "ellipse"]], :text "When true the text will be truncated with an ellipse if it does not fit within the width of the label. Default is false.", :name ":set-ellipse"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "font-scale"]], :name ":set-font-scale"} {:args [["float" "font-scale-x"] ["float" "font-scale-y"]], :name ":set-font-scale"} {:args [["float" "font-scale-x"]], :name ":set-font-scale-x"} {:args [["float" "font-scale-y"]], :name ":set-font-scale-y"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Label.LabelStyle" "style"]], :name ":set-style"} {:args [["CharSequence" "new-text"]], :name ":set-text"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["boolean" "wrap"]], :text "If false, the text will only wrap where it contains newlines (\\n). The preferred size of the label will be the text bounds.\n If true, the text will word wrap using the width of the label. The preferred width of the label will be 0, it is expected\n that the something external will set the width of the label. Default is false.\n <p>\n When wrap is enabled, the label's preferred height depends on the width of the label. In some cases the parent of the label\n will need to layout twice: once to set the width of the label and a second time to adjust to the label's new preferred\n height.", :name ":set-wrap"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["CharSequence" "other"]], :type "boolean", :name ":text-equals"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "label", :type :code, :raw "(defmacro label\n  [text arg & options]\n  `(let [entity# (label* ~text ~arg)]\n     (u/calls! ^Label (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Label.html'>Label</a>.</p><pre>\n&#40;label &quot;I'm a label&quot; &#40;color :white&#41;&#41;\n&#40;label &quot;I'm a label&quot; &#40;style :label &#40;g2d/bitmap-font&#41; &#40;color :white&#41;&#41;&#41;\n&#40;label &quot;I'm a label&quot; &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(label! entity k & options)], :java [["label!" {:text "A text label, with optional word wrapping.\n <p>\n The preferred size of the label is determined by the actual text bounds, unless {@link #setWrap(boolean) word wrap} is enabled.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-font-scale-x"} {:args [], :type "float", :name ":get-font-scale-y"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Label.LabelStyle", :text "Returns the label's style. Modifying the returned style may not have an effect until {@link #setStyle(LabelStyle)} is\n called.", :name ":get-style"} {:args [], :type "CharSequence", :name ":get-text"} {:args [], :type "BitmapFont.TextBounds", :name ":get-text-bounds"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["int" "alignment"]], :name ":set-alignment"} {:args [["int" "label-align"] ["int" "line-align"]], :name ":set-alignment"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["boolean" "ellipse"]], :text "When true the text will be truncated with an ellipse if it does not fit within the width of the label. Default is false.", :name ":set-ellipse"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "font-scale"]], :name ":set-font-scale"} {:args [["float" "font-scale-x"] ["float" "font-scale-y"]], :name ":set-font-scale"} {:args [["float" "font-scale-x"]], :name ":set-font-scale-x"} {:args [["float" "font-scale-y"]], :name ":set-font-scale-y"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Label.LabelStyle" "style"]], :name ":set-style"} {:args [["CharSequence" "new-text"]], :name ":set-text"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["boolean" "wrap"]], :text "If false, the text will only wrap where it contains newlines (\\n). The preferred size of the label will be the text bounds.\n If true, the text will word wrap using the width of the label. The preferred width of the label will be 0, it is expected\n that the something external will set the width of the label. Default is false.\n <p>\n When wrap is enabled, the label's preferred height depends on the width of the label. In some cases the parent of the label\n will need to layout twice: once to set the width of the label and a second time to adjust to the label's new preferred\n height.", :name ":set-wrap"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["CharSequence" "other"]], :type "boolean", :name ":text-equals"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "label!", :type :code, :raw "(defmacro label!\n  [entity k & options]\n  `(u/call! ^Label (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>label</code>.</p>"} {:raw* nil, :arglists [(label? entity)], :java [], :name "label?", :type :code, :raw "(defn label?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Label))", :docstring "<p>Returns true if <code>entity</code> is a <code>label</code>.</p>"} {:raw* "(defn scroll-pane*\n  [child arg]\n  (ActorEntity. (ScrollPane. (u/get-obj child :object) arg)))", :arglists [(scroll-pane child arg & options)], :java [["scroll-pane" {:text "A group that scrolls a child widget using scrollbars and/or mouse or touch dragging.\n <p>\n The widget is sized to its preferred size. If the widget's preferred width or height is less than the size of this scroll pane,\n it is set to the size of this scroll pane. Scrollbars appear when the widget is larger than the scroll pane.\n <p>\n The scroll pane's preferred size is that of the child widget. At this size, the child widget will not need to scroll, so the\n scroll pane is typically sized by ignoring the preferred size in one or both directions.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor"]], :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["int" "index"] ["Actor" "actor"]], :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "If currently scrolling by tracking a touch down, stop scrolling.", :name ":cancel"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [["float" "fling-time"] ["float" "velocity-x"] ["float" "velocity-y"]], :text "Generate fling gesture.", :name ":fling"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :text "Returns the maximum scroll value in the x direction.", :name ":get-max-x"} {:args [], :type "float", :text "Returns the maximum scroll value in the y direction.", :name ":get-max-y"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :name ":get-scroll-bar-height"} {:args [], :type "float", :name ":get-scroll-bar-width"} {:args [], :type "float", :text "Returns the height of the scrolled viewport.", :name ":get-scroll-height"} {:args [], :type "float", :name ":get-scroll-percent-x"} {:args [], :type "float", :name ":get-scroll-percent-y"} {:args [], :type "float", :text "Returns the width of the scrolled viewport.", :name ":get-scroll-width"} {:args [], :type "float", :text "Returns the x scroll position in pixels.", :name ":get-scroll-x"} {:args [], :type "float", :text "Returns the y scroll position in pixels.", :name ":get-scroll-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "ScrollPane.ScrollPaneStyle", :text "Returns the scroll pane's style. Modifying the returned style may not have an effect until\n {@link #setStyle(ScrollPaneStyle)} is called.", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "boolean", :name ":get-variable-size-knobs"} {:args [], :type "float", :text "Gets the flick scroll y velocity.", :name ":get-velocity-x"} {:args [], :type "float", :text "Gets the flick scroll y velocity.", :name ":get-velocity-y"} {:args [], :type "float", :name ":get-visual-scroll-x"} {:args [], :type "float", :name ":get-visual-scroll-y"} {:args [], :type "Actor", :text "Returns the actor embedded in this scroll pane, or null.", :name ":get-widget"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-dragging"} {:args [], :type "boolean", :name ":is-flinging"} {:args [], :type "boolean", :name ":is-force-scroll-x"} {:args [], :type "boolean", :name ":is-force-scroll-y"} {:args [], :type "boolean", :name ":is-panning"} {:args [], :type "boolean", :name ":is-scroll-x"} {:args [], :type "boolean", :name ":is-scroll-y"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Sets the scroll offset so the specified rectangle is fully in view, if possible. Coordinates are in the scroll pane widget's\n coordinate system.", :name ":scroll-to"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Sets the scroll offset so the specified rectangle is fully in view and centered vertically in the scroll pane, if possible.\n Coordinates are in the scroll pane widget's coordinate system.", :name ":scroll-to-center"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "cancel-touch-focus"]], :text "When true (default), the {@link Stage#cancelTouchFocus()} touch focus} is cancelled when flick scrolling begins. This causes\n widgets inside the scrollpane that have received touchDown to receive touchUp when flick scrolling begins.", :name ":set-cancel-touch-focus"} {:args [["boolean" "clamp"]], :text "For flick scroll, prevents scrolling out of the widget's bounds. Default is true.", :name ":set-clamp"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fade-scroll-bars"]], :text "When true the scroll bars fade out after some time of not being used.", :name ":set-fade-scroll-bars"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["boolean" "flick-scroll"]], :name ":set-flick-scroll"} {:args [["float" "fling-time"]], :text "For flick scroll, sets the amount of time in seconds that a fling will continue to scroll. Default is 1.", :name ":set-fling-time"} {:args [["boolean" "x"] ["boolean" "y"]], :text "Forces enabling scrollbars (for non-flick scroll) and overscrolling (for flick scroll) in a direction, even if the contents\n do not exceed the bounds in that direction.", :name ":set-force-scroll"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["boolean" "overscroll-x"] ["boolean" "overscroll-y"]], :text "For flick scroll, if true the widget can be scrolled slightly past its bounds and will animate back to its bounds when\n scrolling is stopped. Default is true.", :name ":set-overscroll"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["boolean" "bottom"] ["boolean" "right"]], :text "Set the position of the vertical and horizontal scroll bars (if they exist).", :name ":set-scroll-bar-positions"} {:args [["float" "percent-x"]], :name ":set-scroll-percent-x"} {:args [["float" "percent-y"]], :name ":set-scroll-percent-y"} {:args [["float" "pixels"]], :name ":set-scroll-x"} {:args [["float" "pixels"]], :name ":set-scroll-y"} {:args [["boolean" "scrollbars-on-top"]], :text "When false (the default), the widget is clipped so it is not drawn under the scrollbars. When true, the widget is clipped to\n the entire scroll pane bounds and the scrollbars are drawn on top of the widget. If {@link #setFadeScrollBars(boolean)} is\n true, the scroll bars are always drawn on top.", :name ":set-scrollbars-on-top"} {:args [["boolean" "x"] ["boolean" "y"]], :text "Disables scrolling in a direction. The widget will be sized to the FlickScrollPane in the disabled direction.", :name ":set-scrolling-disabled"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["boolean" "smooth-scrolling"]], :name ":set-smooth-scrolling"} {:args [["ScrollPane.ScrollPaneStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "variable-size-knobs"]], :text "If true, the scroll knobs are sized based on {@link #getMaxX()} or {@link #getMaxY()}. If false, the scroll knobs are sized\n based on {@link Drawable#getMinWidth()} or {@link Drawable#getMinHeight()}. Default is true.", :name ":set-variable-size-knobs"} {:args [["float" "velocity-x"]], :name ":set-velocity-x"} {:args [["float" "velocity-y"]], :name ":set-velocity-y"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["Actor" "widget"]], :text "Sets the {@link Actor} embedded in this scroll pane.", :name ":set-widget"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "fade-alpha-seconds"] ["float" "fade-delay-seconds"]], :name ":setup-fade-scroll-bars"} {:args [["float" "distance"] ["float" "speed-min"] ["float" "speed-max"]], :text "For flick scroll, sets the overscroll distance in pixels and the speed it returns to the widget's bounds in seconds. Default\n is 50, 30, 200.", :name ":setup-overscroll"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Sets the visual scroll amount equal to the scroll amount. This can be used when setting the scroll amount without animating.", :name ":update-visual-scroll"} {:args [], :name ":validate"}]}]], :name "scroll-pane", :type :code, :raw "(defmacro scroll-pane\n  [child arg & options]\n  `(let [entity# (scroll-pane* ~child ~arg)]\n     (u/calls! ^ScrollPane (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.html'>ScrollPane</a>.</p><pre>\n&#40;scroll-pane table-entity &#40;style :scroll-pane back h h-knob v v-knob&#41;&#41;\n&#40;scroll-pane table-entity &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(scroll-pane! entity k & options)], :java [["scroll-pane!" {:text "A group that scrolls a child widget using scrollbars and/or mouse or touch dragging.\n <p>\n The widget is sized to its preferred size. If the widget's preferred width or height is less than the size of this scroll pane,\n it is set to the size of this scroll pane. Scrollbars appear when the widget is larger than the scroll pane.\n <p>\n The scroll pane's preferred size is that of the child widget. At this size, the child widget will not need to scroll, so the\n scroll pane is typically sized by ignoring the preferred size in one or both directions.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor"]], :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["int" "index"] ["Actor" "actor"]], :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "If currently scrolling by tracking a touch down, stop scrolling.", :name ":cancel"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [["float" "fling-time"] ["float" "velocity-x"] ["float" "velocity-y"]], :text "Generate fling gesture.", :name ":fling"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :text "Returns the maximum scroll value in the x direction.", :name ":get-max-x"} {:args [], :type "float", :text "Returns the maximum scroll value in the y direction.", :name ":get-max-y"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :name ":get-scroll-bar-height"} {:args [], :type "float", :name ":get-scroll-bar-width"} {:args [], :type "float", :text "Returns the height of the scrolled viewport.", :name ":get-scroll-height"} {:args [], :type "float", :name ":get-scroll-percent-x"} {:args [], :type "float", :name ":get-scroll-percent-y"} {:args [], :type "float", :text "Returns the width of the scrolled viewport.", :name ":get-scroll-width"} {:args [], :type "float", :text "Returns the x scroll position in pixels.", :name ":get-scroll-x"} {:args [], :type "float", :text "Returns the y scroll position in pixels.", :name ":get-scroll-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "ScrollPane.ScrollPaneStyle", :text "Returns the scroll pane's style. Modifying the returned style may not have an effect until\n {@link #setStyle(ScrollPaneStyle)} is called.", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "boolean", :name ":get-variable-size-knobs"} {:args [], :type "float", :text "Gets the flick scroll y velocity.", :name ":get-velocity-x"} {:args [], :type "float", :text "Gets the flick scroll y velocity.", :name ":get-velocity-y"} {:args [], :type "float", :name ":get-visual-scroll-x"} {:args [], :type "float", :name ":get-visual-scroll-y"} {:args [], :type "Actor", :text "Returns the actor embedded in this scroll pane, or null.", :name ":get-widget"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-dragging"} {:args [], :type "boolean", :name ":is-flinging"} {:args [], :type "boolean", :name ":is-force-scroll-x"} {:args [], :type "boolean", :name ":is-force-scroll-y"} {:args [], :type "boolean", :name ":is-panning"} {:args [], :type "boolean", :name ":is-scroll-x"} {:args [], :type "boolean", :name ":is-scroll-y"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Sets the scroll offset so the specified rectangle is fully in view, if possible. Coordinates are in the scroll pane widget's\n coordinate system.", :name ":scroll-to"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Sets the scroll offset so the specified rectangle is fully in view and centered vertically in the scroll pane, if possible.\n Coordinates are in the scroll pane widget's coordinate system.", :name ":scroll-to-center"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "cancel-touch-focus"]], :text "When true (default), the {@link Stage#cancelTouchFocus()} touch focus} is cancelled when flick scrolling begins. This causes\n widgets inside the scrollpane that have received touchDown to receive touchUp when flick scrolling begins.", :name ":set-cancel-touch-focus"} {:args [["boolean" "clamp"]], :text "For flick scroll, prevents scrolling out of the widget's bounds. Default is true.", :name ":set-clamp"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fade-scroll-bars"]], :text "When true the scroll bars fade out after some time of not being used.", :name ":set-fade-scroll-bars"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["boolean" "flick-scroll"]], :name ":set-flick-scroll"} {:args [["float" "fling-time"]], :text "For flick scroll, sets the amount of time in seconds that a fling will continue to scroll. Default is 1.", :name ":set-fling-time"} {:args [["boolean" "x"] ["boolean" "y"]], :text "Forces enabling scrollbars (for non-flick scroll) and overscrolling (for flick scroll) in a direction, even if the contents\n do not exceed the bounds in that direction.", :name ":set-force-scroll"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["boolean" "overscroll-x"] ["boolean" "overscroll-y"]], :text "For flick scroll, if true the widget can be scrolled slightly past its bounds and will animate back to its bounds when\n scrolling is stopped. Default is true.", :name ":set-overscroll"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["boolean" "bottom"] ["boolean" "right"]], :text "Set the position of the vertical and horizontal scroll bars (if they exist).", :name ":set-scroll-bar-positions"} {:args [["float" "percent-x"]], :name ":set-scroll-percent-x"} {:args [["float" "percent-y"]], :name ":set-scroll-percent-y"} {:args [["float" "pixels"]], :name ":set-scroll-x"} {:args [["float" "pixels"]], :name ":set-scroll-y"} {:args [["boolean" "scrollbars-on-top"]], :text "When false (the default), the widget is clipped so it is not drawn under the scrollbars. When true, the widget is clipped to\n the entire scroll pane bounds and the scrollbars are drawn on top of the widget. If {@link #setFadeScrollBars(boolean)} is\n true, the scroll bars are always drawn on top.", :name ":set-scrollbars-on-top"} {:args [["boolean" "x"] ["boolean" "y"]], :text "Disables scrolling in a direction. The widget will be sized to the FlickScrollPane in the disabled direction.", :name ":set-scrolling-disabled"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["boolean" "smooth-scrolling"]], :name ":set-smooth-scrolling"} {:args [["ScrollPane.ScrollPaneStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "variable-size-knobs"]], :text "If true, the scroll knobs are sized based on {@link #getMaxX()} or {@link #getMaxY()}. If false, the scroll knobs are sized\n based on {@link Drawable#getMinWidth()} or {@link Drawable#getMinHeight()}. Default is true.", :name ":set-variable-size-knobs"} {:args [["float" "velocity-x"]], :name ":set-velocity-x"} {:args [["float" "velocity-y"]], :name ":set-velocity-y"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["Actor" "widget"]], :text "Sets the {@link Actor} embedded in this scroll pane.", :name ":set-widget"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "fade-alpha-seconds"] ["float" "fade-delay-seconds"]], :name ":setup-fade-scroll-bars"} {:args [["float" "distance"] ["float" "speed-min"] ["float" "speed-max"]], :text "For flick scroll, sets the overscroll distance in pixels and the speed it returns to the widget's bounds in seconds. Default\n is 50, 30, 200.", :name ":setup-overscroll"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Sets the visual scroll amount equal to the scroll amount. This can be used when setting the scroll amount without animating.", :name ":update-visual-scroll"} {:args [], :name ":validate"}]}]], :name "scroll-pane!", :type :code, :raw "(defmacro scroll-pane!\n  [entity k & options]\n  `(u/call! ^ScrollPane (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>scroll-pane</code>.</p>"} {:raw* nil, :arglists [(scroll-pane? entity)], :java [], :name "scroll-pane?", :type :code, :raw "(defn scroll-pane?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) ScrollPane))", :docstring "<p>Returns true if <code>entity</code> is a <code>scroll-pane</code>.</p>"} {:raw* "(defn select-box*\n  [arg]\n  (ActorEntity. (SelectBox. arg)))", :arglists [(select-box arg & options)], :java [["select-box" {:text "A select box (aka a drop-down list) allows a user to choose one of a number of values from a list. When inactive, the selected\n value is displayed. When activated, it shows the list of values that may be selected.\n <p>\n {@link ChangeEvent} is fired when the selectbox selection changes.\n <p>\n The preferred size of the select box is determined by the maximum text bounds of the items and the size of the\n {@link SelectBoxStyle#background}.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-items"} {:args [], :type "List", :text "Returns the list shown when the select box is open.", :name ":get-list"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "int", :name ":get-max-list-count"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "ScrollPane", :text "Returns the scroll pane containing the list that is shown when the select box is open.", :name ":get-scroll-pane"} {:args [], :type "Object", :text "Returns the first selected item, or null.", :name ":get-selected"} {:args [], :type "int", :name ":get-selected-index"} {:args [], :type "Selection", :name ":get-selection"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "SelectBox.SelectBoxStyle", :text "Returns the select box's style. Modifying the returned style may not have an effect until {@link #setStyle(SelectBoxStyle)}\n is called.", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [], :name ":hide-list"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["boolean" "disabled"]], :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["java.lang.Object[]" "new-items"]], :name ":set-items"} {:args [["com.badlogic.gdx.utils.Array" "new-items"]], :name ":set-items"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["int" "max-list-count"]], :text "Set the max number of items to display when the select box is opened. Set to 0 (the default) to display as many as fit in\n the stage height.", :name ":set-max-list-count"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["Object" "item"]], :text "Sets the selection to only the item if found, else selects the first item.", :name ":set-selected"} {:args [["int" "index"]], :text "Sets the selection to only the selected index.", :name ":set-selected-index"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["SelectBox.SelectBoxStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [], :name ":show-list"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "select-box", :type :code, :raw "(defmacro select-box\n  [arg & options]\n  `(let [entity# (select-box* ~arg)]\n     (u/calls! ^SelectBox (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.html'>SelectBox</a>.</p><pre>\n&#40;select-box &#40;style :select-box font color back scroll-style list-style&#41;\n            :set-items &#40;into-array &#91;&quot;Item 1&quot; &quot;Item 2&quot; &quot;Item 3&quot;&#93;&#41;&#41;\n&#40;select-box &#40;skin &quot;uiskin.json&quot;&#41;\n            :set-items &#40;into-array &#91;&quot;Item 1&quot; &quot;Item 2&quot; &quot;Item 3&quot;&#93;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(select-box! entity k & options)], :java [["select-box!" {:text "A select box (aka a drop-down list) allows a user to choose one of a number of values from a list. When inactive, the selected\n value is displayed. When activated, it shows the list of values that may be selected.\n <p>\n {@link ChangeEvent} is fired when the selectbox selection changes.\n <p>\n The preferred size of the select box is determined by the maximum text bounds of the items and the size of the\n {@link SelectBoxStyle#background}.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-items"} {:args [], :type "List", :text "Returns the list shown when the select box is open.", :name ":get-list"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "int", :name ":get-max-list-count"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "ScrollPane", :text "Returns the scroll pane containing the list that is shown when the select box is open.", :name ":get-scroll-pane"} {:args [], :type "Object", :text "Returns the first selected item, or null.", :name ":get-selected"} {:args [], :type "int", :name ":get-selected-index"} {:args [], :type "Selection", :name ":get-selection"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "SelectBox.SelectBoxStyle", :text "Returns the select box's style. Modifying the returned style may not have an effect until {@link #setStyle(SelectBoxStyle)}\n is called.", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [], :name ":hide-list"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["boolean" "disabled"]], :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["java.lang.Object[]" "new-items"]], :name ":set-items"} {:args [["com.badlogic.gdx.utils.Array" "new-items"]], :name ":set-items"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["int" "max-list-count"]], :text "Set the max number of items to display when the select box is opened. Set to 0 (the default) to display as many as fit in\n the stage height.", :name ":set-max-list-count"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["Object" "item"]], :text "Sets the selection to only the item if found, else selects the first item.", :name ":set-selected"} {:args [["int" "index"]], :text "Sets the selection to only the selected index.", :name ":set-selected-index"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["SelectBox.SelectBoxStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [], :name ":show-list"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "select-box!", :type :code, :raw "(defmacro select-box!\n  [entity k & options]\n  `(u/call! ^SelectBox (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>select-box</code>.</p>"} {:raw* nil, :arglists [(select-box? entity)], :java [], :name "select-box?", :type :code, :raw "(defn select-box?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) SelectBox))", :docstring "<p>Returns true if <code>entity</code> is a <code>select-box</code>.</p>"} {:raw* "(defn slider*\n  [{:keys [min max step vertical?]\n    :or {min 0 max 10 step 1 vertical? false}}\n   arg]\n  (ActorEntity.\n    (Slider. (float min) (float max) (float step) vertical? arg)))", :arglists [(slider attrs arg & options)], :java [["slider" {:text "A slider is a horizontal indicator that allows a user to set a value. The slider has a range (min, max) and a stepping between\n each value the slider represents.\n <p>\n {@link ChangeEvent} is fired when the slider knob is moved. Canceling the event will move the knob to where it was previously.\n <p>\n The preferred height of a slider is determined by the larger of the knob and background. The preferred width of a slider is\n 140, a relatively arbitrary size.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-value"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-value"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :name ":get-step-size"} {:args [], :type "ProgressBar.ProgressBarStyle", :text "Returns the progress bar's style. Modifying the returned style may not have an effect until\n {@link #setStyle(ProgressBarStyle)} is called.", :name ":get-style"} {:args [], :type "Slider.SliderStyle", :text "Returns the slider's style. Modifying the returned style may not have an effect until {@link #setStyle(SliderStyle)} is\n called.", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-value"} {:args [], :type "float", :text "If {@link #setAnimateDuration(float) animating} the progress bar value, this returns the value current displayed.", :name ":get-visual-value"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :text "Returns true if the slider is being dragged.", :name ":is-dragging"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "duration"]], :text "If > 0, changes to the progress bar value via {@link #setValue(float)} will happen over this duration in seconds.", :name ":set-animate-duration"} {:args [["Interpolation" "animate-interpolation"]], :text "Sets the interpolation to use for {@link #setAnimateDuration(float)}.", :name ":set-animate-interpolation"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["boolean" "disabled"]], :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "min"] ["float" "max"]], :text "Sets the range of this progress bar. The progress bar's current value is clamped to the range.", :name ":set-range"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["float[]" "values"] ["float" "threshold"]], :text "Will make this progress bar snap to the specified values, if the knob is within the threshold.", :name ":set-snap-to-values"} {:args [["float" "step-size"]], :name ":set-step-size"} {:args [["ProgressBar.ProgressBarStyle" "style"]], :name ":set-style"} {:args [["Slider.SliderStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["float" "value"]], :type "boolean", :text "Sets the progress bar position, rounded to the nearest step size and clamped to the minimum and maximum values.\n {@link #clamp(float)} can be overridden to allow values outside of the progress bar's min/max range.", :name ":set-value"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "slider", :type :code, :raw "(defmacro slider\n  [attrs arg & options]\n  `(let [entity# (slider* ~attrs ~arg)]\n     (u/calls! ^Slider (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Slider.html'>Slider</a>.</p><pre>\n&#40;slider {:min 0 :max 10 :step 1 :vertical? false} &#40;style :slider back knob&#41;&#41;\n&#40;slider {:min 0 :max 10 :step 1 :vertical? false} &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(slider! entity k & options)], :java [["slider!" {:text "A slider is a horizontal indicator that allows a user to set a value. The slider has a range (min, max) and a stepping between\n each value the slider represents.\n <p>\n {@link ChangeEvent} is fired when the slider knob is moved. Canceling the event will move the knob to where it was previously.\n <p>\n The preferred height of a slider is determined by the larger of the knob and background. The preferred width of a slider is\n 140, a relatively arbitrary size.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-value"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-value"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :name ":get-step-size"} {:args [], :type "ProgressBar.ProgressBarStyle", :text "Returns the progress bar's style. Modifying the returned style may not have an effect until\n {@link #setStyle(ProgressBarStyle)} is called.", :name ":get-style"} {:args [], :type "Slider.SliderStyle", :text "Returns the slider's style. Modifying the returned style may not have an effect until {@link #setStyle(SliderStyle)} is\n called.", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-value"} {:args [], :type "float", :text "If {@link #setAnimateDuration(float) animating} the progress bar value, this returns the value current displayed.", :name ":get-visual-value"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :text "Returns true if the slider is being dragged.", :name ":is-dragging"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "duration"]], :text "If > 0, changes to the progress bar value via {@link #setValue(float)} will happen over this duration in seconds.", :name ":set-animate-duration"} {:args [["Interpolation" "animate-interpolation"]], :text "Sets the interpolation to use for {@link #setAnimateDuration(float)}.", :name ":set-animate-interpolation"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["boolean" "disabled"]], :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "min"] ["float" "max"]], :text "Sets the range of this progress bar. The progress bar's current value is clamped to the range.", :name ":set-range"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["float[]" "values"] ["float" "threshold"]], :text "Will make this progress bar snap to the specified values, if the knob is within the threshold.", :name ":set-snap-to-values"} {:args [["float" "step-size"]], :name ":set-step-size"} {:args [["ProgressBar.ProgressBarStyle" "style"]], :name ":set-style"} {:args [["Slider.SliderStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["float" "value"]], :type "boolean", :text "Sets the progress bar position, rounded to the nearest step size and clamped to the minimum and maximum values.\n {@link #clamp(float)} can be overridden to allow values outside of the progress bar's min/max range.", :name ":set-value"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "slider!", :type :code, :raw "(defmacro slider!\n  [entity k & options]\n  `(u/call! ^Slider (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>slider</code>.</p>"} {:raw* nil, :arglists [(slider? entity)], :java [], :name "slider?", :type :code, :raw "(defn slider?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Slider))", :docstring "<p>Returns true if <code>entity</code> is a <code>slider</code>.</p>"} {:raw* "(defn stack*\n  [children]\n  (create-group (Stack.) children))", :arglists [(stack children & options)], :java [["stack" {:text "A stack is a container that sizes its children to its size and positions them at 0,0 on top of each other.\n <p>\n The preferred and min size of the stack is the largest preferred and min size of any children. The max size of the stack is the\n smallest max size of any children.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Actor" "actor"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "stack", :type :code, :raw "(defmacro stack\n  [children & options]\n  `(let [entity# (stack* ~children)]\n     (u/calls! ^Stack (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Stack.html'>Stack</a>.</p><pre>\n&#40;stack &#91;entity-1 entity-2&#93;&#41;\n</pre>"} {:raw* nil, :arglists [(stack! entity k & options)], :java [["stack!" {:text "A stack is a container that sizes its children to its size and positions them at 0,0 on top of each other.\n <p>\n The preferred and min size of the stack is the largest preferred and min size of any children. The max size of the stack is the\n smallest max size of any children.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Actor" "actor"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "stack!", :type :code, :raw "(defmacro stack!\n  [entity k & options]\n  `(u/call! ^Stack (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>stack</code>.</p>"} {:raw* nil, :arglists [(stack? entity)], :java [], :name "stack?", :type :code, :raw "(defn stack?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Stack))", :docstring "<p>Returns true if <code>entity</code> is a <code>stack</code>.</p>"} {:raw* "(defn table*\n  [children]\n  (create-group (Table.) children))", :arglists [(table children & options)], :java [["table" {:text "A group that sizes and positions children using table constraints. By default, {@link #getTouchable()} is\n {@link Touchable#childrenOnly}.\n <p>\n The preferred and minimum sizes are that of the children when laid out in columns and rows.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "table", :type :code, :raw "(defmacro table\n  [children & options]\n  `(let [entity# (table* ~children)]\n     (u/calls! ^Table (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Table.html'>Table</a>.</p><pre>\n&#40;table &#91;entity-1 entity-2&#93;&#41;\n</pre>"} {:raw* nil, :arglists [(table! entity k & options)], :java [["table!" {:text "A group that sizes and positions children using table constraints. By default, {@link #getTouchable()} is\n {@link Touchable#childrenOnly}.\n <p>\n The preferred and minimum sizes are that of the children when laid out in columns and rows.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "table!", :type :code, :raw "(defmacro table!\n  [entity k & options]\n  `(u/call! ^Table (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>table</code>.</p>"} {:raw* nil, :arglists [(table? entity)], :java [], :name "table?", :type :code, :raw "(defn table?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Table))", :docstring "<p>Returns true if <code>entity</code> is a <code>table</code>.</p>"} {:raw* "(defn text-button*\n  [^String text arg]\n  (ActorEntity. (TextButton. text arg)))", :arglists [(text-button text arg & options)], :java [["text-button" {:text "A button with a child {@link Label} to display text.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :name ":get-click-listener"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Label", :name ":get-label"} {:args [], :type "Cell", :name ":get-label-cell"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Button.ButtonStyle", :text "Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "TextButton.TextButtonStyle", :name ":get-style"} {:args [], :type "CharSequence", :name ":get-text"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [], :type "boolean", :name ":is-checked"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-over"} {:args [], :type "boolean", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "is-checked"]], :name ":set-checked"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "is-disabled"]], :text "When true, the button will not toggle {@link #isChecked()} when clicked and will not fire a {@link ChangeEvent}.", :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Button.ButtonStyle" "style"]], :name ":set-style"} {:args [["String" "text"]], :name ":set-text"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Toggles the checked state. This method changes the checked state, which fires a {@link ChangeEvent}, so can be used to\n simulate a button click.", :name ":toggle"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "text-button", :type :code, :raw "(defmacro text-button\n  [text arg & options]\n  `(let [entity# (text-button* ~text ~arg)]\n     (u/calls! ^TextButton (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/TextButton.html'>TextButton</a>.</p><pre>\n&#40;text-button &quot;I'm a text button&quot; &#40;style :text-button up dn checked font&#41;&#41;\n&#40;text-button &quot;I'm a text button&quot; &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(text-button! entity k & options)], :java [["text-button!" {:text "A button with a child {@link Label} to display text.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :name ":get-click-listener"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Label", :name ":get-label"} {:args [], :type "Cell", :name ":get-label-cell"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Button.ButtonStyle", :text "Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is\n called.", :name ":get-style"} {:args [], :type "TextButton.TextButtonStyle", :name ":get-style"} {:args [], :type "CharSequence", :name ":get-text"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [], :type "boolean", :name ":is-checked"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-over"} {:args [], :type "boolean", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "is-checked"]], :name ":set-checked"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "is-disabled"]], :text "When true, the button will not toggle {@link #isChecked()} when clicked and will not fire a {@link ChangeEvent}.", :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Button.ButtonStyle" "style"]], :name ":set-style"} {:args [["String" "text"]], :name ":set-text"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :text "Toggles the checked state. This method changes the checked state, which fires a {@link ChangeEvent}, so can be used to\n simulate a button click.", :name ":toggle"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "text-button!", :type :code, :raw "(defmacro text-button!\n  [entity k & options]\n  `(u/call! ^TextButton (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>text-button</code>.</p>"} {:raw* nil, :arglists [(text-button? entity)], :java [], :name "text-button?", :type :code, :raw "(defn text-button?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) TextButton))", :docstring "<p>Returns true if <code>entity</code> is a <code>text-button</code>.</p>"} {:raw* "(defn text-field*\n  [^String text arg]\n  (ActorEntity. (TextField. text arg)))", :arglists [(text-field text arg & options)], :java [["text-field" {:text "A single-line text input field.\n <p>\n The preferred height of a text field is the height of the {@link TextFieldStyle#font} and {@link TextFieldStyle#background}.\n The preferred width of a text field is 150, a relatively arbitrary size.\n <p>\n The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is\n pressed. Clipboard functionality is provided via the {@link Clipboard} interface. Currently there are two standard\n implementations, one for the desktop and one for Android. The Android clipboard is a stub, as copy & pasting on Android is not\n supported yet.\n <p>\n The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events\n generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.\n The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard}\n implementation will bring up the default IME.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :name ":clear-selection"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [], :text "Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField.", :name ":copy"} {:args [], :text "Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes\n it.", :name ":cut"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "int", :name ":get-cursor-position"} {:args [], :type "InputListener", :name ":get-default-input-listener"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "int", :name ":get-max-length"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "String", :name ":get-message-text"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "TextField.OnscreenKeyboard", :text "Default is an instance of {@link DefaultOnscreenKeyboard}.", :name ":get-onscreen-keyboard"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "String", :name ":get-selection"} {:args [], :type "int", :name ":get-selection-start"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "TextField.TextFieldStyle", :text "Returns the text field's style. Modifying the returned style may not have an effect until {@link #setStyle(TextFieldStyle)}\n is called.", :name ":get-style"} {:args [], :type "String", :name ":get-text"} {:args [], :type "TextField.TextFieldFilter", :name ":get-text-field-filter"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-password-mode"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["boolean" "up"]], :text "Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.", :name ":next"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [], :name ":select-all"} {:args [["float" "blink-time"]], :name ":set-blink-time"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Clipboard" "clipboard"]], :name ":set-clipboard"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["int" "cursor-position"]], :text "Sets the cursor position and clears any selection.", :name ":set-cursor-position"} {:args [["boolean" "disabled"]], :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["boolean" "focus-traversal"]], :text "If true (the default), tab/shift+tab will move to the next text field.", :name ":set-focus-traversal"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["int" "max-length"]], :name ":set-max-length"} {:args [["String" "message-text"]], :text "Sets the text that will be drawn in the text field if no text has been entered.", :name ":set-message-text"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["boolean" "only-font-chars"]], :text "When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.\n When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped\n when typed or pasted.", :name ":set-only-font-chars"} {:args [["TextField.OnscreenKeyboard" "keyboard"]], :name ":set-onscreen-keyboard"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["char" "password-character"]], :text "Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149\n (bullet).", :name ":set-password-character"} {:args [["boolean" "password-mode"]], :text "If true, the text in this text field will be shown as bullet characters.", :name ":set-password-mode"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["boolean" "right-aligned"]], :name ":set-right-aligned"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["int" "selection-start"] ["int" "selection-end"]], :text "Sets the selected text.", :name ":set-selection"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["TextField.TextFieldStyle" "style"]], :name ":set-style"} {:args [["String" "str"]], :name ":set-text"} {:args [["TextField.TextFieldFilter" "filter"]], :name ":set-text-field-filter"} {:args [["TextField.TextFieldListener" "listener"]], :name ":set-text-field-listener"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "text-field", :type :code, :raw "(defmacro text-field\n  [text arg & options]\n  `(let [entity# (text-field* ~text ~arg)]\n     (u/calls! ^TextField (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/TextField.html'>TextField</a>.</p><pre>\n&#40;text-field &quot;I'm a text field&quot; &#40;style :text-field font col cur sel back&#41;&#41;\n&#40;text-field &quot;I'm a text field&quot; &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(text-field! entity k & options)], :java [["text-field!" {:text "A single-line text input field.\n <p>\n The preferred height of a text field is the height of the {@link TextFieldStyle#font} and {@link TextFieldStyle#background}.\n The preferred width of a text field is 150, a relatively arbitrary size.\n <p>\n The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is\n pressed. Clipboard functionality is provided via the {@link Clipboard} interface. Currently there are two standard\n implementations, one for the desktop and one for Android. The Android clipboard is a stub, as copy & pasting on Android is not\n supported yet.\n <p>\n The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events\n generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.\n The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard}\n implementation will bring up the default IME.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :name ":clear-selection"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [], :text "Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField.", :name ":copy"} {:args [], :text "Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes\n it.", :name ":cut"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "int", :name ":get-cursor-position"} {:args [], :type "InputListener", :name ":get-default-input-listener"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "int", :name ":get-max-length"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "String", :name ":get-message-text"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "TextField.OnscreenKeyboard", :text "Default is an instance of {@link DefaultOnscreenKeyboard}.", :name ":get-onscreen-keyboard"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "String", :name ":get-selection"} {:args [], :type "int", :name ":get-selection-start"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "TextField.TextFieldStyle", :text "Returns the text field's style. Modifying the returned style may not have an effect until {@link #setStyle(TextFieldStyle)}\n is called.", :name ":get-style"} {:args [], :type "String", :name ":get-text"} {:args [], :type "TextField.TextFieldFilter", :name ":get-text-field-filter"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-disabled"} {:args [], :type "boolean", :name ":is-password-mode"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["boolean" "up"]], :text "Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.", :name ":next"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [], :name ":select-all"} {:args [["float" "blink-time"]], :name ":set-blink-time"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Clipboard" "clipboard"]], :name ":set-clipboard"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["int" "cursor-position"]], :text "Sets the cursor position and clears any selection.", :name ":set-cursor-position"} {:args [["boolean" "disabled"]], :name ":set-disabled"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["boolean" "focus-traversal"]], :text "If true (the default), tab/shift+tab will move to the next text field.", :name ":set-focus-traversal"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["int" "max-length"]], :name ":set-max-length"} {:args [["String" "message-text"]], :text "Sets the text that will be drawn in the text field if no text has been entered.", :name ":set-message-text"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["boolean" "only-font-chars"]], :text "When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.\n When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped\n when typed or pasted.", :name ":set-only-font-chars"} {:args [["TextField.OnscreenKeyboard" "keyboard"]], :name ":set-onscreen-keyboard"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["char" "password-character"]], :text "Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149\n (bullet).", :name ":set-password-character"} {:args [["boolean" "password-mode"]], :text "If true, the text in this text field will be shown as bullet characters.", :name ":set-password-mode"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["boolean" "right-aligned"]], :name ":set-right-aligned"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["int" "selection-start"] ["int" "selection-end"]], :text "Sets the selected text.", :name ":set-selection"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["TextField.TextFieldStyle" "style"]], :name ":set-style"} {:args [["String" "str"]], :name ":set-text"} {:args [["TextField.TextFieldFilter" "filter"]], :name ":set-text-field-filter"} {:args [["TextField.TextFieldListener" "listener"]], :name ":set-text-field-listener"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "text-field!", :type :code, :raw "(defmacro text-field!\n  [entity k & options]\n  `(u/call! ^TextField (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>text-field</code>.</p>"} {:raw* nil, :arglists [(text-field? entity)], :java [], :name "text-field?", :type :code, :raw "(defn text-field?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) TextField))", :docstring "<p>Returns true if <code>entity</code> is a <code>text-field</code>.</p>"} {:raw* "(defn tree*\n  [children arg]\n  (create-group (Tree. arg) children))", :arglists [(tree children arg & options)], :java [["tree" {:text "A tree widget where each node has an icon, actor, and child nodes.\n <p>\n The preferred size of the tree is determined by the preferred size of the actors for the expanded nodes.\n <p>\n {@link ChangeEvent} is fired when the selected node changes.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Tree.Node" "node"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all tree nodes.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [], :name ":collapse-all"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [], :name ":expand-all"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["com.badlogic.gdx.utils.Array" "objects"]], :name ":find-expanded-objects"} {:args [["Object" "object"]], :type "Tree.Node", :text "Returns the node with the specified object, or null.", :name ":find-node"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :text "Returns the click listener the tree uses for clicking on nodes and the over node.", :name ":get-click-listener"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [["float" "y"]], :type "Tree.Node", :name ":get-node-at"} {:args [], :type "Array", :name ":get-nodes"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Tree.Node", :name ":get-over-node"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "Array", :name ":get-root-nodes"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Selection", :name ":get-selection"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Tree.TreeStyle", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [["int" "index"] ["Tree.Node" "node"]], :name ":insert"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Tree.Node" "node"]], :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["com.badlogic.gdx.utils.Array" "objects"]], :name ":restore-expanded-objects"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["float" "left"] ["float" "right"]], :text "Sets the amount of horizontal space between the node actors and icons.", :name ":set-icon-spacing"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["Tree.Node" "over-node"]], :name ":set-over-node"} {:args [["float" "padding"]], :text "Sets the amount of horizontal space between the nodes and the left/right edges of the tree.", :name ":set-padding"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Tree.TreeStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["float" "y-spacing"]], :text "Sets the amount of vertical space between nodes.", :name ":set-yspacing"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "tree", :type :code, :raw "(defmacro tree\n  [children arg & options]\n  `(let [entity# (tree* ~children ~arg)]\n     (u/calls! ^Tree (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Tree.html'>Tree</a>.</p><pre>\n&#40;tree &#91;entity-1 entity-2&#93; &#40;style :tree plus minus selection&#41;&#41;\n&#40;tree &#91;entity-1 entity-2&#93; &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(tree! entity k & options)], :java [["tree!" {:text "A tree widget where each node has an icon, actor, and child nodes.\n <p>\n The preferred size of the tree is determined by the preferred size of the actors for the expanded nodes.\n <p>\n {@link ChangeEvent} is fired when the selected node changes.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Tree.Node" "node"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all tree nodes.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [], :name ":collapse-all"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [], :name ":expand-all"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["com.badlogic.gdx.utils.Array" "objects"]], :name ":find-expanded-objects"} {:args [["Object" "object"]], :type "Tree.Node", :text "Returns the node with the specified object, or null.", :name ":find-node"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "ClickListener", :text "Returns the click listener the tree uses for clicking on nodes and the over node.", :name ":get-click-listener"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [["float" "y"]], :type "Tree.Node", :name ":get-node-at"} {:args [], :type "Array", :name ":get-nodes"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "Tree.Node", :name ":get-over-node"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "Array", :name ":get-root-nodes"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Selection", :name ":get-selection"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Tree.TreeStyle", :name ":get-style"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [["int" "index"] ["Tree.Node" "node"]], :name ":insert"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Tree.Node" "node"]], :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [["com.badlogic.gdx.utils.Array" "objects"]], :name ":restore-expanded-objects"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["float" "left"] ["float" "right"]], :text "Sets the amount of horizontal space between the node actors and icons.", :name ":set-icon-spacing"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["Tree.Node" "over-node"]], :name ":set-over-node"} {:args [["float" "padding"]], :text "Sets the amount of horizontal space between the nodes and the left/right edges of the tree.", :name ":set-padding"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Tree.TreeStyle" "style"]], :name ":set-style"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["float" "y-spacing"]], :text "Sets the amount of vertical space between nodes.", :name ":set-yspacing"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "tree!", :type :code, :raw "(defmacro tree!\n  [entity k & options]\n  `(u/call! ^Tree (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>tree</code>.</p>"} {:raw* nil, :arglists [(tree? entity)], :java [], :name "tree?", :type :code, :raw "(defn tree?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Tree))", :docstring "<p>Returns true if <code>entity</code> is a <code>tree</code>.</p>"} {:raw* "(defn vertical*\n  [children]\n  (create-group (VerticalGroup.) children))", :arglists [(vertical children & options)], :java [["vertical" {:text "A group that lays out its children on top of each other in a single column. This can be easier than using {@link Table} when\n actors need to be inserted in the middle of the group.\n <p>\n The preferred width is the largest preferred width of any child. The preferred height is the sum of the children's preferred\n heights, plus spacing between them if set. The min size is the preferred size and the max size is 0.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "VerticalGroup", :text "Sets the alignment of widgets within the vertical group. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom}, {@link Align#left}, {@link Align#right}, or any combination of those.", :name ":align"} {:args [], :type "VerticalGroup", :text "Sets the alignment of widgets within the vertical group to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [], :type "VerticalGroup", :name ":fill"} {:args [["float" "fill"]], :type "VerticalGroup", :name ":fill"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-fill"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "boolean", :name ":get-reverse"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :name ":get-space"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "VerticalGroup", :text "Sets {@link Align#left} and clears {@link Align#right} for the alignment of widgets within the vertical group.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["float" "pad"]], :type "VerticalGroup", :text "Sets the padTop, padLeft, padBottom, and padRight to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "VerticalGroup", :name ":pad"} {:args [["float" "pad-bottom"]], :type "VerticalGroup", :name ":pad-bottom"} {:args [["float" "pad-left"]], :type "VerticalGroup", :name ":pad-left"} {:args [["float" "pad-right"]], :type "VerticalGroup", :name ":pad-right"} {:args [["float" "pad-top"]], :type "VerticalGroup", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :type "VerticalGroup", :text "The children will be ordered from bottom to top rather than the default top to bottom.", :name ":reverse"} {:args [["boolean" "reverse"]], :type "VerticalGroup", :text "If true, the children will be ordered from bottom to top rather than the default top to bottom.", :name ":reverse"} {:args [], :type "VerticalGroup", :text "Sets {@link Align#right} and clears {@link Align#left} for the alignment of widgets within the vertical group.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "spacing"]], :type "VerticalGroup", :text "Sets the space between children.", :name ":space"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "vertical", :type :code, :raw "(defmacro vertical\n  [children & options]\n  `(let [entity# (vertical* ~children)]\n     (u/calls! ^VerticalGroup (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/VerticalGroup.html'>VerticalGroup</a>.</p><pre>\n&#40;vertical &#91;entity-1 entity-2&#93;&#41;\n</pre>"} {:raw* nil, :arglists [(vertical! entity k & options)], :java [["vertical!" {:text "A group that lays out its children on top of each other in a single column. This can be easier than using {@link Table} when\n actors need to be inserted in the middle of the group.\n <p>\n The preferred width is the largest preferred width of any child. The preferred height is the sum of the children's preferred\n heights, plus spacing between them if set. The min size is the preferred size and the max size is 0.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "VerticalGroup", :text "Sets the alignment of widgets within the vertical group. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom}, {@link Align#left}, {@link Align#right}, or any combination of those.", :name ":align"} {:args [], :type "VerticalGroup", :text "Sets the alignment of widgets within the vertical group to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [], :type "VerticalGroup", :name ":fill"} {:args [["float" "fill"]], :type "VerticalGroup", :name ":fill"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "float", :name ":get-fill"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "boolean", :name ":get-reverse"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "float", :name ":get-space"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "VerticalGroup", :text "Sets {@link Align#left} and clears {@link Align#right} for the alignment of widgets within the vertical group.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["float" "pad"]], :type "VerticalGroup", :text "Sets the padTop, padLeft, padBottom, and padRight to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "VerticalGroup", :name ":pad"} {:args [["float" "pad-bottom"]], :type "VerticalGroup", :name ":pad-bottom"} {:args [["float" "pad-left"]], :type "VerticalGroup", :name ":pad-left"} {:args [["float" "pad-right"]], :type "VerticalGroup", :name ":pad-right"} {:args [["float" "pad-top"]], :type "VerticalGroup", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :type "VerticalGroup", :text "The children will be ordered from bottom to top rather than the default top to bottom.", :name ":reverse"} {:args [["boolean" "reverse"]], :type "VerticalGroup", :text "If true, the children will be ordered from bottom to top rather than the default top to bottom.", :name ":reverse"} {:args [], :type "VerticalGroup", :text "Sets {@link Align#right} and clears {@link Align#left} for the alignment of widgets within the vertical group.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "spacing"]], :type "VerticalGroup", :text "Sets the space between children.", :name ":space"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :name ":validate"}]}]], :name "vertical!", :type :code, :raw "(defmacro vertical!\n  [entity k & options]\n  `(u/call! ^VerticalGroup (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>vertical</code>.</p>"} {:raw* nil, :arglists [(vertical? entity)], :java [], :name "vertical?", :type :code, :raw "(defn vertical?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) VerticalGroup))", :docstring "<p>Returns true if <code>entity</code> is a <code>vertical</code>.</p>"} {:raw* "(defn window*\n  [children ^String title arg]\n  (create-group (Window. title arg) children))", :arglists [(window children title arg & options)], :java [["window" {:text "A table that can be dragged and act as a modal window. The top padding is used as the window's title height.\n <p>\n The preferred size of a window is the preferred size of the title text and the children as laid out by the table. After adding\n children to the window, it can be convenient to call {@link #pack()} to size the window to the size of the children.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Table", :name ":get-button-table"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Window.WindowStyle", :text "Returns the window's style. Modifying the returned style may not have an effect until {@link #setStyle(WindowStyle)} is\n called.", :name ":get-style"} {:args [], :type "String", :name ":get-title"} {:args [], :type "float", :name ":get-title-width"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-dragging"} {:args [], :type "boolean", :name ":is-modal"} {:args [], :type "boolean", :name ":is-movable"} {:args [], :type "boolean", :name ":is-resizable"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "keep-within-stage"]], :name ":set-keep-within-stage"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["boolean" "is-modal"]], :name ":set-modal"} {:args [["boolean" "is-movable"]], :name ":set-movable"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["boolean" "is-resizable"]], :name ":set-resizable"} {:args [["int" "resize-border"]], :name ":set-resize-border"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Window.WindowStyle" "style"]], :name ":set-style"} {:args [["String" "title"]], :name ":set-title"} {:args [["int" "title-alignment"]], :name ":set-title-alignment"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "window", :type :code, :raw "(defmacro window\n  [children title arg & options]\n  `(let [entity# (window* ~children ~title ~arg)]\n     (u/calls! ^Window (u/get-obj entity# :object) ~@options)\n     entity#))", :docstring "<p>Returns an entity based on <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/ui/Window.html'>Window</a>.</p><pre>\n&#40;window &#91;entity-1 entity-2&#93; &quot;I'm a window&quot; &#40;style :window title font col&#41;&#41;\n&#40;window &#91;entity-1 entity-2&#93; &quot;I'm a window&quot; &#40;skin &quot;uiskin.json&quot;&#41;&#41;\n</pre>"} {:raw* nil, :arglists [(window! entity k & options)], :java [["window!" {:text "A table that can be dragged and act as a modal window. The top padding is used as the window's title height.\n <p>\n The preferred size of a window is the preferred size of the title text and the children as laid out by the table. After adding\n children to the window, it can be convenient to call {@link #pack()} to size the window to the size of the children.", :items [{:args [["float" "delta"]], :text "Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.\n <p>\n The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.", :name ":act"} {:args [["float" "delta"]], :name ":act"} {:args [["String" "text"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "label-style-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["Color" "color"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [["String" "text"] ["String" "font-name"] ["String" "color-name"]], :type "Cell", :text "Adds a new cell with a label. This may only be called if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":add"} {:args [], :type "Cell", :text "Adds a cell without a widget.", :name ":add"} {:args [["Actor" "actor"]], :type "Cell", :text "Adds a new cell to the table with the specified actor.", :name ":add"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :name ":add"} {:args [["Action" "action"]], :name ":add-action"} {:args [["Actor" "actor"]], :text "Adds an actor as a child of this group. The actor is first removed from its parent group, if any.", :name ":add-actor"} {:args [["Actor" "actor-after"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately after another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-after"} {:args [["int" "index"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, at a specific index. The actor is first removed from its parent group, if any.", :name ":add-actor-at"} {:args [["Actor" "actor-before"] ["Actor" "actor"]], :text "Adds an actor as a child of this group, immediately before another child actor. The actor is first removed from its parent\n group, if any.", :name ":add-actor-before"} {:args [["EventListener" "listener"]], :type "boolean", :text "Adds a listener that is only notified during the capture phase.", :name ":add-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :text "Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.", :name ":add-listener"} {:args [["int" "align"]], :type "Table", :text "Sets the alignment of the logical table within the table widget. Set to {@link Align#center}, {@link Align#top},\n {@link Align#bottom} , {@link Align#left} , {@link Align#right}, or any combination of those.", :name ":align"} {:args [["Drawable" "background"]], :type "Table", :name ":background"} {:args [["String" "drawable-name"]], :type "Table", :name ":background"} {:args [], :type "Table", :text "Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table widget.", :name ":bottom"} {:args [], :type "Table", :text "Sets the alignment of the logical table within the table widget to {@link Align#center}. This clears any other alignment.", :name ":center"} {:args [], :text "Removes all actions and listeners on this actor.", :name ":clear"} {:args [], :text "Removes all children, actions, and listeners from this group.", :name ":clear"} {:args [], :text "Removes all actions on this actor.", :name ":clear-actions"} {:args [], :text "Removes all actors from this group.", :name ":clear-children"} {:args [], :text "Removes all actors and cells from the table.", :name ":clear-children"} {:args [], :text "Removes all listeners on this actor.", :name ":clear-listeners"} {:args [], :type "boolean", :text "Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds.", :name ":clip-begin"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :type "boolean", :text "Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The transform\n matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call to\n {@link #clipEnd()} if true is returned.", :name ":clip-begin"} {:args [], :text "Ends clipping begun by {@link #clipBegin(float, float, float, float)}.", :name ":clip-end"} {:args [["int" "column"]], :type "Cell", :text "Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting\n at 0.", :name ":column-defaults"} {:args [], :type "Table", :text "Turns on all debug lines.", :name ":debug"} {:args [["BaseTableLayout.Debug" "debug"]], :type "Table", :text "Turns on debug lines.", :name ":debug"} {:args [], :type "Table", :text "Turns on cell debug lines.", :name ":debug-cell"} {:args [], :type "Table", :text "Turns on table debug lines.", :name ":debug-table"} {:args [], :type "Table", :text "Turns on widget debug lines.", :name ":debug-widget"} {:args [], :type "Cell", :text "The cell values that will be used as the defaults for all cells.", :name ":defaults"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the actor. The Batch is configured to draw in the parent's coordinate system.\n {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)\n This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on\n the Batch. If {@link Batch#end()} is called to draw without the Batch then {@link Batch#begin()} must be called before the\n method returns.\n <p>\n The default implementation does nothing.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "Draws the group and its children. The default implementation calls {@link #applyTransform(Batch, Matrix4)} if needed, then\n {@link #drawChildren(Batch, float)}, then {@link #resetTransform(Batch)} if needed.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :text "If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget group is laid\n out.", :name ":draw"} {:args [["Batch" "batch"] ["float" "parent-alpha"]], :name ":draw"} {:args [["String" "name"]], :type "Actor", :text "Returns the first actor found with the specified name. Note this recursively compares the name of every actor in the group.", :name ":find-actor"} {:args [["Event" "event"]], :type "boolean", :text "Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor\n actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.\n <p>\n Events are fired in 2 phases.\n <ol>\n <li>The first phase (the \"capture\" phase) notifies listeners on each actor starting at the root and propagating downward to\n (and including) this actor.</li>\n <li>The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,\n propagating upward to the root.</li>\n </ol>\n If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.", :name ":fire"} {:args [], :type "Array", :name ":get-actions"} {:args [], :type "int", :name ":get-align"} {:args [], :type "Drawable", :name ":get-background"} {:args [], :type "Table", :name ":get-button-table"} {:args [], :type "Array", :name ":get-capture-listeners"} {:args [["Actor" "actor"]], :type "Cell", :text "Returns the cell for the specified widget in this table, or null.", :name ":get-cell"} {:args [], :type "List", :text "Returns the cells for this table.", :name ":get-cells"} {:args [], :type "SnapshotArray", :text "Returns an ordered list of child actors in this group.", :name ":get-children"} {:args [], :type "boolean", :name ":get-clip"} {:args [], :type "Color", :text "Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color.", :name ":get-color"} {:args [], :type "BaseTableLayout.Debug", :name ":get-debug"} {:args [], :type "float", :name ":get-height"} {:args [], :type "Array", :name ":get-listeners"} {:args [], :type "float", :name ":get-max-height"} {:args [], :type "float", :name ":get-max-width"} {:args [], :type "float", :name ":get-min-height"} {:args [], :type "float", :name ":get-min-width"} {:args [], :type "String", :name ":get-name"} {:args [], :type "float", :name ":get-origin-x"} {:args [], :type "float", :name ":get-origin-y"} {:args [], :type "float", :name ":get-pad-bottom"} {:args [], :type "Value", :name ":get-pad-bottom-value"} {:args [], :type "float", :name ":get-pad-left"} {:args [], :type "Value", :name ":get-pad-left-value"} {:args [], :type "float", :name ":get-pad-right"} {:args [], :type "Value", :name ":get-pad-right-value"} {:args [], :type "float", :name ":get-pad-top"} {:args [], :type "Value", :name ":get-pad-top-value"} {:args [], :type "float", :text "Returns {@link #getPadLeft()} plus {@link #getPadRight()}.", :name ":get-pad-x"} {:args [], :type "float", :text "Returns {@link #getPadTop()} plus {@link #getPadBottom()}.", :name ":get-pad-y"} {:args [], :type "Group", :text "Returns the parent actor, or null if not in a group.", :name ":get-parent"} {:args [], :type "float", :name ":get-pref-height"} {:args [], :type "float", :name ":get-pref-width"} {:args [], :type "float", :text "Returns x plus width.", :name ":get-right"} {:args [], :type "float", :name ":get-rotation"} {:args [["float" "y"]], :type "int", :text "Returns the row index for the y coordinate.", :name ":get-row"} {:args [], :type "float", :name ":get-scale-x"} {:args [], :type "float", :name ":get-scale-y"} {:args [], :type "Stage", :text "Returns the stage that this actor is currently in, or null if not in a stage.", :name ":get-stage"} {:args [], :type "Window.WindowStyle", :text "Returns the window's style. Modifying the returned style may not have an effect until {@link #setStyle(WindowStyle)} is\n called.", :name ":get-style"} {:args [], :type "String", :name ":get-title"} {:args [], :type "float", :name ":get-title-width"} {:args [], :type "float", :text "Returns y plus height.", :name ":get-top"} {:args [], :type "Touchable", :name ":get-touchable"} {:args [], :type "Object", :name ":get-user-object"} {:args [], :type "float", :name ":get-width"} {:args [], :type "float", :name ":get-x"} {:args [], :type "float", :name ":get-y"} {:args [], :type "int", :text "Returns the z-index of this actor.", :name ":get-zindex"} {:args [], :type "boolean", :name ":has-children"} {:args [], :type "boolean", :text "Returns true if the actor's parent is not null.", :name ":has-parent"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :text "Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and\n {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system (0,0\n is the bottom left of the actor and width,height is the upper right).\n <p>\n This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not\n occur on this Actor.\n <p>\n The default implementation returns this actor if the point is within this actor's bounds.", :name ":hit"} {:args [["float" "x"] ["float" "y"] ["boolean" "touchable"]], :type "Actor", :name ":hit"} {:args [], :name ":invalidate"} {:args [], :name ":invalidate-hierarchy"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the ascendant of the specified actor.", :name ":is-ascendant-of"} {:args [["Actor" "actor"]], :type "boolean", :text "Returns true if this actor is the same as or is the descendant of the specified actor.", :name ":is-descendant-of"} {:args [], :type "boolean", :name ":is-dragging"} {:args [], :type "boolean", :name ":is-modal"} {:args [], :type "boolean", :name ":is-movable"} {:args [], :type "boolean", :name ":is-resizable"} {:args [], :type "boolean", :text "Returns true if input events are processed by this actor.", :name ":is-touchable"} {:args [], :type "boolean", :name ":is-transform"} {:args [], :type "boolean", :name ":is-visible"} {:args [], :name ":layout"} {:args [], :type "Table", :text "Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table widget.", :name ":left"} {:args [["Actor" "ascendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent.", :name ":local-to-ascendant-coordinates"} {:args [["Actor" "descendant"] ["Vector2" "local-coords"]], :type "Vector2", :text "Converts coordinates for this group to those of a descendant actor. The descendant does not need to be a direct child.", :name ":local-to-descendant-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the parent's coordinates.", :name ":local-to-parent-coordinates"} {:args [["Vector2" "local-coords"]], :type "Vector2", :text "Transforms the specified point in the actor's coordinates to be in the stage's coordinates.", :name ":local-to-stage-coordinates"} {:args [["float" "x"] ["float" "y"]], :name ":move-by"} {:args [], :type "boolean", :text "Returns true if the widget's layout has been {@link #invalidate() invalidated}.", :name ":needs-layout"} {:args [["Event" "event"] ["boolean" "capture"]], :type "boolean", :text "Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,\n this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}\n must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.", :name ":notify"} {:args [], :name ":pack"} {:args [["Value" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["Value" "top"] ["Value" "left"] ["Value" "bottom"] ["Value" "right"]], :type "Table", :name ":pad"} {:args [["float" "pad"]], :type "Table", :text "Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.", :name ":pad"} {:args [["float" "top"] ["float" "left"] ["float" "bottom"] ["float" "right"]], :type "Table", :name ":pad"} {:args [["Value" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["float" "pad-bottom"]], :type "Table", :text "Padding at the bottom edge of the table.", :name ":pad-bottom"} {:args [["Value" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["float" "pad-left"]], :type "Table", :text "Padding at the left edge of the table.", :name ":pad-left"} {:args [["Value" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["float" "pad-right"]], :type "Table", :text "Padding at the right edge of the table.", :name ":pad-right"} {:args [["Value" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["float" "pad-top"]], :type "Table", :text "Padding at the top edge of the table.", :name ":pad-top"} {:args [["Vector2" "parent-coords"]], :type "Vector2", :text "Converts the coordinates given in the parent's coordinate system to this actor's coordinate system.", :name ":parent-to-local-coordinates"} {:args [], :text "Prints the actor hierarchy recursively for debugging purposes.", :name ":print"} {:args [], :type "boolean", :text "Removes this actor from its parent, if it has a parent.", :name ":remove"} {:args [["Action" "action"]], :name ":remove-action"} {:args [["Actor" "actor"]], :type "boolean", :text "Removes an actor from this group. If the actor will not be used again and has actions, they should be\n {@link Actor#clearActions() cleared} so the actions will be returned to their\n {@link Action#setPool(com.badlogic.gdx.utils.Pool) pool}, if any. This is not done automatically.", :name ":remove-actor"} {:args [["Actor" "actor"]], :type "boolean", :name ":remove-actor"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-capture-listener"} {:args [["EventListener" "listener"]], :type "boolean", :name ":remove-listener"} {:args [], :text "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\n and cell, column, and row defaults.", :name ":reset"} {:args [], :type "Table", :text "Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table widget.", :name ":right"} {:args [["float" "amount-in-degrees"]], :text "Adds the specified rotation to the current rotation.", :name ":rotate-by"} {:args [], :type "Cell", :text "Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults\n for all cells in the new row.", :name ":row"} {:args [["float" "scale"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Adds the specified scale to the current scale.", :name ":scale-by"} {:args [["Vector2" "screen-coords"]], :type "Vector2", :text "Transforms the specified point in screen coordinates to the actor's local coordinate system.", :name ":screen-to-local-coordinates"} {:args [["String" "drawable-name"]], :text "Sets the background drawable from the skin and adjusts the table's padding to match the background. This may only be called\n if {@link Table#Table(Skin)} or {@link #setSkin(Skin)} was used.", :name ":set-background"} {:args [["Drawable" "background"]], :text "Sets the background drawable and adjusts the table's padding to match the background.", :name ":set-background"} {:args [["Drawable" "background"] ["boolean" "adjust-padding"]], :text "Sets the background drawable and, if adjustPadding is true, sets the table's padding to {@link Drawable#getBottomHeight()} ,\n {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and {@link Drawable#getRightWidth()}.", :name ":set-background"} {:args [["float" "x"] ["float" "y"] ["float" "width"] ["float" "height"]], :text "Set bounds the x, y, width, and height.", :name ":set-bounds"} {:args [["boolean" "enabled"]], :text "Causes the contents to be clipped if they exceed the table widget bounds. Enabling clipping will set\n {@link #setTransform(boolean)} to true.", :name ":set-clip"} {:args [["Color" "color"]], :name ":set-color"} {:args [["float" "r"] ["float" "g"] ["float" "b"] ["float" "a"]], :name ":set-color"} {:args [["Rectangle" "culling-area"]], :text "Children completely outside of this rectangle will not be drawn. This is only valid for use with unrotated and unscaled\n actors!", :name ":set-culling-area"} {:args [["boolean" "fill-parent"]], :name ":set-fill-parent"} {:args [["float" "height"]], :name ":set-height"} {:args [["boolean" "keep-within-stage"]], :name ":set-keep-within-stage"} {:args [["boolean" "enabled"]], :name ":set-layout-enabled"} {:args [["boolean" "is-modal"]], :name ":set-modal"} {:args [["boolean" "is-movable"]], :name ":set-movable"} {:args [["String" "name"]], :text "Sets a name for easier identification of the actor in application code.", :name ":set-name"} {:args [["float" "origin-x"] ["float" "origin-y"]], :text "Sets the originx and originy.", :name ":set-origin"} {:args [["float" "origin-x"]], :name ":set-origin-x"} {:args [["float" "origin-y"]], :name ":set-origin-y"} {:args [["float" "x"] ["float" "y"]], :text "Sets the x and y.", :name ":set-position"} {:args [["boolean" "is-resizable"]], :name ":set-resizable"} {:args [["int" "resize-border"]], :name ":set-resize-border"} {:args [["float" "degrees"]], :name ":set-rotation"} {:args [["boolean" "round"]], :text "If true (the default), positions and sizes are rounded to integers.", :name ":set-round"} {:args [["float" "scale-xy"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"] ["float" "scale-y"]], :text "Sets the scalex and scaley.", :name ":set-scale"} {:args [["float" "scale-x"]], :name ":set-scale-x"} {:args [["float" "scale-y"]], :name ":set-scale-y"} {:args [["float" "width"] ["float" "height"]], :text "Sets the width and height.", :name ":set-size"} {:args [["Skin" "skin"]], :name ":set-skin"} {:args [["Window.WindowStyle" "style"]], :name ":set-style"} {:args [["String" "title"]], :name ":set-title"} {:args [["int" "title-alignment"]], :name ":set-title-alignment"} {:args [["Touchable" "touchable"]], :text "Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}.", :name ":set-touchable"} {:args [["boolean" "transform"]], :text "When true (the default), the Batch is transformed so children are drawn in their parent's coordinate system. This has a\n performance impact because {@link Batch#flush()} must be done before and after the transform. If the actors in a group are\n not rotated or scaled, then the transform for the group can be set to false. In this case, each child's position will be\n offset by the group's position for drawing, causing the children to appear in the correct location even though the Batch has\n not been transformed.", :name ":set-transform"} {:args [["Object" "user-object"]], :text "Sets an application specific object for convenience.", :name ":set-user-object"} {:args [["boolean" "visible"]], :text "If false, the actor will not be drawn and will not receive touch events. Default is true.", :name ":set-visible"} {:args [["float" "width"]], :name ":set-width"} {:args [["float" "x"]], :name ":set-x"} {:args [["float" "y"]], :name ":set-y"} {:args [["int" "index"]], :text "Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a\n lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.\n Setting a z-index less than zero is invalid.", :name ":set-zindex"} {:args [["float" "size"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["float" "width"] ["float" "height"]], :text "Adds the specified size to the current size.", :name ":size-by"} {:args [["com.badlogic.gdx.scenes.scene2d.Actor[]" "actors"]], :type "Cell", :text "Adds a new cell to the table with the specified actors in a {@link Stack}.", :name ":stack"} {:args [["Vector2" "stage-coords"]], :type "Vector2", :text "Transforms the specified point in the stage's coordinates to the actor's local coordinate system.", :name ":stage-to-local-coordinates"} {:args [["int" "first"] ["int" "second"]], :type "boolean", :text "Swaps two actors by index. Returns false if the swap did not occur because the indexes were out of bounds.", :name ":swap-actor"} {:args [["Actor" "first"] ["Actor" "second"]], :type "boolean", :text "Swaps two actors. Returns false if the swap did not occur because the actors are not children of this group.", :name ":swap-actor"} {:args [], :text "Changes the z-order for this actor so it is in back of all siblings.", :name ":to-back"} {:args [], :text "Changes the z-order for this actor so it is in front of all siblings.", :name ":to-front"} {:args [], :type "String", :name ":to-string"} {:args [], :type "Table", :text "Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table widget.", :name ":top"} {:args [], :name ":validate"}]}]], :name "window!", :type :code, :raw "(defmacro window!\n  [entity k & options]\n  `(u/call! ^Window (u/get-obj ~entity :object) ~k ~@options))", :docstring "<p>Calls a single method on a <code>window</code>.</p>"} {:raw* nil, :arglists [(window? entity)], :java [], :name "window?", :type :code, :raw "(defn window?\n  [entity]\n  (isa? (type (u/get-obj entity :object)) Window))", :docstring "<p>Returns true if <code>entity</code> is a <code>window</code>.</p>"} {:raw* nil, :arglists [(actor-gesture-listener! screen k & options)], :java [["actor-gesture-listener!" {:text "Detects tap, long press, fling, pan, zoom, and pinch gestures on an actor. If there is only a need to detect tap, use\n {@link ClickListener}.", :items [{:args [["InputEvent" "event"] ["float" "velocity-x"] ["float" "velocity-y"] ["int" "button"]], :name ":fling"} {:args [], :type "GestureDetector", :name ":get-gesture-detector"} {:args [], :type "Actor", :name ":get-touch-down-target"} {:args [["Event" "e"]], :type "boolean", :name ":handle"} {:args [["Actor" "actor"] ["float" "x"] ["float" "y"]], :type "boolean", :text "If true is returned, additional gestures will not be triggered. No event is provided because this event is triggered by time\n passing, not by an InputEvent.", :name ":long-press"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["float" "delta-x"] ["float" "delta-y"]], :text "The delta is the difference in stage coordinates since the last pan.", :name ":pan"} {:args [["InputEvent" "event"] ["Vector2" "initial-pointer1"] ["Vector2" "initial-pointer2"] ["Vector2" "pointer1"] ["Vector2" "pointer2"]], :name ":pinch"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "count"] ["int" "button"]], :name ":tap"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :name ":touch-down"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :name ":touch-up"} {:args [["InputEvent" "event"] ["float" "initial-distance"] ["float" "distance"]], :name ":zoom"}]}]], :name "actor-gesture-listener!", :type :code, :raw "(defmacro actor-gesture-listener!\n  [screen k & options]\n  `(let [listeners# (u/get-obj ~screen :ui-listeners)\n         ^ActorGestureListener object#\n         (u/get-obj listeners# :actor-gesture-listener)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/ActorGestureListener.html'>ActorGestureListener</a> in the <code>screen</code>.</p>"} {:raw* nil, :arglists [(change-listener! screen k & options)], :java [["change-listener!" {:text "Listener for {@link ChangeEvent}.", :items [{:args [["ChangeListener.ChangeEvent" "event"] ["Actor" "actor"]], :name ":changed"} {:args [["Event" "event"]], :type "boolean", :name ":handle"}]}]], :name "change-listener!", :type :code, :raw "(defmacro change-listener!\n  [screen k & options]\n  `(let [listeners# (u/get-obj ~screen :ui-listeners)\n         ^ChangeListener object# (u/get-obj listeners# :change-listener)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/ChangeListener.html'>ChangeListener</a> in the <code>screen</code>.</p>"} {:raw* nil, :arglists [(click-listener! screen k & options)], :java [["click-listener!" {:text "Detects mouse over, mouse or finger touch presses, and clicks on an actor. A touch must go down over the actor and is\n considered pressed as long as it is over the actor or within the {@link #setTapSquareSize(float) tap square}. This behavior\n makes it easier to press buttons on a touch interface when the initial touch happens near the edge of the actor. Double clicks\n can be detected using {@link #getTapCount()}. Any touch (not just the first) will trigger this listener. While pressed, other\n touch downs are ignored.", :items [{:args [], :text "If a touch down is being monitored, the drag and touch up events are ignored until the next touch up.", :name ":cancel"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"]], :name ":clicked"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["Actor" "from-actor"]], :text "Called any time the mouse cursor or a finger touch is moved over an actor. On the desktop, this event occurs even when no\n mouse buttons are pressed (pointer will be -1).", :name ":enter"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["Actor" "from-actor"]], :name ":enter"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["Actor" "to-actor"]], :text "Called any time the mouse cursor or a finger touch is moved out of an actor. On the desktop, this event occurs even when no\n mouse buttons are pressed (pointer will be -1).", :name ":exit"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["Actor" "to-actor"]], :name ":exit"} {:args [], :type "int", :name ":get-button"} {:args [], :type "int", :text "The button that initially pressed this button or -1 if the button is not pressed.", :name ":get-pressed-button"} {:args [], :type "int", :text "The pointer that initially pressed this button or -1 if the button is not pressed.", :name ":get-pressed-pointer"} {:args [], :type "int", :text "Returns the number of taps within the tap count interval for the most recent click event.", :name ":get-tap-count"} {:args [], :type "float", :name ":get-tap-square-size"} {:args [], :type "float", :name ":get-touch-down-x"} {:args [], :type "float", :name ":get-touch-down-y"} {:args [["Event" "e"]], :type "boolean", :name ":handle"} {:args [["float" "x"] ["float" "y"]], :type "boolean", :name ":in-tap-square"} {:args [], :type "boolean", :text "Returns true if a touch is within the tap square.", :name ":in-tap-square"} {:args [], :text "The tap square will not longer be used for the current touch.", :name ":invalidate-tap-square"} {:args [["Actor" "actor"] ["float" "x"] ["float" "y"]], :type "boolean", :text "Returns true if the specified position is over the specified actor or within the tap square.", :name ":is-over"} {:args [], :type "boolean", :text "Returns true if the mouse or touch is over the actor or pressed and within the tap square.", :name ":is-over"} {:args [], :type "boolean", :text "Returns true if a touch is over the actor or within the tap square.", :name ":is-pressed"} {:args [], :type "boolean", :text "Returns true if a touch is over the actor or within the tap square or has been very recently. This allows the UI to show a\n press and release that was so fast it occurred within a single frame.", :name ":is-visual-pressed"} {:args [["InputEvent" "event"] ["int" "keycode"]], :type "boolean", :text "Called when a key goes down. When true is returned, the event is {@link Event#handle() handled}.", :name ":key-down"} {:args [["InputEvent" "event"] ["char" "character"]], :type "boolean", :text "Called when a key is typed. When true is returned, the event is {@link Event#handle() handled}.", :name ":key-typed"} {:args [["InputEvent" "event"] ["int" "keycode"]], :type "boolean", :text "Called when a key goes up. When true is returned, the event is {@link Event#handle() handled}.", :name ":key-up"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"]], :type "boolean", :text "Called any time the mouse is moved when a button is not down. This event only occurs on the desktop. When true is returned,\n the event is {@link Event#handle() handled}.", :name ":mouse-moved"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "amount"]], :type "boolean", :text "Called when the mouse wheel has been scrolled. When true is returned, the event is {@link Event#handle() handled}.", :name ":scrolled"} {:args [["int" "button"]], :text "Sets the button to listen for, all other buttons are ignored. Default is {@link Buttons#LEFT}. Use -1 for any button.", :name ":set-button"} {:args [["float" "tap-count-interval"]], :name ":set-tap-count-interval"} {:args [["float" "half-tap-square-size"]], :name ":set-tap-square-size"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :text "Called when a mouse button or a finger touch goes down on the actor. If true is returned, this listener will receive all\n touchDragged and touchUp events, even those not over this actor, until touchUp is received. Also when true is returned, the\n event is {@link Event#handle() handled}.", :name ":touch-down"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-down"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"]], :text "Called when a mouse button or a finger touch is moved anywhere, but only if touchDown previously returned true for the mouse\n button or touch. The touchDragged event is always {@link Event#handle() handled}.", :name ":touch-dragged"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"]], :name ":touch-dragged"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :text "Called when a mouse button or a finger touch goes up anywhere, but only if touchDown previously returned true for the mouse\n button or touch. The touchUp event is always {@link Event#handle() handled}.", :name ":touch-up"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :name ":touch-up"}]}]], :name "click-listener!", :type :code, :raw "(defmacro click-listener!\n  [screen k & options]\n  `(let [listeners# (u/get-obj ~screen :ui-listeners)\n         ^ClickListener object# (u/get-obj listeners# :click-listener)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.html'>ClickListener</a> in the <code>screen</code>.</p>"} {:raw* nil, :arglists [(drag-listener! screen k & options)], :java [["drag-listener!" {:text "Detects mouse or finger touch drags on an actor. A touch must go down over the actor and a drag won't start until it is moved\n outside the {@link #setTapSquareSize(float) tap square}. Any touch (not just the first) will trigger this listener. While\n pressed, other touch downs are ignored.", :items [{:args [], :name ":cancel"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"]], :name ":drag"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"]], :name ":drag-start"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"]], :name ":drag-stop"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["Actor" "from-actor"]], :text "Called any time the mouse cursor or a finger touch is moved over an actor. On the desktop, this event occurs even when no\n mouse buttons are pressed (pointer will be -1).", :name ":enter"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["Actor" "to-actor"]], :text "Called any time the mouse cursor or a finger touch is moved out of an actor. On the desktop, this event occurs even when no\n mouse buttons are pressed (pointer will be -1).", :name ":exit"} {:args [], :type "int", :name ":get-button"} {:args [], :type "float", :text "Returns the amount on the x axis that the touch has been dragged since the last drag event.", :name ":get-delta-x"} {:args [], :type "float", :text "Returns the amount on the y axis that the touch has been dragged since the last drag event.", :name ":get-delta-y"} {:args [], :type "float", :name ":get-tap-square-size"} {:args [], :type "float", :name ":get-touch-down-x"} {:args [], :type "float", :name ":get-touch-down-y"} {:args [["Event" "e"]], :type "boolean", :name ":handle"} {:args [], :type "boolean", :text "Returns true if a touch has been dragged outside the tap square.", :name ":is-dragging"} {:args [["InputEvent" "event"] ["int" "keycode"]], :type "boolean", :text "Called when a key goes down. When true is returned, the event is {@link Event#handle() handled}.", :name ":key-down"} {:args [["InputEvent" "event"] ["char" "character"]], :type "boolean", :text "Called when a key is typed. When true is returned, the event is {@link Event#handle() handled}.", :name ":key-typed"} {:args [["InputEvent" "event"] ["int" "keycode"]], :type "boolean", :text "Called when a key goes up. When true is returned, the event is {@link Event#handle() handled}.", :name ":key-up"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"]], :type "boolean", :text "Called any time the mouse is moved when a button is not down. This event only occurs on the desktop. When true is returned,\n the event is {@link Event#handle() handled}.", :name ":mouse-moved"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "amount"]], :type "boolean", :text "Called when the mouse wheel has been scrolled. When true is returned, the event is {@link Event#handle() handled}.", :name ":scrolled"} {:args [["int" "button"]], :text "Sets the button to listen for, all other buttons are ignored. Default is {@link Buttons#LEFT}. Use -1 for any button.", :name ":set-button"} {:args [["float" "half-tap-square-size"]], :name ":set-tap-square-size"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :text "Called when a mouse button or a finger touch goes down on the actor. If true is returned, this listener will receive all\n touchDragged and touchUp events, even those not over this actor, until touchUp is received. Also when true is returned, the\n event is {@link Event#handle() handled}.", :name ":touch-down"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :type "boolean", :name ":touch-down"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"]], :text "Called when a mouse button or a finger touch is moved anywhere, but only if touchDown previously returned true for the mouse\n button or touch. The touchDragged event is always {@link Event#handle() handled}.", :name ":touch-dragged"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"]], :name ":touch-dragged"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :text "Called when a mouse button or a finger touch goes up anywhere, but only if touchDown previously returned true for the mouse\n button or touch. The touchUp event is always {@link Event#handle() handled}.", :name ":touch-up"} {:args [["InputEvent" "event"] ["float" "x"] ["float" "y"] ["int" "pointer"] ["int" "button"]], :name ":touch-up"}]}]], :name "drag-listener!", :type :code, :raw "(defmacro drag-listener!\n  [screen k & options]\n  `(let [listeners# (u/get-obj ~screen :ui-listeners)\n         ^DragListener object# (u/get-obj listeners# :drag-listener)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/DragListener.html'>DragListener</a> in the <code>screen</code>.</p>"} {:raw* nil, :arglists [(focus-listener! screen k & options)], :java [["focus-listener!" {:text "Listener for {@link FocusEvent}.", :items [{:args [["Event" "event"]], :type "boolean", :name ":handle"} {:args [["FocusListener.FocusEvent" "event"] ["Actor" "actor"] ["boolean" "focused"]], :name ":keyboard-focus-changed"} {:args [["FocusListener.FocusEvent" "event"] ["Actor" "actor"] ["boolean" "focused"]], :name ":scroll-focus-changed"}]}]], :name "focus-listener!", :type :code, :raw "(defmacro focus-listener!\n  [screen k & options]\n  `(let [listeners# (u/get-obj ~screen :ui-listeners)\n         ^FocusListener object# (u/get-obj listeners# :focus-listener)]\n     (u/call! object# ~k ~@options)))", :docstring "<p>Calls a single method on the <a href='http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/utils/FocusListener.html'>FocusListener</a> in the <code>screen</code>.</p>"})})